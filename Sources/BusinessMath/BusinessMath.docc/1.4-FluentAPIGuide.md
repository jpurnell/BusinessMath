# Fluent API Guide

Build financial models with intuitive, declarative syntax inspired by SwiftUI.

## Overview

The BusinessMath Fluent API provides a SwiftUI-style declarative syntax for building financial models, investments, scenarios, and time series. Instead of imperative construction with initializers and setters, you describe *what* you want in a natural, readable way.

This guide shows you how to:
- Build financial models using ``ModelBuilder``
- Define investment analyses with ``InvestmentBuilder``
- Create scenarios using ``ScenarioBuilder``
- Construct time series with ``TimeSeriesBuilder``
- Choose when to use fluent APIs vs. traditional construction
- Test and debug builder-based code

## Why Fluent APIs?

Traditional construction can be verbose and error-prone:

```swift
// Traditional approach - imperative and verbose
var revenueAccount = try Account(
    entity: company,
    name: "Product Revenue",
    type: .revenue,
    timeSeries: TimeSeries(periods: periods, values: revenueValues)
)

var cogsAccount = try Account(
    entity: company,
    name: "Cost of Goods Sold",
    type: .expense,
    timeSeries: TimeSeries(periods: periods, values: cogsValues),
    expenseType: .costOfGoodsSold
)

var model = FinancialModel(entity: company)
model.addAccount(revenueAccount)
model.addAccount(cogsAccount)
```

Fluent APIs are declarative and readable:

```swift
// Fluent approach - declarative and clear
let model = buildModel(for: company) {
    Revenue {
        Product("Product Revenue")
            .price(periods: periods, values: priceValues)
            .quantity(periods: periods, values: quantityValues)
    }

    Costs {
        FixedCost("COGS", periods: periods, value: 50_000)
    }
}
```

The fluent syntax makes your intent clear, reduces boilerplate, and catches errors at compile time.

## ModelBuilder: Building Financial Models

### Basic Model Construction

Start with revenue and cost components using simple product models:

```swift
import BusinessMath

let company = Entity(
    id: "ACME001",
    primaryType: .ticker,
    name: "Acme Corp"
)

// Build a simple model with single-value revenue and costs
let model = buildModel(for: company) {
    Revenue {
        Product("Widget Sales")
            .price(50)
            .quantity(1000)
    }

    Costs {
        Fixed("Rent", 5_000)
        Fixed("Salaries", 15_000)
        Variable("Materials", 0.40)  // 40% of revenue
    }
}

// Access results
let revenue = model.calculateRevenue()  // 50,000 (50 × 1,000)
let costs = model.calculateCosts(revenue: revenue)  // 40,000 (20k fixed + 20k variable)
let profit = model.calculateProfit()  // 10,000
```

### Product-Based Revenue Models with Time Series

Define revenue from products with time-varying pricing and quantity:

```swift
let company = Entity(
	id: "ACME001",
	primaryType: .ticker,
	name: "Acme Corp"
)

let periods = [
	Period.year(2023),
	Period.year(2024),
	Period.year(2025),
	Period.year(2026)
]

let model = buildModel(for: company) {
	Revenue {
		// Product with time series for price and quantity
		Product("Widget")
			.price(periods: periods, values: [10.0, 10.0, 10.5, 10.5])
			.quantity(periods: periods, values: [10_000, 11_000, 11_500, 12_000])

		Product("Gadget")
			.price(periods: periods, values: [25.0, 25.0, 26.0, 26.0])
			.quantity(periods: periods, values: [2_000, 2_200, 2_300, 2_400])
	}

	Costs {
		// Fixed costs with time series
		FixedCost("Rent", periods: periods, value: 5_000)
		FixedCost("Salaries", periods: periods, value: 15_000)

		// Variable costs (% of revenue)
		VariableCost("Materials", rate: 0.40)  // 40% of revenue
		VariableCost("Shipping", rate: 0.05)   // 5% of revenue
	}
}

// Access period-specific results
let revenue2024 = model.totalRevenue(for: .year(2024))
let expenses2024 = model.totalExpenses(for: .year(2024))
let profit2024 = model.profit(for: .year(2024))

// Revenue is automatically calculated from price × quantity for each period
// Variable costs are automatically calculated as % of revenue for each period
```

### Multiple Revenue Sources

Combine different revenue streams using multiple products:

```swift
let company = Entity(
	id: "ACME001",
	primaryType: .ticker,
	name: "Acme Corp"
)

let model = buildModel(for: company) {
	Revenue {
		// Hardware products
		Product("Laptop")
			.price(1200)
			.quantity(50)

		Product("Monitor")
			.price(300)
			.quantity(100)

		// Recurring subscription (represented as monthly revenue)
		Product("Software Subscription")
			.price(99)
			.customers(500)
	}

	Costs {
		// Fixed operating costs
		Fixed("Rent", 10_000)
		Fixed("Salaries", 50_000)

		// Variable costs
		Variable("Materials & COGS", 0.45)  // 45% of revenue
		Variable("Sales Commission", 0.10)   // 10% of revenue
	}
}

print(model.calculateRevenue().currency())
// Total revenue = (1200×50) + (300×100) + (99×500) = 60k + 30k + 49.5k = 139.5k
```

### Conditional Components

Use Swift control flow within builders:

```swift
let includeInternationalSales = true
let hasNewProduct = false

let model = buildModel(for: company) {
    Revenue {
        // Always included
        Product("Domestic Sales")
            .price(100)
            .quantity(1000)

        // Conditionally included
        if includeInternationalSales {
            Product("International Sales")
                .price(120)
                .quantity(300)
        }

        if hasNewProduct {
            Product("New Widget")
                .price(15)
                .quantity(5000)
        }
    }

    Costs {
        Fixed("Operating Expenses", 20_000)
        Variable("Materials", 0.35)
    }
}
```

### Array-Based Components

Build components from collections using standard Swift iteration:

```swift
let company = Entity(
	id: "ACME001",
	primaryType: .ticker,
	name: "Acme Corp"
)

// Define products in an array
let products = [
	("Widget A", 10.0, 10_000),
	("Widget B", 15.0, 8_000),
	("Widget C", 20.0, 6_000)
]

let model = buildModel(for: company) {
	Revenue {
		// Add all products dynamically
		for (name, price, quantity) in products {
			Product(name)
				.price(price)
				.quantity(Double(quantity))
		}
	}

	Costs {
		Fixed("Overhead", 25_000)
		Variable("Materials", 0.30)
	}
}
```

## InvestmentBuilder: Investment Analysis

### Simple Investment Analysis

Define cash flows and automatically calculate metrics:

```swift
import BusinessMath

let company = Entity(
	id: "ACME001",
	primaryType: .ticker,
	name: "Acme Corp"
)

// Traditional approach - manual NPV/IRR calculation
let cashFlows = [-100_000.0, 30_000, 35_000, 40_000, 45_000]
let netPresentValue = npv(discountRate: 0.10, cashFlows: cashFlows)
let internalRateOfReturn = try irr(cashFlows: cashFlows)

// Fluent approach - automatic calculation with rich context
let investment = buildInvestment {
	Name("Warehouse Expansion")
	InitialInvestment(100_000)

	CashFlows {
		CashFlow(year: 1, amount: 30_000.0)
		CashFlow(year: 2, amount: 35_000.0)
		CashFlow(year: 3, amount: 40_000.0)
		CashFlow(year: 4, amount: 45_000.0)
	}

	DiscountRate(0.10)
}

// All metrics calculated automatically
print("NPV: \(investment.npv.currency())")              // ~$17,000
print("IRR: \(((investment.irr ?? 0) * 100).formatted())%")        // ~17.1%
print("Payback: \(investment.paybackPeriod ?? 0) years")  // 3 years
print("ROI: \(investment.roi * 100)%")        // ~50%```

### Investment with Dates

Use specific dates for irregular cash flows with period-based approximation:

```swift
let today = Date()
let oneYearOut = Calendar.current.date(byAdding: .year, value: 1, to: today)!
let twoYearsOut = Calendar.current.date(byAdding: .year, value: 2, to: today)!
let threeYearsOut = Calendar.current.date(byAdding: .year, value: 3, to: today)!

let investment = buildInvestment {
	Name("Equipment Purchase")
	InitialInvestment(75_000)

	CashFlows {
		CashFlow(year: 1, amount: 25_000)   // Year 1 return
		CashFlow(year: 2, amount: 30_000)   // Year 2 return
		CashFlow(year: 3, amount: 35_000)   // Year 3 return
	}

	DiscountRate(0.08)
}

// Calculates NPV and IRR
print("NPV: \(investment.npv.currency())")
print("IRR: \(((investment.irr ?? 0) * 100).formatted())%")
```

### Investment Categories

Group and analyze related investments:

```swift
let investment = buildInvestment {
    Name("Digital Transformation Initiative")
    Category("Technology")

    InitialInvestment(250_000)

    // Cash flows by category
    CashFlowCategory("Cost Savings") {
        CashFlow(year: 1, amount: 50_000)
        CashFlow(year: 2, amount: 60_000)
        CashFlow(year: 3, amount: 70_000)
    }

    CashFlowCategory("Revenue Growth") {
        CashFlow(year: 1, amount: 30_000)
        CashFlow(year: 2, amount: 40_000)
        CashFlow(year: 3, amount: 50_000)
    }

    DiscountRate(0.12)
}

// Analyze by category
let costSavingsNPV = investment.npv(for: "Cost Savings")
let revenueGrowthNPV = investment.npv(for: "Revenue Growth")
```

### Comparing Multiple Investments

Build a portfolio for comparison:

```swift
let investmentA = buildInvestment {
	Name("Project A - Quick Win")
	InitialInvestment(50_000)

	CashFlows {
		CashFlow(year: 1, amount: 30_000)
		CashFlow(year: 2, amount: 30_000)
	}

	DiscountRate(0.10)
}

let investmentB = buildInvestment {
	Name("Project B - Long-term Growth")
	InitialInvestment(100_000)

	CashFlows {
		CashFlow(year: 1, amount: 20_000)
		CashFlow(year: 2, amount: 30_000)
		CashFlow(year: 3, amount: 40_000)
		CashFlow(year: 4, amount: 50_000)
	}

	DiscountRate(0.10)
}

// Compare metrics
print("Project A: NPV = \(investmentA.npv.currency()), IRR = \(((investmentA.irr ?? 0) * 100).formatted())%")
print("Project B: NPV = \(investmentB.npv.currency()), IRR = \(((investmentB.irr ?? 0) * 100).formatted())%")

// Decision: Project B has higher NPV, but Project A has higher IRR and faster payback
```

## ScenarioBuilder: Scenario Analysis

### Creating Scenarios

Define base, best, and worst case scenarios using the ScenarioSet builder:

```swift
import BusinessMath

// Create a scenario set with multiple scenarios
let scenarios = ScenarioSet {
    Baseline {
        revenue(1_000_000)
        growth(0.15)       // 15% growth
        margin(0.60)       // 60% margin
        costs(200_000)
    }

    Optimistic {
        revenue(1_200_000)
        growth(0.25)       // 25% growth
        margin(0.65)       // 65% margin
        costs(180_000)
    }

    Pessimistic {
        revenue(800_000)
        growth(0.05)       // 5% growth
        margin(0.55)       // 55% margin
        costs(220_000)
    }
}

// Access individual scenarios
if let baseCase = scenarios.scenario(named: "Baseline") {
    print("Base revenue: \(baseCase.parameters["revenue"] ?? 0)")
}

// Or create individual scenarios with buildScenario
let customScenario = buildScenario {
    Name("Custom Scenario")
    Description("Expected performance with current assumptions")

    ScenarioDriver("Revenue Growth", value: 0.15)
    ScenarioDriver("Gross Margin", value: 0.60)
    ScenarioDriver("Operating Expenses", value: 200_000)
}
```

### Scenario Adjustments

Modify scenarios by adjusting specific parameters:

```swift
let scenario = buildScenario {
    Name("Market Expansion")

    // Base assumptions
    ScenarioDriver("Domestic Revenue", value: 1_000_000)
    ScenarioDriver("Cost of Goods Sold", value: 600_000)
    ScenarioDriver("Operating Expenses", value: 200_000)

    // Adjustments for expansion
    ScenarioAdjustment("Add International Revenue") {
        AddScenarioDriver("International Revenue", value: 300_000)
        AdjustScenarioDriver("Operating Expenses", increase: 50_000)
        AdjustScenarioDriver("Cost of Goods Sold", multiplyBy: 1.10)
    }
}

// Access scenario parameters
let domesticRevenue = scenario.parameters["Domestic Revenue"]  // 1,000,000
let opexIncrease = scenario.parameters["Operating Expenses"]   // 50,000
```

### Conditional Scenarios

Use logic to define scenario variants:

```swift
let marketCondition = "recession"
let hasNewProduct = true

let scenarios = ScenarioSet {
    ScenarioNamed("2025 Planning") {
        // Adjust based on market conditions
        if marketCondition == "growth" {
            growth(0.20)
            margin(0.65)
        } else if marketCondition == "recession" {
            growth(0.05)
            margin(0.55)
        } else {
            growth(0.10)
            margin(0.60)
        }

        // New product launch
        if hasNewProduct {
            parameter("New Product Revenue", value: 150_000)
            parameter("New Product Marketing", value: 30_000)
        }

        // Base expenses
        costs(200_000)
    }
}
```

### Sensitivity Analysis

Vary parameters to understand impact using the standard scenario templates:

```swift
// Three-way sensitivity analysis
let scenarios = ScenarioSet.standardThreeWay(
	baseRevenue: 1_000_000,
	baseGrowth: 0.10,
	variability: 0.20  // ±20% variation
)

// Access scenarios
for scenario in scenarios.scenarios {
	if let revenue = scenario.parameters["revenue"],
	   let growth = scenario.parameters["growth"] {
		print("\(scenario.name): Revenue = \(revenue.currency()), Growth = \((growth * 100).formatted())%")
	}
}

// Or build custom sensitivity scenarios
let revenueChanges: [Double] = [-0.20, -0.10, 0, 0.10, 0.20]
let sensitivitySet = ScenarioSet {
	for change in revenueChanges {
		ScenarioNamed("Revenue \(change > 0 ? "+" : "")\(Int(change * 100))%") {
			revenue(1_000_000 * (1.0 + change))
			margin(0.60)
			costs(200_000)
		}
	}
}
```

## TimeSeriesBuilder: Declarative Time Series

### Building Time Series

Create time series with natural syntax using automatic period sequencing:

```swift
import BusinessMath

let jan = Period.month(year: 2025, month: 1)

// Traditional approach
let periods = (0..<12).map { jan + $0 }
let values: [Double] = [100, 105, 110, 108, 115, 120, 118, 125, 130, 128, 135, 140]
let ts = TimeSeries(periods: periods, values: values)

// Fluent approach with automatic period sequencing
let revenue = buildTimeSeries(startingAt: jan) {
    Entry(100)  // January - period auto-sequenced from jan
    Entry(105)  // February - period is jan.next()
    Entry(110)  // March
    Entry(108)  // April
    Entry(115)  // May
    Entry(120)  // June
    Entry(118)  // July
    Entry(125)  // August
    Entry(130)  // September
    Entry(128)  // October
    Entry(135)  // November
    Entry(140)  // December
}

// Or use the standard builder with explicit periods
let revenue2 = TimeSeries {
    Period.month(year: 2025, month: 1) => 100
    Period.month(year: 2025, month: 2) => 105
    Period.month(year: 2025, month: 3) => 110
    // ...
}
```

### Named Entries

Add labels for clarity and debugging:

```swift
let jan = Period.month(year: 2025, month: 1)

let revenue = buildTimeSeries(startingAt: jan) {
	Entry(100, label: "January")
	Entry(105, label: "February")
	Entry(110, label: "March")
	Entry(108, label: "April")
	Entry(115, label: "May")
	Entry(120, label: "June")
	Entry(118, label: "July")
	Entry(125, label: "August")
	Entry(130, label: "September")
	Entry(128, label: "October")
	Entry(135, label: "November")
	Entry(140, label: "December")
}

// Labels available for debugging and display
print(revenue.label(for: jan) ?? "No label")  // "January"
```

### Array-Based Construction

Generate entries from data using standard Swift iteration:

```swift
let jan = Period.month(year: 2025, month: 1)

let historicalData: [Double] = [
	100, 105, 110, 108, 115, 120,
	118, 125, 130, 128, 135, 140
]

let revenue = buildTimeSeries(startingAt: jan) {
	for value in historicalData {
		Entry(value)
	}
}

// Or with labels
let revenue2 = buildTimeSeries(startingAt: jan) {
	for (index, value) in historicalData.enumerated() {
		Entry(value, label: "Month \(index + 1)")
	}
}
```

### Conditional Entries

Use control flow to build time series:

```swift
let jan = Period.month(year: 2025, month: 1)

let includeSeasonalBoost = true
let holidayMonths = [11, 12]  // November, December

let revenue = buildTimeSeries(startingAt: jan) {
	for month in 1...12 {
		let baseRevenue = 100_000.0

		// Apply seasonal boost for holiday months
		if includeSeasonalBoost && holidayMonths.contains(month) {
			Entry(baseRevenue * 1.3, label: "Month \(month) - Holiday Boost")
		} else {
			Entry(baseRevenue, label: "Month \(month)")
		}
	}
}
```

### Computed Entries with Growth Patterns

Generate growing sequences easily:

```swift
let jan = Period.month(year: 2025, month: 1)

// Compound growth from a starting value
let revenue = buildTimeSeries(startingAt: jan) {
	// Generate 12 months of 5% compound growth starting at 100
	GrowthFrom(startValue: 100, rate: 0.05, periods: 12)
}
// Result: [100, 105, 110.25, 115.76, 121.55, ...]

// Or use projection builder for more control
let projected = TimeSeries(from: 2023, to: 2030) {
	starting(at: 100_000)
	growing(by: 0.10)  // 10% annual growth
}

// Option 1: Use GrowthFrom (recommended for compound growth)
let revenue2 = buildTimeSeries(startingAt: jan) {
	GrowthFrom(startValue: 100.0, rate: 0.05, periods: 12)
}

// Option 2: Generate entries outside builder, then pass as array
let revenue3 = buildTimeSeries(startingAt: jan) {
	// Result builders support arrays via buildExpression
	(1...12).map { month in
		let value = 100.0 * pow(1.05, Double(month - 1))
		return Entry(value, label: "Month \(month)")
	}
}
```

## Advanced Patterns

### Nested Builders

Combine builders for complex models:

```swift
let company = Entity(
	id: "ACME001",
	primaryType: .ticker,
	name: "Acme Corp"
)

let periods = [
	Period.year(2023),
	Period.year(2024),
	Period.year(2025),
	Period.year(2026)
]

let model = buildModel(for: company) {
	Revenue {
		// Use projection builder for growing revenue
		let baseRevenue = 100_000.0
		let growthRate = 0.10

		for (index, _) in periods.enumerated() {
			let revenue = baseRevenue * pow(1 + growthRate, Double(index))
			Product("Product \(index + 1)")
				.price(revenue)
				.quantity(1)
		}
	}

	Costs {
		// Variable costs as % of revenue
		Variable("COGS", 0.40)

		// Fixed costs
		FixedCost("Operating Expenses", periods: periods, value: 20_000)
	}
}
```

### Custom Components

Define reusable builder components:

```swift
let company = Entity(
	id: "ACME001",
	primaryType: .ticker,
	name: "Acme Corp"
)

	// Custom product bundle helper
	func productBundle(_ name: String, products: [(String, Double, Double)]) -> [RevenueComponent] {
		products.map { productName, price, quantity in
			Product(productName)
				.price(price)
				.quantity(quantity)
				.toComponent()
		}
	}

	// Use custom component
	let model = buildModel(for: company) {
		Revenue {
			for component in productBundle(
				"Widget Bundle",
				products: [
					("Widget A", 10.0, 10_000),
					("Widget B", 15.0, 8_000),
					("Widget C", 20.0, 6_000)
				]
			) {
				component
			}
		}

		Costs {
			Fixed("Overhead", 25_000)
			Variable("Materials", 0.30)
		}
	}
```

## Best Practices

### When to Use Fluent APIs

**Use fluent builders when:**
- Building models with multiple components
- Creating scenarios for comparison
- Defining investments for analysis
- Constructing time series from structured data
- Readability is important (presentations, documentation)
- You want compile-time validation

**Use traditional construction when:**
- Building single-component objects
- Performance is critical (tight loops)
- Migrating existing code incrementally
- Integration with external systems
- Dynamic construction from external data sources

### Performance Considerations

Fluent APIs have minimal overhead:

```swift
// Both approaches have similar performance
// Fluent (negligible overhead from result builder)
let model1 = buildModel(for: company) {
    Revenue {
        Product("Sales")
            .price(periods: periods, values: [100, 110, 120])
            .quantity(periods: periods, values: [1000, 1100, 1200])
    }
    Costs {
        FixedCost("Overhead", periods: periods, value: 10_000)
    }
}

// Traditional (direct initialization)
let model2 = FinancialModel(entity: company)

// For 1000+ components, consider traditional approach
// For < 100 components, fluent APIs are fine
```

### Error Handling in Builders

Handle errors gracefully:

```swift
// Throwing from within builders
let model = buildModel(for: company) {
    // This compiles but may throw at runtime
    try Revenue("Sales", periods: periods, values: values)

    // Better: validate before building
    if periods.count != values.count {
        // Handle error before builder
        fatalError("Periods and values must match")
    }

    Revenue("Sales", periods: periods, values: values)
}

// Or use Result type
let modelResult = Result {
    try buildModel(for: company) {
        try Revenue("Sales", periods: periods, values: values)
        FixedCost("Overhead", periods: periods, value: 10_000)
    }
}

switch modelResult {
case .success(let model):
    print("Model built successfully")
case .failure(let error):
    print("Error building model: \(error)")
}
```

### Testing Builder-Based Code

Test fluent APIs like any other code:

```swift
import Testing
@testable import BusinessMath

@Test("ModelBuilder creates correct structure")
func testModelBuilder() {
    let company = Entity(id: "TEST", primaryType: .ticker, name: "Test")
    let periods = [Period.quarter(year: 2025, quarter: 1)]

    let model = buildModel(for: company) {
        Revenue("Sales", periods: periods, values: [100_000])
        FixedCost("Overhead", periods: periods, value: 20_000)
    }

    #expect(model.entity == company)
    #expect(model.revenueAccounts.count == 1)
    #expect(model.totalRevenue(for: periods[0]) == 100_000)
    #expect(model.totalExpenses(for: periods[0]) == 20_000)
}

@Test("InvestmentBuilder calculates metrics")
func testInvestmentBuilder() {
    let investment = buildInvestment {
        InitialInvestment(100_000)

        CashFlows {
            CashFlow(year: 1, amount: 30_000)
            CashFlow(year: 2, amount: 40_000)
            CashFlow(year: 3, amount: 50_000)
        }

        DiscountRate(0.10)
    }

    #expect(investment.initialInvestment == 100_000)
    #expect(investment.cashFlows.count == 3)
    #expect(investment.npv > 0)  // Positive NPV
    #expect(investment.irr ?? 0 > 0.10)  // IRR > discount rate
}
```

## Common Workflows

### Complete Financial Model

Build a comprehensive financial model:

```swift
let company = Entity(id: "ACME", primaryType: .ticker, name: "Acme Corp")
let jan = Period.month(year: 2025, month: 1)
let months = (0...11).map { jan + $0 }

let model = buildModel(for: company) {
	// Revenue streams
	Product("Widget Pro")
		.price(periods: months, values: Array(repeating: 10.0, count: 12))
		.quantity(periods: months, values: [10_000, 11_000, 12_000, 13_000, 14_000, 15_000,
											16_000, 17_000, 18_000, 19_000, 20_000, 21_000])

	Revenue("Subscription Services",
		   periods: months,
		   values: buildTimeSeries(startingAt: jan) {
			   GrowthFrom(startValue: 5_000, rate: 0.05, periods: 12)  // 12 months at 5% growth
		   }.valuesArray)

	// Cost structure
	VariableCost("Materials", rate: 0.40)   // 40% of revenue
	VariableCost("Shipping", rate: 0.05)   // 5% of revenue

	FixedCost("Salaries", periods: months, value: 50_000)
	FixedCost("Rent", periods: months, value: 10_000)
	FixedCost("Utilities", periods: months, value: 2_000)
}

// Analyze results
for month in months {
	let revenue = model.totalRevenue(for: month)
	let expenses = model.totalExpenses(for: month)
	let netIncome = revenue - expenses

	print("\(month): Revenue = \(revenue.currency()), Expenses = \(expenses.currency()), Net Income = \(netIncome.currency())")
}
```

### Scenario Comparison Workflow

Compare multiple scenarios:

```swift
// Define scenarios
let scenarios = [
	buildScenario {
		Name("Conservative")
		ScenarioDriver("Revenue Growth", value: 0.05)
		ScenarioDriver("Gross Margin", value: 0.55)
		ScenarioDriver("Operating Expenses", value: 220_000)
	},
	buildScenario {
		Name("Base Case")
		ScenarioDriver("Revenue Growth", value: 0.15)
		ScenarioDriver("Gross Margin", value: 0.60)
		ScenarioDriver("Operating Expenses", value: 200_000)
	},
	buildScenario {
		Name("Aggressive")
		ScenarioDriver("Revenue Growth", value: 0.25)
		ScenarioDriver("Gross Margin", value: 0.65)
		ScenarioDriver("Operating Expenses", value: 180_000)
	}
]

// Build model for each scenario
let baseRevenue = 1_000_000.0

for scenario in scenarios {
	let revenueGrowth = scenario["Revenue Growth"] ?? 0.0
	let grossMargin = scenario["Gross Margin"] ?? 0.0
	let operatingExpenses = scenario["Operating Expenses"] ?? 0.0

	let yearEndRevenue = baseRevenue * (1 + revenueGrowth)
	let grossProfit = yearEndRevenue * grossMargin
	let netIncome = grossProfit - operatingExpenses

	print("\(scenario.name):")
	print("  Revenue: \(yearEndRevenue.currency())")
	print("  Gross Profit: \(grossProfit.currency())")
	print("  Net Income: \(netIncome.currency())")
	print()
}
```

### Investment Portfolio Analysis

Analyze multiple investments:

```swift
// Define investment options
let investments = [
	buildInvestment {
		Name("Project A - Equipment Upgrade")
		Category("Capital Expenditure")
		InitialInvestment(75_000)

		CashFlows {
			CashFlow(year: 1, amount: 25_000)
			CashFlow(year: 2, amount: 30_000)
			CashFlow(year: 3, amount: 35_000)
		}

		DiscountRate(0.10)
	},
	buildInvestment {
		Name("Project B - Market Expansion")
		Category("Growth")
		InitialInvestment(150_000)

		CashFlows {
			CashFlow(year: 1, amount: 30_000)
			CashFlow(year: 2, amount: 50_000)
			CashFlow(year: 3, amount: 70_000)
			CashFlow(year: 4, amount: 90_000)
		}

		DiscountRate(0.10)
	},
	buildInvestment {
		Name("Project C - Cost Reduction")
		Category("Efficiency")
		InitialInvestment(50_000)

		CashFlows {
			CashFlow(year: 1, amount: 20_000)
			CashFlow(year: 2, amount: 20_000)
			CashFlow(year: 3, amount: 20_000)
		}

		DiscountRate(0.10)
	}
]

// Rank by NPV
let ranked = investments.sorted { $0.npv > $1.npv }

print("Investment Rankings by NPV:")
for (index, investment) in ranked.enumerated() {
	print("\(index + 1). \(investment.name ?? "")")
	print("   NPV: \(investment.npv.currency())")
	print("   IRR: \(((investment.irr ?? 0) * 100).formatted())%")
	print("   Payback: \((investment.paybackPeriod ?? .infinity).formatted()) years")
	print()
}
```

## Next Steps

- Learn about <doc:1.5-TemplateGuide> for pre-built industry models
- Explore <doc:3.3-BuildingRevenueModel> for complete modeling workflows
- Read <doc:4.2-ScenarioAnalysisGuide> for advanced scenario techniques
- Check <doc:3.8-InvestmentAnalysis> for valuation patterns
- Review <doc:1.7-ErrorHandlingGuide> for handling errors in builders

## See Also

- ``ModelBuilder``
- ``InvestmentBuilder``
- ``ScenarioBuilder``
- ``TimeSeriesBuilder``
- ``FinancialModel``
- ``Investment``
- ``FinancialScenario``
- ``TimeSeries``
