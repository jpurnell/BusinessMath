# Statistical Distributions & Descriptive Statistics

Learn how to use probability distributions and calculate descriptive statistics for data analysis and preprocessing.

## Overview

Statistical distributions and descriptive statistics are foundational tools for understanding and working with data. Whether you're analyzing historical performance, preprocessing data for machine learning, or modeling uncertainty in simulations, these tools provide essential insights.

This guide covers:
- Calculating descriptive statistics (mean, variance, skewness, etc.)
- Working with probability distributions (normal, triangular, uniform, etc.)
- Normalizing and standardizing data for analysis
- Choosing the right distribution for your use case
- Practical applications in business analytics

**Prerequisites:** Basic understanding of statistics and probability concepts.

**Estimated Time:** 30 minutes

## Part 1: Descriptive Statistics

Descriptive statistics summarize the key characteristics of your data.

### Basic Statistics

Calculate mean, median, mode, and other central tendency measures:

```swift
import BusinessMath

let salesData = [105.0, 120.0, 98.0, 135.0, 110.0, 125.0, 115.0]

// Central tendency
let avg = mean(salesData)              // 115.43
let mid = median(salesData)            // 115.0
let mostCommon = mode(salesData)       // [105, 120, 98, ...] (no repeats)

// Spread/dispersion
let stdDev = stdDev(salesData)         // 11.76
let variance = variance(salesData)     // 138.29

// Shape
let skewness = try coefficientOfSkew(salesData)  // Measures asymmetry

print("Average sales: $\(avg.currency(2))")
print("Standard deviation: $\(stdDev.currency(2))")
```

**Output:**
```
Average sales: $115.43
Standard deviation: $11.76
```

### All-in-One: Descriptives

Get a comprehensive summary with a single function:

```swift
let data = [12.5, 15.2, 13.8, 14.1, 16.0, 12.9, 15.5]

let stats = try descriptives(data)

print("Mean: \(stats.mean.number(2))")              // 14.29
print("Std Dev: \(stats.stdDev.number(2))")         // 1.29
print("Skewness: \(stats.skew.number(2))")          // Asymmetry measure
print("Coeff of Variation: \(stats.cVar.percent(1))") // Relative variability
```

### Specialized Means

Different averaging methods for different contexts:

```swift
let returns = [0.10, 0.05, -0.02, 0.08, 0.12]

// Arithmetic mean (most common)
let arithmeticMean = mean(returns)  // 0.066 (6.6%)

// Geometric mean (for compound growth rates)
let geometricMean = geometricMean(returns.map { 1 + $0 }) - 1  // More accurate for returns

// Harmonic mean (for rates and ratios)
let speeds = [60.0, 40.0, 30.0]  // mph for different segments
let avgSpeed = harmonicMean(speeds)  // 42.86 mph (correct for average speed)

// Weighted average
let grades = [85.0, 90.0, 78.0]
let weights = [0.3, 0.5, 0.2]  // 30%, 50%, 20%
let finalGrade = weightedAverage(grades, weights: weights)  // 85.9
```

### Correlation & Covariance

Measure relationships between variables:

```swift
let advertising = [1000.0, 1500.0, 2000.0, 2500.0, 3000.0]
let sales = [50.0, 65.0, 75.0, 88.0, 95.0]

// Correlation coefficient (-1 to 1)
let correlation = correlationCoefficient(advertising, sales)  // ~0.99 (strong positive)

// Covariance
let cov = covariance(advertising, sales)  // Measures joint variability

if correlation > 0.8 {
    print("Strong positive correlation: more advertising → more sales")
}
```

## Part 2: Probability Distributions

Distributions model random variability and uncertainty.

### Normal Distribution

The bell curve - most common in nature and finance:

```swift
// Generate random values from normal distribution
let mean = 100.0
let stdDev = 15.0

let normalDist = DistributionNormal(mean, stdDev)
let samples = (0..<1000).map { _ in normalDist.random() }

print("Sample mean: \(mean(samples).number(1))")     // ~100
print("Sample std dev: \(stdDev(samples).number(1))") // ~15

// Calculate probability: P(X ≤ x)
let x = 115.0
let probability = normalCDF(x, mean: mean, stdDev: stdDev)
print("P(X ≤ 115) = \(probability.percent(1))")  // ~84.1%

// Inverse: find x for given probability
let p = 0.95  // 95th percentile
let value = inverseNormalCDF(p, mean: mean, stdDev: stdDev)
print("95th percentile: \(value.number(1))")  // ~124.7
```

**Use cases:**
- Modeling returns, revenues, costs
- Quality control (± 2σ = 95% of data)
- Risk analysis (Value at Risk)

### Triangular Distribution

When you know min, most-likely, and max:

```swift
// Sales forecast: minimum $80K, most likely $100K, maximum $120K
let minSales = 80_000.0
let likelySales = 100_000.0
let maxSales = 120_000.0

let triangularDist = DistributionTriangular(min: minSales, mode: likelySales, max: maxSales)

let projections = (0..<5).map { _ in triangularDist.random() }
print("Sales scenarios: \(projections.map { $0.currency(0) })")
```

**Use cases:**
- Three-point estimates (optimistic/realistic/pessimistic)
- Expert judgment scenarios
- Project cost estimation

### Uniform Distribution

Equal probability across a range:

```swift
// Random discount between 10% and 25%
let uniformDist = DistributionUniform(min: 0.10, max: 0.25)
let discount = uniformDist.random()

print("Discount: \(discount.percent(0))")  // 10% to 25%, equally likely

// CDF: probability of discount ≤ 20%
let prob = uniformCDF(0.20, min: 0.10, max: 0.25)  // 0.667 (66.7%)
```

**Use cases:**
- Random sampling
- Monte Carlo when no information available
- Simulating uniform randomness

### Exponential Distribution

For time between events:

```swift
// Customer arrivals: average rate = 5 per hour (λ = 5)
let lambda = 5.0
let exponentialDist = DistributionExponential(lambda: lambda)

let timeBetweenCustomers = exponentialDist.random()  // Hours
print("Next customer in \(timeBetweenCustomers.number(2)) hours")

// Probability of waiting more than 0.5 hours
let waitTime = 0.5
let prob = 1 - exponentialCDF(waitTime, lambda: lambda)  // ~8.2%
```

**Use cases:**
- Time between events (arrivals, failures)
- Reliability analysis
- Queueing theory

### Other Distributions

BusinessMath supports many specialized distributions:

```swift
// Log-Normal (for prices, incomes that can't be negative)
let logNormalDist = DistributionLogNormal(mean: 4.6, stdDev: 0.2)
let stockPrice = logNormalDist.random()

// Beta (bounded between 0 and 1, for percentages)
let betaDist = DistributionBeta(alpha: 2.0, beta: 5.0)
let completionRate = betaDist.random()  // 0 to 1

// Gamma (waiting time for multiple events)
let gammaDist = DistributionGamma(shape: 2.0, scale: 3.0)
let timeToFailure = gammaDist.random()

// Chi-Squared (hypothesis testing, variance estimation)
let df = 10  // degrees of freedom
let chiSquared = distributionChiSquared(degreesOfFreedom: df)

// Student's t (small sample sizes)
let tDist = distributionT(degreesOfFreedom: df)

// F-distribution (comparing variances)
let fDist = distributionF(df1: 5, df2: 10)

// Pareto (power law, wealth distribution)
let paretoDist = DistributionPareto(scale: 1.0, shape: 2.0)

// Weibull (failure rates, lifetime modeling)
let weibullDist = DistributionWeibull(shape: 2.0, scale: 100.0)
```

## Part 3: Data Normalization & Preprocessing

Prepare data for analysis and machine learning.

### Z-Score Standardization

Transform data to mean=0, stdDev=1:

```swift
let rawData = [85.0, 92.0, 78.0, 95.0, 88.0, 90.0, 82.0]

// Standardize to z-scores
let dataMean = mean(rawData)
let dataStdDev = stdDev(rawData)

let zScores = rawData.map { zScore($0, mean: dataMean, stdDev: dataStdDev) }

print("Original: \(rawData)")
print("Z-scores: \(zScores.map { $0.number(2) })")
// Z-scores: [-0.71, 0.43, -1.42, 0.99, 0.00, 0.28, -0.57]

// Now data has mean≈0, stdDev≈1
print("Z-score mean: \(mean(zScores).number(4))")      // ~0
print("Z-score stdDev: \(stdDev(zScores).number(4))")  // ~1
```

**Use cases:**
- Before K-Means clustering (equalizes feature scales)
- Comparing variables with different units
- Neural network input preprocessing

### Detecting Outliers

Use z-scores to identify unusual values:

```swift
let data = [50.0, 52.0, 51.0, 200.0, 49.0, 53.0, 48.0]  // 200 is outlier

let dataMean = mean(data)
let dataStdDev = stdDev(data)

for (i, value) in data.enumerated() {
    let z = zScore(value, mean: dataMean, stdDev: dataStdDev)
    if abs(z) > 3 {  // More than 3 standard deviations
        print("Outlier detected at index \(i): \(value) (z=\(z.number(2)))")
    }
}
```

### Percentiles & Quantiles

Find values at specific percentiles:

```swift
let testScores = [65.0, 70.0, 75.0, 80.0, 85.0, 90.0, 95.0]

// Find 90th percentile score
let p90 = percentileLocation(testScores, percentile: 0.90)
print("90th percentile: \(p90.number(1))")  // ~93.0

// For normal distribution
let mean = 75.0
let stdDev = 10.0
let p95Score = percentileZScore(0.95) * stdDev + mean  // ~91.4
```

## Part 4: Statistical Testing & Inference

### Confidence Intervals

Estimate population parameters from samples:

```swift
let sampleMean = 500.0
let sampleStdDev = 50.0
let sampleSize = 25
let confidenceLevel = 0.95  // 95% confidence

let ci = confidenceInterval(
    mean: sampleMean,
    stdDev: sampleStdDev,
    n: sampleSize,
    confidenceLevel: confidenceLevel
)

print("95% CI: [\(ci.lower.number(2)), \(ci.upper.number(2))]")
// True population mean is between these values with 95% confidence
```

### Hypothesis Testing

Test statistical significance:

```swift
let sampleMean = 52.0
let populationMean = 50.0
let sampleStdDev = 5.0
let n = 30

// Calculate t-statistic
let tStat = tStatistic(
    sampleMean: sampleMean,
    populationMean: populationMean,
    sampleStdDev: sampleStdDev,
    n: n
)

// Get p-value
let pValue = pValue(tStat, degreesOfFreedom: n - 1)

if pValue < 0.05 {
    print("Statistically significant difference (p = \(pValue.number(4)))")
} else {
    print("Not statistically significant")
}
```

## Part 5: Choosing the Right Distribution

### Decision Guide

| Distribution | When to Use | Parameters | Example |
|--------------|-------------|------------|---------|
| **Normal** | Natural variation, many samples | mean, stdDev | Heights, measurement errors, returns |
| **Triangular** | Expert estimates (min/likely/max) | min, mode, max | Project costs, sales forecasts |
| **Uniform** | No preference, equal probability | min, max | Random sampling, dice rolls |
| **Exponential** | Time between events | lambda (rate) | Customer arrivals, equipment failure |
| **Log-Normal** | Positive values, right-skewed | mean, stdDev (of log) | Asset prices, incomes, city sizes |
| **Beta** | Bounded percentages (0-1) | alpha, beta | Completion rates, default rates |
| **Poisson** | Count of events in interval | lambda (mean count) | Calls per hour, defects per batch |

### Practical Examples by Use Case

**Financial Modeling:**
- Stock returns → Normal
- Stock prices → Log-Normal
- Default probability → Beta
- Time to default → Exponential

**Operations:**
- Customer arrivals → Poisson count, Exponential time
- Service time → Exponential or Gamma
- Demand forecast → Normal or Triangular

**Risk Analysis:**
- Cost overruns → Triangular (if expert estimates)
- Cost overruns → Normal (if historical data)
- Rare events → Exponential or Weibull

## Part 6: Practical Applications

### Example: Data Preprocessing for Clustering

```swift
// Sales data from different product lines (different scales)
let productASales = [1_000.0, 1_200.0, 900.0, 1_100.0]
let productBSales = [50.0, 60.0, 45.0, 55.0]

// Standardize before clustering to equalize scales
let meanA = mean(productASales)
let stdDevA = stdDev(productASales)
let normalizedA = productASales.map { zScore($0, mean: meanA, stdDev: stdDevA) }

let meanB = mean(productBSales)
let stdDevB = stdDev(productBSales)
let normalizedB = productBSales.map { zScore($0, mean: meanB, stdDev: stdDevB) }

// Now both features have equal weight in clustering
```

### Example: Monte Carlo Simulation Setup

```swift
// Model uncertain revenue with normal distribution
let baseRevenue = 1_000_000.0
let uncertaintyStdDev = 150_000.0

let revenueDist = DistributionNormal(baseRevenue, uncertaintyStdDev)

// Run 10,000 simulations
let simulations = (0..<10_000).map { _ in revenueDist.random() }

// Analyze results
let simMean = mean(simulations)
let simStdDev = stdDev(simulations)
let percentile5 = percentileLocation(simulations.sorted(), percentile: 0.05)
let percentile95 = percentileLocation(simulations.sorted(), percentile: 0.95)

print("Expected revenue: \(simMean.currency(0))")
print("90% confidence interval: [\(percentile5.currency(0)), \(percentile95.currency(0))]")
```

### Example: Quality Control

```swift
// Process should produce widgets with mean weight 100g, stdDev 2g
let targetMean = 100.0
let targetStdDev = 2.0

// Sample measurements
let sample = [99.5, 100.2, 101.0, 98.8, 100.5, 99.0, 100.8]

let sampleMean = mean(sample)
let sampleStdDev = stdDev(sample)

// Check if process is in control (within ±3σ)
for measurement in sample {
    let z = zScore(measurement, mean: targetMean, stdDev: targetStdDev)
    if abs(z) > 3 {
        print("⚠️ Out of control: \(measurement)g (z=\(z.number(2)))")
    }
}

// Overall process check
if abs(sampleMean - targetMean) > targetStdDev {
    print("⚠️ Process mean has shifted")
}
```

## Summary

You've learned how to:
- ✓ Calculate descriptive statistics (mean, variance, skewness, etc.)
- ✓ Work with probability distributions (normal, triangular, uniform, and more)
- ✓ Standardize and normalize data for analysis
- ✓ Choose appropriate distributions for different scenarios
- ✓ Apply statistical methods to real business problems

Statistical distributions and descriptive statistics form the foundation of data analysis, risk modeling, and machine learning in BusinessMath.

## See Also

### Related Guides
- <doc:1.2-TimeSeries> - Apply statistics to time series data
- <doc:4.1-MonteCarloTimeSeriesGuide> - Use distributions in simulations
- <doc:2.3-RiskAnalyticsGuide> - Risk metrics and VaR calculations
- <doc:5.24-K-MeansTutorial> - Data preprocessing for clustering

### Key Functions
- ``mean(_:)`` - Arithmetic mean
- ``median(_:)`` - Middle value
- ``stdDev(_:)`` - Standard deviation
- ``variance(_:)`` - Variance
- ``descriptives(_:)`` - Comprehensive statistics
- ``zScore(_:mean:stdDev:)`` - Standardization
- ``correlationCoefficient(_:_:)`` - Correlation
- ``normalCDF(_:mean:stdDev:)`` - Normal probability
- ``inverseNormalCDF(_:mean:stdDev:)`` - Inverse normal

### Distribution Types
- ``DistributionNormal`` - Normal (Gaussian) distribution
- ``DistributionTriangular`` - Triangular distribution
- ``DistributionUniform`` - Uniform distribution
- ``DistributionExponential`` - Exponential distribution
- ``DistributionLogNormal`` - Log-normal distribution
- ``DistributionBeta`` - Beta distribution
- ``DistributionGamma`` - Gamma distribution
