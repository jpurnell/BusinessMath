# Data Table Analysis

Perform Excel-like sensitivity analysis and scenario planning with data tables.

## Overview

This tutorial demonstrates how to use BusinessMath's data table functionality for "What-If Analysis" - a powerful technique for exploring how changes in input variables affect outputs. You'll learn how to:

- Create one-variable data tables for sensitivity analysis
- Build two-variable data tables for scenario matrices
- Export results to CSV for spreadsheet analysis
- Apply data tables to real-world financial decisions
- Interpret and visualize results

**Time estimate:** 25-35 minutes

## Prerequisites

- Basic understanding of Swift
- Familiarity with financial concepts (loans, investments, pricing)
- Understanding of time value of money (see <doc:1.3-TimeValueOfMoney>)

## What are Data Tables?

Data tables systematically vary one or two input values and calculate corresponding outputs. This is identical to Excel's "Data Table" feature under "What-If Analysis."

**Use Cases:**
- **Sensitivity Analysis**: How does NPV change with different discount rates?
- **Scenario Planning**: What's our profit at various price/volume combinations?
- **Risk Assessment**: How sensitive is our investment to key assumptions?
- **Pricing Optimization**: What price maximizes revenue?

## Part 1: One-Variable Data Tables

One-variable tables show how an output changes as a single input varies.

### Example 1: Loan Payment Sensitivity

A common question: "How much will my monthly payment change if interest rates rise?"

```swift
import BusinessMath

// Loan parameters
let principal = 300_000.0
let loanTerm = 360  // 30 years monthly

// Test different interest rates
let rates = [0.03, 0.035, 0.04, 0.045, 0.05, 0.055, 0.06, 0.065, 0.07]

// Create data table
let paymentTable = DataTable<Double, Double>.oneVariable(
    inputs: rates,
    calculate: { annualRate in
        let monthlyRate = annualRate / 12.0
        return payment(
            presentValue: principal,
            rate: monthlyRate,
            periods: loanTerm,
            futureValue: 0,
            type: .ordinary
        )
    }
)

print("Mortgage Payment Sensitivity Analysis")
print("======================================")
print("Loan Amount: \(principal.currency())")
print("Term: 30 years")
print()
print("Rate\t\tMonthly Payment\tTotal Interest")
print("----\t\t---------------\t--------------")

for (rate, monthlyPayment) in paymentTable {
	let totalPaid = monthlyPayment * Double(loanTerm)
	let totalInterest = totalPaid - principal

	print("\(round(rate * 1000)/10)%\t\t\(monthlyPayment.currency())\t\t\(totalInterest.currency())")
}
```

**Expected output:**
```
Mortgage Payment Sensitivity Analysis
======================================
Loan Amount: $300,000.00
Term: 30 years

Rate		Monthly Payment	Total Interest
----		---------------	--------------
3.0%		$1,264.81		$155,332.36
3.5%		$1,347.13		$184,968.26
4.0%		$1,432.25		$215,608.52
4.5%		$1,520.06		$247,220.13
5.0%		$1,610.46		$279,767.35
5.5%		$1,703.37		$313,212.12
6.0%		$1,798.65		$347,514.57
6.5%		$1,896.20		$382,633.47
7.0%		$1,995.91		$418,526.69
```

**Insight:** A 1% rate increase (4% → 5%) adds $178/month and $64,000 in total interest!

### Example 2: Investment NPV Sensitivity

How sensitive is an investment's value to the discount rate?

```swift
// Investment cash flows
let investment = -100_000.0
let cashFlows = [investment, 30_000.0, 35_000.0, 40_000.0, 45_000.0, 50_000.0]

// Test different discount rates
let discountRates = [0.06, 0.08, 0.10, 0.12, 0.14, 0.16, 0.18, 0.20]

let npvTable = DataTable<Double, Double>.oneVariable(
    inputs: discountRates,
    calculate: { rate in
        return npv(discountRate: rate, cashFlows: cashFlows)
    }
)

print("\nInvestment NPV Sensitivity")
print("===============================")
print("Initial Investment: \((-investment).currency())")
print()
print("Discount Rate\tNPV\t\t\t\tDecision")
print("-------------\t----------\t\t--------")

for (rate, npvValue) in npvTable {
	let decision = npvValue > 0 ? "Accept ✓" : "Reject ✗"
	print("\(rate.percent(2).padding(toLength: 8, withPad: " ", startingAt: 0))\t\t\(npvValue.currency())\t\t\(decision)")
}

// Find the rate where NPV ≈ 0 (this is the IRR)
let irrValue = try! irr(cashFlows: cashFlows)
print("\nIRR (where NPV = 0): \(String(format: "%.2f%%", irrValue * 100))")
```

**Expected output:**
```
Investment NPV Sensitivity
===============================
Initial Investment: $100,000.00

Discount Rate	NPV				Decision
-------------	----------		--------
6%      		$66,043.66		Accept ✓
8%      		$56,643.43		Accept ✓
10%     		$48,032.61		Accept ✓
12%     		$40,128.37		Accept ✓
14%     		$32,858.06		Accept ✓
16%     		$26,157.83		Accept ✓
18%     		$19,971.38		Accept ✓
20%     		$14,248.97		Accept ✓

IRR (where NPV = 0): 25.75%
```

**Insight:** This investment remains attractive even at high discount rates, indicating low risk sensitivity.

### Example 3: Break-Even Analysis

At what sales volume do we break even?

```swift
// Business parameters
let fixedCosts = 50_000.0
let variableCostPerUnit = 15.0
let pricePerUnit = 25.0

// Test different sales volumes
let volumes = Array(stride(from: 1000.0, through: 10000.0, by: 1000.0))

let profitTable = DataTable<Double, Double>.oneVariable(
    inputs: volumes,
    calculate: { volume in
        let revenue = pricePerUnit * volume
        let totalCosts = fixedCosts + (variableCostPerUnit * volume)
        return revenue - totalCosts
    }
)

print("\nBreak-Even Analysis")
print("=====================================")
print("Fixed Costs: \(fixedCosts.currency())")
print("Variable Cost/Unit: \(variableCostPerUnit.currency())")
print("Price/Unit: \(pricePerUnit.currency())")
print("Contribution Margin: \((pricePerUnit - variableCostPerUnit).currency())/unit")
print()
print("\("Volume".padding(toLength: 12, withPad: " ", startingAt: 0))\("Revenue".padding(toLength: 16, withPad: " ", startingAt: 0))\("Total Costs".padding(toLength: 16, withPad: " ", startingAt: 0))\("Profit")")
print("--------\t-----------\t\t-----------\t\t-------------")

for (volume, profit) in profitTable {
	let revenue = pricePerUnit * volume
	let totalCosts = fixedCosts + (variableCostPerUnit * volume)
	let status = profit >= 0 ? "✓" : "✗"

	print("\(volume.formatted().padding(toLength: 12, withPad: " ", startingAt: 0))\(revenue.currency().padding(toLength: 16, withPad: " ", startingAt: 0))\(totalCosts.currency().padding(toLength: 16, withPad: " ", startingAt: 0))\(profit.currency()) \(status)")
}

// Calculate exact break-even
let breakEvenVolume = fixedCosts / (pricePerUnit - variableCostPerUnit)
print("\nBreak-Even Volume: \(breakEvenVolume.formatted()) units")
```

**Expected output:**
```
Break-Even Analysis
=====================================
Fixed Costs: $50,000.00
Variable Cost/Unit: $15.00
Price/Unit: $25.00
Contribution Margin: $10.00/unit

Volume      Revenue         Total Costs     Profit
--------	-----------		-----------		-------------
1000        $25,000.00      $65,000.00      -$40,000.00 ✗
2000        $50,000.00      $80,000.00      -$30,000.00 ✗
3000        $75,000.00      $95,000.00      -$20,000.00 ✗
4000        $100,000.00     $110,000.00     -$10,000.00 ✗
5000        $125,000.00     $125,000.00     $0.00 ✓
6000        $150,000.00     $140,000.00     $10,000.00 ✓
7000        $175,000.00     $155,000.00     $20,000.00 ✓
8000        $200,000.00     $170,000.00     $30,000.00 ✓
9000        $225,000.00     $185,000.00     $40,000.00 ✓
10000       $250,000.00     $200,000.00     $50,000.00 ✓

Break-Even Volume: 5000 units
```

## Part 2: Two-Variable Data Tables

Two-variable tables create a matrix showing how outputs change with two varying inputs.

### Example 4: Pricing Strategy Matrix

What price and volume combination maximizes profit?

```swift
// Fixed business parameters
let monthlyFixedCosts = 100_000.0
let variableCostPerUnit = 30.0

// Scenarios to test
let pricePoints = [40.0, 45.0, 50.0, 55.0, 60.0]
let volumeScenarios = [2000.0, 2500.0, 3000.0, 3500.0, 4000.0]

// Create two-variable profit matrix
let profitMatrix = DataTable<Double, Double>.twoVariable(
rowInputs: pricePoints,
columnInputs: volumeScenarios,
calculate: { price, volume in
	let revenue = price * volume
	let totalCosts = monthlyFixedCosts + (variableCostPerUnit * volume)
	return revenue - totalCosts
}
)

print("\nPricing Strategy Matrix (Monthly Profit)")
print("=========================================")
print("Fixed Costs: \(monthlyFixedCosts.currency())")
print("Variable Cost: \(variableCostPerUnit.currency())/unit")
print()

// Print header row with volume scenarios
var headerString = "Price".padding(toLength: 10, withPad: " ", startingAt: 0)
for volume in volumeScenarios {
headerString += "\(volume.formatted())".paddingLeft(toLength: 14)
}
print(headerString)
print(String(repeating: "=", count: 80))

// Print data rows
for (rowIndex, price) in pricePoints.enumerated() {
var rowString = "\(price.currency())".padding(
	toLength: 13,
	withPad: " ",
	startingAt: 0
)
for colIndex in 0..<volumeScenarios.count {
	let profit = profitMatrix[rowIndex][colIndex]
	rowString += "\(profit.currency())"
		.padding(toLength: 14, withPad: " ", startingAt: 0)
}
print(rowString)
}

// Find optimal combination
var maxProfit = -Double.infinity
var optimalPrice = 0.0
var optimalVolume = 0.0

for (rowIndex, price) in pricePoints.enumerated() {
for (colIndex, volume) in volumeScenarios.enumerated() {
	let profit = profitMatrix[rowIndex][colIndex]
	if profit > maxProfit {
		maxProfit = profit
		optimalPrice = price
		optimalVolume = volume
	}
}
}

print("\nOptimal Strategy:")
print(
"Price: \(optimalPrice.currency()), Volume: \(optimalVolume.formatted()) units"
)
print("Maximum Monthly Profit: \(maxProfit.currency())")

```

**Expected output:**
```
Pricing Strategy Matrix (Monthly Profit)
=========================================
Fixed Costs: $100,000.00
Variable Cost: $30.00/unit

Price               2000          2500          3000          3500          4000
================================================================================
$40.00       -$80,000.00   -$75,000.00   -$70,000.00   -$65,000.00   -$60,000.00   
$45.00       -$70,000.00   -$62,500.00   -$55,000.00   -$47,500.00   -$40,000.00   
$50.00       -$60,000.00   -$50,000.00   -$40,000.00   -$30,000.00   -$20,000.00   
$55.00       -$50,000.00   -$37,500.00   -$25,000.00   -$12,500.00   $0.00         
$60.00       -$40,000.00   -$25,000.00   -$10,000.00   $5,000.00     $20,000.00    

Optimal Strategy:
Price: $60.00, Volume: 4000 units
Maximum Monthly Profit: $20,000.00
```

**Insight:** Higher prices with higher volumes yield maximum profit, but you need to validate volume assumptions at different price points (demand elasticity).

### Example 5: Investment Scenario Analysis

How do growth rate and discount rate together affect investment value?

```swift
// Base investment
let initialCost = 50_000.0
let baseRevenue = 20_000.0
let years = 5

// Scenarios
let growthRates = [0.05, 0.10, 0.15, 0.20, 0.25]  // 5% to 25% annual growth
let discountRates = [0.08, 0.10, 0.12, 0.14, 0.16] // 8% to 16% required return

let npvMatrix = DataTable<Double, Double>.twoVariable(
	rowInputs: growthRates,
	columnInputs: discountRates,
	calculate: { growth, discount in
		// Generate cash flows with growth
		var flows = [-initialCost]  // Initial investment
		var revenue = baseRevenue

		for _ in 1...years {
			revenue *= (1 + growth)
			flows.append(revenue)
		}

		return npv(discountRate: discount, cashFlows: flows)
	}
)

print("\nInvestment NPV Matrix ($)")
print("=========================")
print("Initial Investment: \(initialCost.currency())")
print("Base Revenue: \(baseRevenue.currency())")
print("Period: \(years) years")
print()

// Print header
var headerString = "Growth\\Discount".padding(toLength: 16, withPad: " ", startingAt: 0)
for discount in discountRates {
	headerString += "\(discount.percent())".paddingLeft(toLength: 16)
}
print(headerString)
print(String(repeating: "=", count: 96))

// Print rows
for (rowIndex, growth) in growthRates.enumerated() {
	var rowString = "\(growth.percent())".padding(toLength: 16, withPad: " ", startingAt: 0)
//		print(String(format: "%.0f%%\t\t", growth * 100), terminator: "")

	for colIndex in 0..<discountRates.count {
		let npvValue = npvMatrix[rowIndex][colIndex]
		let indicator = npvValue > 0 ? "+" : ""
		rowString += "\(indicator)\(npvValue.currency())".paddingLeft(toLength: 16)
//			print(String(format: "%@$%.0f\t", indicator, npvValue), terminator: "")
	}
	print(rowString)
}

// Count positive NPV scenarios
var acceptableScenarios = 0
var totalScenarios = growthRates.count * discountRates.count

for row in npvMatrix {
	for npvValue in row {
		if npvValue > 0 {
			acceptableScenarios += 1
		}
	}
}

let percentAcceptable = Double(acceptableScenarios) / Double(totalScenarios)
print("\nScenarios with Positive NPV: \(acceptableScenarios)/\(totalScenarios) (\(percentAcceptable.percent()))")
```

**Expected output:**
```
Investment NPV Matrix ($)
=========================
Initial Investment: $50,000.00
Base Revenue: $20,000.00
Period: 5 years

Growth\Discount               8%             10%             12%             14%             16%
================================================================================================
5%                   +$41,968.95     +$37,162.42     +$32,741.07     +$28,665.85     +$24,902.37
10%                  +$55,694.65     +$50,000.00     +$44,768.71     +$39,953.36     +$35,512.25
15%                  +$71,208.65     +$64,491.50     +$58,328.53     +$52,662.56     +$47,443.33
20%                  +$88,701.76     +$80,812.23     +$73,581.88     +$66,942.17     +$60,832.92
25%                 +$108,378.69     +$99,150.25     +$90,701.80     +$82,951.68     +$75,828.23

Scenarios with Positive NPV: 25/25 (100%)
```

**Insight:** The investment is robust - positive NPV across all reasonable growth and discount scenarios. This indicates low risk.

### Example 6: Loan Affordability Matrix

Combined analysis of interest rates and loan amounts.

```swift
// Buyer's constraint: Maximum monthly payment
let maxMonthlyPayment = 2_500.0
let loanTermMonths = 360  // 30 years

// Scenarios
let loanAmounts = [250_000.0, 300_000.0, 350_000.0, 400_000.0, 450_000.0]
let interestRates = [0.03, 0.035, 0.04, 0.045, 0.05, 0.055, 0.06]

let paymentMatrix = DataTable<Double, Double>.twoVariable(
	rowInputs: loanAmounts,
	columnInputs: interestRates,
	calculate: { loanAmount, annualRate in
		let monthlyRate = annualRate / 12.0
		return payment(
			presentValue: loanAmount,
			rate: monthlyRate,
			periods: loanTermMonths,
			futureValue: 0,
			type: .ordinary
		)
	}
)

print("\nLoan Affordability Matrix (Monthly Payment)")
print("============================================")
print("Maximum Affordable Payment: \(maxMonthlyPayment.currency())")
print("Term: 30 years")
print()

// Print header
var headerString = "Loan Amount".padding(toLength: 16, withPad: " ", startingAt: 0)
for rate in interestRates {
	headerString += "\(round(rate * 1000)/10)%".paddingLeft(toLength: 13, withPad: " ")
}
print(headerString)
print(String(repeating: "=", count: 107))

// Print rows with affordability indicators
for (rowIndex, amount) in loanAmounts.enumerated() {
	var rowString = "$\((amount/1000))k".padding(toLength: 16, withPad: " ", startingAt: 0)
	for colIndex in 0..<interestRates.count {
		let monthlyPmt = paymentMatrix[rowIndex][colIndex]
		let affordable = monthlyPmt <= maxMonthlyPayment ? "✓" : "✗"
		rowString += "\(monthlyPmt.currency())".paddingLeft(toLength: 12, withPad: " ")
		rowString += "\(affordable)"
	}
	print(rowString)
}

// Find maximum affordable loan at each rate
print("\nMaximum Affordable Loan Amount by Rate:")
for (colIndex, rate) in interestRates.enumerated() {
	var maxAffordable = 0.0

	for (rowIndex, amount) in loanAmounts.enumerated() {
		let monthlyPmt = paymentMatrix[rowIndex][colIndex]
		if monthlyPmt <= maxMonthlyPayment {
			maxAffordable = amount
		}
	}

	print("At \(round(rate * 1000)/10)%: \(maxAffordable.currency())")
}
```

**Expected output:**
```
Loan Affordability Matrix (Monthly Payment)
============================================
Maximum Affordable Payment: $2,500.00
Term: 30 years

Loan Amount              3.0%         3.5%         4.0%         4.5%         5.0%         5.5%         6.0%
===========================================================================================================
$250.0k            $1,054.01✓   $1,122.61✓   $1,193.54✓   $1,266.71✓   $1,342.05✓   $1,419.47✓   $1,498.88✓
$300.0k            $1,264.81✓   $1,347.13✓   $1,432.25✓   $1,520.06✓   $1,610.46✓   $1,703.37✓   $1,798.65✓
$350.0k            $1,475.61✓   $1,571.66✓   $1,670.95✓   $1,773.40✓   $1,878.88✓   $1,987.26✓   $2,098.43✓
$400.0k            $1,686.42✓   $1,796.18✓   $1,909.66✓   $2,026.74✓   $2,147.29✓   $2,271.16✓   $2,398.20✓
$450.0k            $1,897.22✓   $2,020.70✓   $2,148.37✓   $2,280.08✓   $2,415.70✓   $2,555.05✗   $2,697.98✗

Maximum Affordable Loan Amount by Rate:
At 3.0%: $450,000.00
At 3.5%: $450,000.00
At 4.0%: $450,000.00
At 4.5%: $450,000.00
At 5.0%: $450,000.00
At 5.5%: $400,000.00
At 6.0%: $400,000.00
```

**Insight:** Rate increases above 5.5% significantly reduce buying power - from $450k to $400k.

## Part 3: Exporting and Formatting

### CSV Export

Export results for spreadsheet analysis.

```swift
// Create a data table
let rates = [0.03, 0.04, 0.05, 0.06, 0.07]
let paymentTable = DataTable<Double, Double>.oneVariable(
    inputs: rates,
    calculate: { rate in
        payment(
            presentValue: 300_000,
            rate: rate / 12,
            periods: 360,
            futureValue: 0,
            type: .ordinary
        )
    }
)

// Export to CSV
let csv = DataTable.toCSV(
    paymentTable,
    inputHeader: "Interest Rate",
    outputHeader: "Monthly Payment"
)

print(csv)

// Write to file (in real application)
// try csv.write(toFile: "loan_payments.csv", atomically: true, encoding: .utf8)
```

**Output:**
```
Interest Rate,Monthly Payment
0.03,1264.812101188368
0.04,1432.2458863963616
0.05,1610.4648690364193
0.06,1798.6515754582708
0.07,1995.907485537547
```

### Two-Variable CSV Export

```swift
let prices = [10.0, 12.0, 14.0]
let volumes = [100.0, 200.0, 300.0]
let fixedCost = 500.0
let variableCost = 5.0

let profitMatrix = DataTable<Double, Double>.twoVariable(
    rowInputs: prices,
    columnInputs: volumes,
    calculate: { price, volume in
        (price * volume) - fixedCost - (variableCost * volume)
    }
)

let csv = DataTable.toCSV(
    profitMatrix,
    rowInputs: prices,
    columnInputs: volumes
)

print(csv)
```

**Output:**
```
,100.0,200.0,300.0,
10.0,0.0,500.0,1000.0,
12.0,200.0,900.0,1600.0,
14.0,400.0,1300.0,2200.0,
```

### Formatted Console Output

```swift
let prices = [10.0, 12.0, 14.0]
let volumes = [100.0, 200.0, 300.0]
let fixedCost = 500.0
let variableCost = 5.0

let profitMatrix = DataTable<Double, Double>.twoVariable(
	rowInputs: prices,
	columnInputs: volumes,
	calculate: { price, volume in
		(price * volume) - fixedCost - (variableCost * volume)
	}
)

let formatted = DataTable.formatTwoVariable(
    profitMatrix,
    rowInputs: prices,
    columnInputs: volumes
)

print("\nProfit Analysis")
print("===============")
print(formatted)
```

**Output:**
```
Profit Analysis
====================================================
					   100.0       200.0       300.0
====================================================
10.0                     0.0       500.0      1000.0
12.0                   200.0       900.0      1600.0
14.0                   400.0      1300.0      2200.0
```

## Part 4: Advanced Techniques

### Custom Analysis with Data Tables

Combine data tables with other BusinessMath features:

```swift
// Investment with irregular cash flow dates
import Foundation

let investmentAmount = 100_000.0
let rateScenarios = [0.08, 0.10, 0.12, 0.14]

// Actual payment dates (irregular)
let dates = [
	Date(),  // Today
	Date(timeIntervalSinceNow: 90 * 86400),   // 90 days
	Date(timeIntervalSinceNow: 180 * 86400),  // 180 days
	Date(timeIntervalSinceNow: 365 * 86400),  // 1 year
	Date(timeIntervalSinceNow: 730 * 86400)   // 2 years
]

let cashFlows = [-investmentAmount, 25_000.0, 30_000.0, 35_000.0, 40_000.0]

// XNPV sensitivity table
let xnpvTable = DataTable<Double, Double>.oneVariable(
	inputs: rateScenarios,
	calculate: { rate in
		try! xnpv(rate: rate, dates: dates, cashFlows: cashFlows)
	}
)

print("\nXNPV             Sensitivity")
print("========================================")
for (rate, npvValue) in xnpvTable {
	print("\(rate.percent().padding(toLength: 16, withPad: " ", startingAt: 0)) \(npvValue.currency())")
}
```

### Integration with Time Series

```swift
import BusinessMath

// Historical revenue data
let periods = [
    Period.quarter(year: 2024, quarter: 1),
    Period.quarter(year: 2024, quarter: 2),
    Period.quarter(year: 2024, quarter: 3),
    Period.quarter(year: 2024, quarter: 4)
]
let revenue = [100_000.0, 120_000.0, 115_000.0, 135_000.0]
let timeSeries = TimeSeries(periods: periods, values: revenue)

// Sensitivity: How do different growth assumptions affect forecast?
let growthScenarios = [0.05, 0.10, 0.15, 0.20]

let forecastTable = DataTable<Double, TimeSeries<Double>>.oneVariable(
    inputs: growthScenarios,
    calculate: { growthRate in
        // Apply growth to last period
        let lastValue = timeSeries.valuesArray.last ?? 0
        let forecastValue = lastValue * (1 + growthRate)

        // Create forecast period
        let forecastPeriod = Period.quarter(year: 2025, quarter: 1)

        return TimeSeries(
            periods: [forecastPeriod],
            values: [forecastValue]
        )
    }
)

print("\nRevenue Forecast Scenarios (Q1 2025)")
print("======================================")
print("Last Actual (Q4 2024): $\(String(format: "%.0f", revenue.last ?? 0))")
print()

for (growth, forecast) in forecastTable {
    let forecastValue = forecast.valuesArray.first ?? 0
    print(String(format: "%.0f%% growth: $%.0f", growth * 100, forecastValue))
}
```

## Best Practices

### 1. Choose Appropriate Input Ranges

```swift
// ✓ Good: Reasonable range around expected value
let rates = [0.05, 0.06, 0.07, 0.08, 0.09]  // ±2% from 7% base

// ✗ Bad: Too wide, includes unrealistic scenarios
let rates = [0.01, 0.10, 0.20, 0.30, 0.40]
```

### 2. Use Meaningful Step Sizes

```swift
// ✓ Good: Fine granularity for precise analysis
let prices = Array(stride(from: 10.0, through: 20.0, by: 1.0))

// ✗ Bad: Too coarse, might miss optimal point
let prices = [10.0, 20.0]
```

### 3. Validate Assumptions

```swift
// ✓ Good: Check for nonsensical combinations
let profitMatrix = DataTable<Double, Double>.twoVariable(
    rowInputs: prices,
    columnInputs: volumes,
    calculate: { price, volume in
        // Validate: Higher prices typically mean lower volumes
        // Could add demand curve here
        let revenue = price * volume
        let costs = fixedCost + (variableCost * volume)
        return revenue - costs
    }
)
```

### 4. Document Your Analysis

```swift
print("\nAssumptions:")
print("- Fixed costs remain constant across volumes")
print("- Variable cost of $\(variableCost) per unit")
print("- No economies of scale considered")
print("- Demand elasticity not modeled")
```

## Common Patterns

### Pattern 1: Find Threshold Values

```swift
// Find the discount rate where NPV = 0 (IRR approximation)
let npvTable = DataTable<Double, Double>.oneVariable(
    inputs: Array(stride(from: 0.05, through: 0.30, by: 0.01)),
    calculate: { rate in npv(discountRate: rate, cashFlows: cashFlows) }
)

var irrApprox = 0.0
for (rate, npvValue) in npvTable {
    if abs(npvValue) < 100 {  // Close to zero
        irrApprox = rate
        break
    }
}

print("IRR (approximate): \(String(format: "%.2f%%", irrApprox * 100))")
```

### Pattern 2: Identify Optimal Values

```swift
// Find price that maximizes profit at given volume
let targetVolume = 5000.0
let optimalPrice = DataTable<Double, Double>.oneVariable(
    inputs: Array(stride(from: 20.0, through: 100.0, by: 5.0)),
    calculate: { price in
        let revenue = price * targetVolume
        let costs = fixedCosts + (variableCostPerUnit * targetVolume)
        return revenue - costs
    }
).max { $0.output < $1.output }

if let optimal = optimalPrice {
    print("Optimal price: $\(optimal.input)")
    print("Maximum profit: $\(String(format: "%.0f", optimal.output))")
}
```

### Pattern 3: Risk Assessment

```swift
// Count scenarios where we meet target return
let targetReturn = 0.15  // 15% IRR
let acceptableScenarios = npvMatrix.flatMap { $0 }
    .filter { $0 > 0 }
    .count

let totalScenarios = growthRates.count * discountRates.count
let successRate = Double(acceptableScenarios) / Double(totalScenarios)

print("Success rate: \(String(format: "%.0f%%", successRate * 100))")
```

## Summary

You've learned how to:

✓ Create one-variable data tables for sensitivity analysis
✓ Build two-variable matrices for scenario planning
✓ Export results to CSV for further analysis
✓ Apply data tables to loans, investments, and pricing
✓ Identify optimal values and threshold points
✓ Assess risk across multiple scenarios

Data tables are powerful tools for:
- **Understanding relationships** between inputs and outputs
- **Identifying sensitivities** to key assumptions
- **Exploring scenarios** without building complex models
- **Communicating analysis** to stakeholders with clear matrices

## Next Steps

- Explore <doc:4.2-ScenarioAnalysisGuide> for Monte Carlo simulation
- Learn <doc:3.8-InvestmentAnalysis> for detailed NPV/IRR techniques
- Study <doc:5.1-OptimizationGuide> for finding optimal solutions programmatically

## See Also

- ``DataTable``
- ``npv(discountRate:cashFlows:)``
- ``payment(presentValue:rate:periods:futureValue:type:)``
- ``TimeSeries``
