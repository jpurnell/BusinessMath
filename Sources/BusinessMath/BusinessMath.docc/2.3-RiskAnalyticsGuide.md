# Risk Analytics and Stress Testing

Measure and manage risk with comprehensive analytics and scenario testing.

## Overview

Risk analytics help you understand and quantify uncertainty in financial decisions. BusinessMath provides industry-standard risk measures including Value at Risk (VaR), stress testing, and comprehensive risk metrics.

This guide covers:
- Stress testing with pre-defined and custom scenarios
- Value at Risk (VaR) calculation and aggregation
- Comprehensive risk metrics (Sharpe, Sortino, drawdown)
- Practical risk management applications
- Portfolio risk decomposition

## Stress Testing

Stress tests evaluate how portfolios or projects perform under adverse scenarios.

### Pre-Defined Scenarios

BusinessMath includes common stress scenarios based on historical crises.

```swift
import BusinessMath

// Define stress scenarios
let scenarios = [
    StressScenario<Double>.recession,      // Moderate economic downturn
    StressScenario<Double>.crisis,         // Severe financial crisis
    StressScenario<Double>.supplyShock     // Supply chain disruption
]

// Examine scenario parameters
for scenario in scenarios {
    print("\(scenario.name):")
    print("  Description: \(scenario.description)")
    print("  Shocks:")
    for (driver, shock) in scenario.shocks {
        let pct = shock * 100
        print("    \(driver): \(pct > 0 ? "+" : "")\(pct)%")
    }
}
```

Output:
```
Recession:
  Description: Economic recession scenario
  Shocks:
	Revenue: -15.0%
	COGS: +5.0%
	InterestRate: +2.0%

Financial Crisis:
  Description: Severe financial crisis (2008-style)
  Shocks:
	Revenue: -30.0%
	InterestRate: +5.0%
	CustomerChurn: +20.0%
	COGS: +10.0%

Supply Chain Shock:
  Description: Major supply chain disruption
  Shocks:
	InventoryLevel: -30.0%
	DeliveryTime: +50.0%
	COGS: +25.0%
```

### Custom Stress Scenarios

Create scenarios specific to your business.

```swift
// Pandemic scenario
let pandemic = StressScenario(
    name: "Global Pandemic",
    description: "Extended lockdowns and remote work transition",
    shocks: [
        "Revenue": -0.35,           // -35% revenue
        "RemoteWorkCosts": 0.20,    // +20% IT/remote costs
        "TravelExpenses": -0.80,    // -80% travel
        "RealEstateCosts": -0.15    // -15% office costs
    ]
)

// Regulatory change scenario
let regulation = StressScenario(
    name: "New Regulation",
    description: "Stricter compliance requirements",
    shocks: [
        "ComplianceCosts": 0.50,    // +50% compliance
        "Revenue": -0.05,            // -5% from restrictions
        "OperatingMargin": -0.03     // -3% margin compression
    ]
)

let allScenarios = scenarios + [pandemic, regulation]
```

### Running Stress Tests

```swift
let stressTest = StressTest(scenarios: allScenarios)

// Apply to your financial model
// (Simplified example - integrate with your actual model)
struct FinancialMetrics {
    let revenue: Double
    let costs: Double
    let npv: Double
}

let baseline = FinancialMetrics(
    revenue: 10_000_000,
    costs: 7_000_000,
    npv: 5_000_000
)

for scenario in stressTest.scenarios {
    // Apply shocks
    var stressed = baseline

    if let revenueShock = scenario.shocks["Revenue"] {
        stressed.revenue *= (1 + revenueShock)
    }

    if let cogsShock = scenario.shocks["COGS"] {
        stressed.costs *= (1 + cogsShock)
    }

    let stressedNPV = stressed.revenue - stressed.costs  // Simplified
    let impact = stressedNPV - baseline.npv
    let impactPct = (impact / baseline.npv)

    print("\n\(scenario.name):")
    print("  Baseline NPV: \(baseline.npv.currency())")
    print("  Stressed NPV: \(stressedNPV.currency())")
    print("  Impact: \(impact.currency()) (\(impactPct.percent()))")
}
```

## Value at Risk (VaR)

VaR measures the maximum loss expected over a time horizon at a given confidence level.

### Calculating VaR from Returns

```swift
// Portfolio returns (daily for 1 year)
let spReturns: [Double] = [0.0088, 0.0079, -0.0116, -0.0024, -0.0016, -0.0107, 0.0021, 0.0067, -0.0009, -0.0035, 0.0019, 0.0011, 0.003, 0.0025, -0.0053, 0.0054, 0.0069, 0.0091, 0.0155, 0.0098, -0.0156, 0.0038, -0.0083, -0.0092, -0.0005, -0.0166, 0.0006, 0.0021, 0.0154, 0.0013, -0.0112, 0.0037, -0.0117, 0.0017, 0.0026, -0.0099, 0, 0.0023, 0.0123, 0.0079, 0.0058, -0.0053, 0, 0.0107, 0.0053, -0.0063, 0.004, -0.0016, 0.0156, -0.0271, -0.0028, 0.0058, -0.0038, 0.0036, 0.0001, 0.0006, 0.0034, 0.0041, 0.0026, 0.0059, -0.005, -0.0028, -0.0055, 0.0044, 0.0049, 0.0048, -0.001, -0.0013, 0.0047, -0.0005, 0.0085, 0.003, 0.0027, 0.0021, -0.0032, 0.0083, 0.0051, -0.0069, -0.0064, 0.0032, 0.0024, 0.0041, -0.0043, 0.0152, -0.004, -0.0024, -0.0059, -0.0001, -0.0029, 0.0003, 0.0032, 0.0113, -0.0025, 0.0078, -0.0008, 0.0073, -0.0049, 0.0147, -0.016, -0.0037, -0.0012, -0.003, 0.0002, 0.004, 0.0007, 0.0078, 0.0006, 0.0014, -0.0001, 0.0054, 0.0032, -0.004, 0.0014, -0.0033, 0.0027, 0.0061, -0.0007, -0.0079, 0.0083, 0.0047, -0.0011, 0.0052, 0.0052, 0.008, 0, 0.0111, 0.0096, -0.0022, -0.0003, -0.0084, 0.0094, -0.0113, 0.0038, -0.0027, 0.0055, 0.0009, 0.0103, -0.0053, 0.0001, 0.0058, 0.0041, -0.0001, 0.004, -0.0056, 0.0205, -0.0067, -0.0004, -0.0161, -0.0039, 0.0009, 0.007, 0.0041, 0.001, 0.0072, 0.0326, -0.0007, 0.0058, 0.0043, -0.0077, -0.0064, 0.0147, 0.0063, 0.0015, 0.0058, 0.0006, 0.0074, 0.0203, 0.0167, 0.0251, -0.0236, 0.0013, -0.0224, -0.0017, 0.0079, 0.0181, -0.0346, 0.0952, -0.0157, -0.0023, -0.0597, -0.0484, 0.0067, 0.0038, 0.0055, -0.0197, -0.0033, -0.0112, 0.0016, 0.0176, 0.0008, -0.0022, 0.0108, -0.0107, 0.0064, 0.0213, -0.0139, 0.0049, -0.0076, -0.027, 0.0055, -0.0178, 0.0112, -0.0122, -0.0176, 0.0159, -0.0159, 0.0001, -0.0047, -0.005, -0.0171, -0.0043, 0.0024, 0.0024, -0.0001, 0.0104, -0.0027, 0.0003, 0.0067, -0.0095, 0.0036, 0.0039, 0.0072, -0.0076, -0.005, 0.0053, -0.0047, 0.0092, -0.0146, -0.0029, 0.0053, 0.0061, 0.0088, 0.01, -0.0021, 0.0183, 0.0011, 0.0016, -0.0154, 0.0016, -0.0111, 0.0055, 0.0126, -0.0022, -0.0043, -0.0107, -0.0111, -0.0004, 0.011, 0.0073, 0.0109]
let spReturnMean = mean(spReturns)
let spReturnStdDev = stdDev(spReturns)
let returns: [Double] = (0..<250).map({_ in distributionNormal(mean: spReturnMean, stdDev: spReturnStdDev)}) /* 250 daily returns */

	let periods = (0..<spReturns.count).map { Period.day(Date().addingTimeInterval(Double($0) * 86400)) }
	let timeSeries = TimeSeries(periods: periods, values: spReturns)

	let riskMetrics = ComprehensiveRiskMetrics(
		returns: timeSeries,
		riskFreeRate: 0.02 / 250  // 2% annual = 0.008% daily
	)

	print("Value at Risk:")
	print("  95% VaR: \(riskMetrics.var95.percent())")
	print("  99% VaR: \(riskMetrics.var99.percent())")

	// Interpret: "95% confidence we won't lose more than X% in a day"
	let portfolioValue = 1_000_000.0
	let var95Loss = abs(riskMetrics.var95) * portfolioValue

	print("\nFor \(portfolioValue.currency(0)) portfolio:")
	print("  95% 1-day VaR: \(var95Loss.currency())")
	print("  Meaning: 95% confident daily loss won't exceed \(var95Loss.currency())")

	print("\nConditional VaR (Expected Shortfall):")
	print("  CVaR (95%): \(riskMetrics.cvar95.percent())")
	print("  Tail Risk Ratio: \(riskMetrics.tailRisk.number())")

	// CVaR is the expected loss if we're in the worst 5%
	let cvarLoss = abs(riskMetrics.cvar95) * portfolioValue
	print("  If in worst 5% of days, expect to lose: \(cvarLoss.currency())")
```

### Conditional VaR (CVaR / Expected Shortfall)

CVaR measures the average loss in the worst cases (beyond VaR).

```swift
print("\nConditional VaR (Expected Shortfall):")
print("  CVaR (95%): \(riskMetrics.cvar95.percent())")
print("  Tail Risk Ratio: \(riskMetrics.tailRisk.number())")

// CVaR is the expected loss if we're in the worst 5%
let cvarLoss = abs(riskMetrics.cvar95) * portfolioValue
print("  If in worst 5% of days, expect to lose: \(cvarLoss.currency())")
```

## Comprehensive Risk Metrics

A complete risk profile includes multiple measures.

### Full Risk Assessment

```swift
print("\nComprehensive Risk Profile:")
print(riskMetrics.description)
```

Output:
```
Comprehensive Risk Metrics:
  VaR (95%): -1.66%
  VaR (99%): -4.84%
  CVaR (95%): -2.76%
  Max Drawdown: 18.91%
  Sharpe Ratio: 0.05
  Sortino Ratio: 0.05
  Tail Risk: 1.66
  Skewness: 1.05
  Kurtosis: 18.53
```

### Maximum Drawdown

Maximum drawdown measures the largest peak-to-trough decline.

```swift
let drawdown = riskMetrics.maxDrawdown

print("\nDrawdown Analysis:")
print("  Maximum drawdown: \(drawdown.percent())")

if drawdown < 0.10 {
    print("  Risk level: Low")
} else if drawdown < 0.20 {
    print("  Risk level: Moderate")
} else {
    print("  Risk level: High")
}
```

### Sharpe and Sortino Ratios

Risk-adjusted return measures.

```swift
print("\nRisk-Adjusted Returns:")
print("  Sharpe Ratio: \(riskMetrics.sharpeRatio)")
print("    (return per unit of total volatility)")

print("  Sortino Ratio: \(riskMetrics.sortinoRatio)")
print("    (return per unit of downside volatility)")

// Sortino > Sharpe indicates asymmetric returns (positive skew)
if riskMetrics.sortinoRatio > riskMetrics.sharpeRatio {
    print("  Portfolio has limited downside with upside potential")
}
```

### Tail Statistics

Skewness and kurtosis describe return distribution shape.

```swift
print("\nTail Statistics:")
print("  Skewness: \(riskMetrics.skewness)")

if riskMetrics.skewness < -0.5 {
    print("    Negative skew: More frequent small gains, rare large losses")
    print("    Risk: Fat left tail")
} else if riskMetrics.skewness > 0.5 {
    print("    Positive skew: More frequent small losses, rare large gains")
    print("    Risk: Fat right tail")
} else {
    print("    Roughly symmetric distribution")
}

print("  Excess Kurtosis: \(riskMetrics.kurtosis)")

if riskMetrics.kurtosis > 1.0 {
    print("    Fat tails: More extreme events than normal distribution")
    print("    Risk: Higher probability of large moves")
}
```

## Practical Risk Management

### Setting Risk Limits

```swift
struct RiskLimits {
    let maxVaR95: Double         // Maximum 95% VaR
    let maxDrawdown: Double      // Maximum allowed drawdown
    let minSharpeRatio: Double   // Minimum acceptable Sharpe
}

let limits = RiskLimits(
    maxVaR95: 0.03,      // 3% daily VaR
    maxDrawdown: 0.20,   // 20% drawdown
    minSharpeRatio: 0.5  // 0.5 Sharpe
)

func checkRiskLimits(metrics: ComprehensiveRiskMetrics<Double>, limits: RiskLimits) -> [String] {
	var breaches: [String] = []

	if abs(metrics.var95) > limits.maxVaR95 {
		breaches.append("VaR limit breached: \(abs(metrics.var95).percent()) > \(limits.maxVaR95.percent())")
	}

	if metrics.maxDrawdown > limits.maxDrawdown {
		breaches.append("Drawdown limit breached: \(metrics.maxDrawdown.percent()) > \(limits.maxDrawdown.percent())")
	}

	if metrics.sharpeRatio < limits.minSharpeRatio {
		breaches.append("Sharpe below minimum: \(metrics.sharpeRatio.number(3)) < \(limits.minSharpeRatio.number(3))")
	}

	return breaches
}

let breaches = checkRiskLimits(metrics: riskMetrics, limits: limits)
if breaches.isEmpty {
    print("✓ All risk limits satisfied")
} else {
    print("⚠️ Risk limit breaches:")
    for breach in breaches {
        print("  - \(breach)")
    }
}
```

### Monitoring Risk Over Time

```swift
// Track risk metrics daily/weekly
struct RiskSnapshot {
    let date: Date
    let var95: Double
    let sharpeRatio: Double
    let drawdown: Double
}

var riskHistory: [RiskSnapshot] = []

// Add current snapshot
riskHistory.append(RiskSnapshot(
    date: Date(),
    var95: riskMetrics.var95,
    sharpeRatio: riskMetrics.sharpeRatio,
    drawdown: riskMetrics.maxDrawdown
))

// Alert if risk increasing
if riskHistory.count >= 2 {
    let current = riskHistory.last!
    let previous = riskHistory[riskHistory.count - 2]

    let varIncrease = (abs(current.var95) - abs(previous.var95)) / abs(previous.var95)

    if varIncrease > 0.20 {  // VaR increased >20%
        print("⚠️ ALERT: VaR increased \(varIncrease.percent()) since last measurement")
    }
}
```

## Aggregating Risk Across Portfolios

Combine VaR across multiple portfolios accounting for correlations.
```swift
// Three portfolios with individual VaRs
let portfolioVaRs = [100_000.0, 150_000.0, 200_000.0]

// Correlation matrix
let correlations = [
	[1.0, 0.6, 0.4],
	[0.6, 1.0, 0.5],
	[0.4, 0.5, 1.0]
]
```
### Portfolio VaR Aggregation

```swift
// Aggregate VaR using variance-covariance method
let aggregatedVaR = RiskAggregator<Double>.aggregateVaR(
	individualVaRs: portfolioVaRs,
	correlations: correlations
)

let simpleSum = portfolioVaRs.reduce(0, +)
let diversificationBenefit = simpleSum - aggregatedVaR

print("VaR Aggregation:")
print("  Portfolio A VaR: \(portfolioVaRs[0].currency())")
print("  Portfolio B VaR: \(portfolioVaRs[1].currency())")
print("  Portfolio C VaR: \(portfolioVaRs[2].currency())")
print("  Simple sum: \(simpleSum.currency())")
print("  Aggregated VaR: \(aggregatedVaR.currency())")
print("  Diversification benefit: \(diversificationBenefit.currency())")
```

### Marginal VaR

Understand how each portfolio's risk contribution to total portfolio risk.

**Marginal VaR** is the derivative ∂VaR/∂v_i - it tells you how much the total portfolio VaR changes when you increase a position by $1. This is a **dimensionless ratio**, not a dollar amount.

```swift
// Calculate marginal VaR for each portfolio
print("\nMarginal VaR (sensitivity to $1 increase):")
for i in 0..<portfolioVaRs.count {
	let marginal = RiskAggregator<Double>.marginalVaR(
		entity: i,
		individualVaRs: portfolioVaRs,
		correlations: correlations
	)

	print("\nPortfolio \(["A", "B", "C"][i]):")
	print("  Individual VaR: \(portfolioVaRs[i].currency())")
	print("  Marginal VaR: \(marginal.formatted(.number.precision(.fractionLength(4))))")
	print("  Interpretation: Each $1 increase in this portfolio increases total VaR by $\(marginal.formatted(.number.precision(.fractionLength(2))))")
	print("  Risk contribution: \((marginal * 100).formatted(.number.precision(.fractionLength(1))))%")
}

// Note: Marginal VaR is already the risk contribution percentage (as a ratio)!
// It represents each portfolio's contribution to total risk on a per-dollar basis.
```

### Component VaR

Allocate total VaR to each portfolio based on weights. **Component VaR** gives you dollar amounts - it answers "how much of the total portfolio VaR is attributable to this position?"

**Important:** Component VaR applies weights to compute a weighted portfolio VaR, then allocates it. This is different from the unweighted `aggregatedVaR` calculated above.

**Key relationship:** Component_i = Weighted Position_i × Marginal VaR of weighted portfolio

```swift
let weights = [0.3, 0.4, 0.3]  // Portfolio allocation weights

// Component VaR computes VaR of the WEIGHTED portfolio
let componentVaRs = RiskAggregator<Double>.componentVaR(
	individualVaRs: portfolioVaRs,
	weights: weights,
	correlations: correlations
)

print("\nComponent VaR (dollar allocation of weighted portfolio risk):")
var totalComponentVaR = 0.0
for i in 0..<portfolioVaRs.count {
	let component = componentVaRs[i]
	totalComponentVaR += component
	let weightedPosition = weights[i] * portfolioVaRs[i]

	print("  Portfolio \(["A", "B", "C"][i]):")
	print("    Weight: \((weights[i] * 100).formatted(.number.precision(.fractionLength(0))))%")
	print("    Weighted position: \(weightedPosition.currency())")
	print("    Component VaR: \(component.currency())")
}

print("\nTotal component VaR: \(totalComponentVaR.currency())")
print("(Sum of components = VaR of weighted portfolio, by Euler allocation)")

// To verify, compute VaR of the weighted portfolio
let weightedVaRs = zip(weights, portfolioVaRs).map { $0 * $1 }
let weightedPortfolioVaR = RiskAggregator<Double>.aggregateVaR(
	individualVaRs: weightedVaRs,
	correlations: correlations
)
print("Weighted portfolio VaR: \(weightedPortfolioVaR.currency())")
print("Components sum correctly: \(abs(totalComponentVaR - weightedPortfolioVaR) < 1.0)")
```

**Summary of differences:**
- **Marginal VaR**: Sensitivity measure (ratio between 0-1) - "how much VaR changes per $1 increase"
- **Component VaR**: Attribution measure (dollars) - "how much of total VaR comes from this weighted position"
- **Aggregated VaR**: Total portfolio VaR with specified positions (can be weighted or unweighted)

## Next Steps

- Explore <doc:5.2-PortfolioOptimizationGuide> for risk-aware portfolio construction
- Learn <doc:3.12-RealOptionsGuide> for valuing downside protection options
- See <doc:4.2-ScenarioAnalysisGuide> for modeling risk scenarios

## See Also

- ``StressTest``
- ``StressScenario``
- ``RiskAggregator``
- ``ComprehensiveRiskMetrics``
