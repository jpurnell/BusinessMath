# Command-Line Visualization

Learn how to create visual representations of data directly in the terminal.

## Overview

BusinessMath provides command-line visualization tools for exploring data and presenting results without external dependencies. This tutorial shows you how to create:
- Histograms for distribution analysis
- Tornado diagrams for sensitivity analysis

These visualizations work in any terminal environment and are perfect for CLI applications, scripts, and quick data exploration.

## Content

## Histogram Visualization

Histograms show the distribution of values, making it easy to see patterns, central tendency, and outliers.

#### Basic Histogram

Create a histogram from simulation results:

```swift
import BusinessMath

// Run a Monte Carlo simulation
var revenueValues: [Double] = []
for _ in 0..<1_000 {
    // Simulate revenue with uncertainty
    let revenue = distributionNormal(mean: 1_000_000, stdDev: 100_000)
    revenueValues.append(revenue)
}

// Create simulation results
let results = SimulationResults(values: revenueValues)

// Generate histogram
let histogram = results.histogram(bins: 20)

// Visualize
let plot = plotHistogram(histogram)
print(plot)
```

**Output:**
```
Histogram (20 bins, 10,000 samples):

[  750000 -   800000):  â–ˆâ–ˆâ–ˆâ–ˆ 45 (  0.5%)
[  800000 -   850000):  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ 234 (  2.3%)
[  850000 -   900000):  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ 567 (  5.7%)
[  900000 -   950000):  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ 892 (  8.9%)
[  950000 -  1000000):  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ 1234 ( 12.3%)
[ 1000000 -  1050000):  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ 1256 ( 12.6%)
[ 1050000 -  1100000):  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ 1102 ( 11.0%)
[ 1100000 -  1150000):  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ 678 (  6.8%)
...
```

#### Interpreting Histograms

- **Bar length**: Represents the number of values in that range
- **Percentage**: Shows what portion of total values fall in that bin
- **Shape**: Reveals the distribution pattern
  - Bell curve: Normal distribution
  - Skewed right: More low values, few high outliers
  - Skewed left: More high values, few low outliers
  - Bimodal: Two distinct peaks

#### Choosing Bin Count

```swift
// Too few bins (5) - loses detail
let coarseHistogram = results.histogram(bins: 5)

// Good balance (20) - shows pattern clearly
let goodHistogram = results.histogram(bins: 20)

// Too many bins (100) - too granular, hard to see pattern
let fineHistogram = results.histogram(bins: 100)

// We have implemented Seaborn's automatic binning method, which selects the maximum bin count between Sturges' and Freedman-Diaconis rules. This often provides a better starting point for exploration by ensuring sufficient detail in the visualization.
```

#### Using Histograms for Analysis

```swift
// Example: Analyzing project completion time
let projectDurations = (0..<500).map({_ in distributionNormal(mean: 200, stdDev: 14)})
let completionDays = SimulationResults(values: projectDurations)
let hist = completionDays.histogram(bins: 20)

print(plotHistogram(hist))

// Find the mode (most common range)
let maxBin = hist.max { $0.count < $1.count }!
print("\nMost likely completion time: \(maxBin.range.lowerBound.number(0))-\(maxBin.range.upperBound.number(0)) days")

// Check for outliers
let p95 = completionDays.percentiles.p95
let p5 = completionDays.percentiles.p5
print("Middle 90% of outcomes: \(p5.number(1)) to \(p95.number(1)) days")

// Risk analysis
let probDelay = completionDays.probabilityAbove(deadlineDays)
print("Probability of missing deadline (\(deadlineDays.number(0)) days)): \(probDelay.percent())")
```

## Tornado Diagram Visualization

Tornado diagrams show which inputs have the greatest impact on outputs, making them essential for sensitivity analysis.

#### Basic Tornado Diagram

Create a tornado diagram from sensitivity analysis:

```swift
import BusinessMath

// Define periods for our analysis
let q1 = Period.quarter(year: 2024, quarter: 1)
let q2 = Period.quarter(year: 2024, quarter: 2)
let q3 = Period.quarter(year: 2024, quarter: 3)
let q4 = Period.quarter(year: 2024, quarter: 4)
let periods = [q1, q2, q3, q4]

// Create an entity (company) for our model
let entity = Entity(id: "CS123", name: "Coffee Shop")

// Create base case scenario with driver overrides
var driverOverrides: [String: AnyDriver<Double>] = [:]
driverOverrides["Price"] = AnyDriver(DeterministicDriver(name: "Price", value: 100.0))
driverOverrides["Volume"] = AnyDriver(DeterministicDriver(name: "Volume", value: 1000.0))
driverOverrides["Cost"] = AnyDriver(DeterministicDriver(name: "Cost", value: 60.0))
driverOverrides["OpEx"] = AnyDriver(DeterministicDriver(name: "OpEx", value: 10_000.0))
driverOverrides["Tax Rate"] = AnyDriver(DeterministicDriver(name: "Tax Rate", value: 0.25))

let baseCase = FinancialScenario(
	name: "Base Case",
	description: "Standard operating scenario",
	driverOverrides: driverOverrides
)

// Builder function that creates financial statements from drivers
let builder: ScenarioRunner.StatementBuilder = { drivers, periods in
	// Sample driver values
	let price = drivers["Price"]?.sample(for: periods[0]) ?? 100.0
	let volume = drivers["Volume"]?.sample(for: periods[0]) ?? 1000.0
	let cost = drivers["Cost"]?.sample(for: periods[0]) ?? 60.0
	let opex = drivers["OpEx"]?.sample(for: periods[0]) ?? 10_000.0
	let taxRate = drivers["Tax Rate"]?.sample(for: periods[0]) ?? 0.25

	// Calculate financial metrics
	let revenue = price * volume
	let cogs = cost * volume
	let netBeforeTax = revenue - cogs - opex
	let netAfterTax = netBeforeTax * (1.0 - taxRate)

	// Create time series for all periods
	let revenueValues = Array(repeating: revenue, count: periods.count)
	let cogsValues = Array(repeating: cogs, count: periods.count)
	let opexValues = Array(repeating: opex, count: periods.count)
	let netValues = Array(repeating: netAfterTax, count: periods.count)

	let revenueSeries = TimeSeries<Double>(periods: periods, values: revenueValues)
	let cogsSeries = TimeSeries<Double>(periods: periods, values: cogsValues)
	let opexSeries = TimeSeries<Double>(periods: periods, values: opexValues)
	let netSeries = TimeSeries<Double>(periods: periods, values: netValues)

	// Build accounts
	let revenueAccount = try Account(entity: entity, name: "Revenue", incomeStatementRole: .revenue, timeSeries: revenueSeries)
	let cogsAccount = try Account(entity: entity, name: "COGS", incomeStatementRole: .costOfGoodsSold, timeSeries: cogsSeries)
	let opexAccount = try Account(entity: entity, name: "OpEx", incomeStatementRole: .operatingExpenseOther, timeSeries: opexSeries)

	// Build income statement
	let incomeStatement = try IncomeStatement(
		entity: entity,
		periods: periods,
		accounts: [revenueAccount, cogsAccount, opexAccount]
	)
	// Build balance sheet (simplified for example)
	let cashAndEquivalents = try Account(
		entity: entity,
		name: "Cash",
		balanceSheetRole: .cashAndEquivalents,
		timeSeries: netSeries
	)
	let equityAccount = try Account(
		entity: entity,
		name: "Equity",
		balanceSheetRole: .commonStock,
		timeSeries: netSeries
	)
	let balanceSheet = try BalanceSheet(
		entity: entity,
		periods: periods,
		accounts: [cashAndEquivalents, equityAccount]
	)

	// Build cash flow statement (simplified for example)
	let cashAccount = try Account(entity: entity, name: "Operating Cash", cashFlowRole: .otherOperatingActivities, timeSeries: netSeries)
	let cashFlowStatement = try CashFlowStatement(
		entity: entity,
		periods: periods,
		accounts: [cashAccount]
	)

	return (incomeStatement, balanceSheet, cashFlowStatement)
}

// Run tornado analysis
let tornado = try runTornadoAnalysis(
	baseCase: baseCase,
	entity: entity,
	periods: periods,
	inputDrivers: ["Price", "Volume", "Cost", "OpEx", "Tax Rate"],
	variationPercent: 0.20,  // Vary each input by Â±20%
	steps: 2,
	builder: builder
) { projection in
	// Extract the metric we care about (e.g., Q1 Net Income)
	return projection.incomeStatement.netIncome[q1]!
}

// Visualize
let tornadoPlot = plotTornadoDiagram(tornado)
print(tornadoPlot)
```

**Output:**
```
Tornado Diagram - Sensitivity Analysis
Base Case: 30000

Price    â—„â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ|â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–º Impact: 40000 133.3%
		   10000                 30000                 50000)
Cost     â—„          â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ|â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ          â–º Impact: 24000 80.0%
		   18000                 30000                 42000)
Volume   â—„               â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ|â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ               â–º Impact: 16000 53.3%
		   22000                 30000                 38000)
OpEx     â—„                       â–ˆâ–ˆ|â–ˆâ–ˆâ–ˆ                      â–º Impact: 4000 13.3%
		   28000                 30000                 32000)
Tax Rate â—„                         |                         â–º Impact: 0 0.0%
		   30000                 30000                 30000)
```

#### Interpreting Tornado Diagrams

**Structure:**
- **Vertical axis**: Input drivers, ranked by impact (largest first)
- **Horizontal axis**: Output values
- **Center line (â”‚)**: Base case output
- **Left bars**: Output when input is decreased
- **Right bars**: Output when input is increased

**Insights:**
- **Bar length**: Shows total impact range
- **Symmetry**: Equal left/right bars = linear relationship
- **Asymmetry**: Unequal bars = non-linear relationship
- **Direction**:
  - Right-heavy: Input positively affects output (Revenue)
  - Left-heavy: Input negatively affects output (Costs)

#### Using Tornado Diagrams for Decision Making

```swift
// Identify key drivers
print("Top 3 Value Drivers:")
for (i, input) in tornado.inputs.prefix(3).enumerated() {
	let impact = tornado.impacts[input]!
	let percentImpact = (impact / tornado.baseCaseOutput)
	print("\(i+1). \(input): Â±\(percentImpact.percent()) impact on output")
}

// Focus management attention
let topDriver = tornado.inputs.first!
let topImpact = tornado.impacts[topDriver]!

print("\nðŸ’¡ Key Insight:")
print("Focus on \(topDriver) - it has \(Int(topImpact)) impact,")
print("which is \((topImpact / tornado.impacts[tornado.inputs.last!]!).number(1))x more than \(tornado.inputs.last!)")

// Risk vs. Opportunity
for input in tornado.inputs {
	let low = tornado.lowValues[input]!
	let high = tornado.highValues[input]!
	let base = tornado.baseCaseOutput

	let downside = base - low
	let upside = high - base

	if downside > upside {
		print("\nâš ï¸  \(input): More downside risk than upside")
	} else if upside > downside * 1.5 {
		print("\nðŸ“ˆ \(input): Significant upside opportunity")
	}
}
```

#### Comparing Scenarios

Use tornado diagrams to compare different scenarios:

```swift
// Base case
let baseTornado = try runTornadoAnalysis(
    baseCase: baseCase,
    entity: entity,
    periods: periods,
    inputDrivers: ["Price", "Volume", "Cost", "OpEx"],
    variationPercent: 0.20,
    steps: 2,
    builder: builder
) { projection in
    return projection.incomeStatement.netIncome[q1]!
}

// After improvement initiative - create scenario with lower costs
var improvedDriverOverrides: [String: AnyDriver<Double>] = [:]
improvedDriverOverrides["Price"] = AnyDriver(DeterministicDriver(name: "Price", value: 100.0))
improvedDriverOverrides["Volume"] = AnyDriver(DeterministicDriver(name: "Volume", value: 1000.0))
improvedDriverOverrides["Cost"] = AnyDriver(DeterministicDriver(name: "Cost", value: 40.0))  // Reduced from 60
improvedDriverOverrides["OpEx"] = AnyDriver(DeterministicDriver(name: "OpEx", value: 9_000.0))  // Reduced from 10,000

let improvedCase = FinancialScenario(
    name: "Improved Case",
    description: "After cost reduction initiative",
    driverOverrides: improvedDriverOverrides
)

let improvedTornado = try runTornadoAnalysis(
    baseCase: improvedCase,
    entity: entity,
    periods: periods,
    inputDrivers: ["Price", "Volume", "Cost", "OpEx"],
    variationPercent: 0.20,
    steps: 2,
    builder: builder
) { projection in
    return projection.incomeStatement.netIncome[q1]!
}

print("=== Before Improvement ===")
print(plotTornadoDiagram(baseTornado))

print("\n=== After Cost Reduction ===")
print(plotTornadoDiagram(improvedTornado))

// Compare sensitivities
for input in baseTornado.inputs {
    let baseImpact = baseTornado.impacts[input]!
    let improvedImpact = improvedTornado.impacts[input]!
    let change = ((improvedImpact - baseImpact) / baseImpact)

    if abs(change) > 0.1 {
        print("\(input) sensitivity changed by \(change.percent()")
    }
}
```

## Combining Visualizations

Use both histograms and tornado diagrams together for comprehensive analysis:

```swift
import BusinessMath

// Setup periods and entity
	let q1 = Period.quarter(year: 2024, quarter: 1)
	let q2 = Period.quarter(year: 2024, quarter: 2)
	let q3 = Period.quarter(year: 2024, quarter: 3)
	let q4 = Period.quarter(year: 2024, quarter: 4)
	let periods = [q1, q2, q3, q4]
let entityCV = Entity(id: "CS123", name: "Coffee Shop")

// Create base case scenario
	var driverOverrides: [String: AnyDriver<Double>] = [:]
	driverOverrides["Price"] = AnyDriver(DeterministicDriver(name: "Price", value: 100.0))
	driverOverrides["Volume"] = AnyDriver(DeterministicDriver(name: "Volume", value: 1000.0))
	driverOverrides["Cost"] = AnyDriver(DeterministicDriver(name: "Cost", value: 60.0))
	driverOverrides["OpEx"] = AnyDriver(DeterministicDriver(name: "OpEx", value: 10_000.0))

	let baseCase = FinancialScenario(
		name: "Base Case",
		description: "Standard operating scenario",
		driverOverrides: driverOverrides
	)

// Builder function
let builderCV: ScenarioRunner.StatementBuilder = { drivers, periods in
	let price = drivers["Price"]?.sample(for: periods[0]) ?? 100.0
	let volume = drivers["Volume"]?.sample(for: periods[0]) ?? 1000.0
	let cost = drivers["Cost"]?.sample(for: periods[0]) ?? 60.0
	let opex = drivers["OpEx"]?.sample(for: periods[0]) ?? 10_000.0

	let revenue = price * volume
	let cogs = cost * volume
	let netIncome = revenue - cogs - opex

	let revenueValues = Array(repeating: revenue, count: periods.count)
	let cogsValues = Array(repeating: cogs, count: periods.count)
	let opexValues = Array(repeating: opex, count: periods.count)
	let netValues = Array(repeating: netIncome, count: periods.count)

	let revenueSeries = TimeSeries<Double>(periods: periods, values: revenueValues)
	let cogsSeries = TimeSeries<Double>(periods: periods, values: cogsValues)
	let opexSeries = TimeSeries<Double>(periods: periods, values: opexValues)
	let netSeries = TimeSeries<Double>(periods: periods, values: netValues)

	let revenueAccount = try Account(entity: entity, name: "Revenue", incomeStatementRole: .revenue, timeSeries: revenueSeries)
	let cogsAccount = try Account(entity: entity, name: "COGS", incomeStatementRole: .costOfGoodsSold, timeSeries: cogsSeries)
	let opexAccount = try Account(entity: entity, name: "OpEx", incomeStatementRole: .operatingExpenseOther, timeSeries: opexSeries)

	let incomeStatement = try IncomeStatement(
		entity: entity,
		periods: periods,
		accounts: [revenueAccount, cogsAccount, opexAccount]
	)

	let assetAccount = try Account(entity: entity, name: "Cash", balanceSheetRole: .cashAndEquivalents, timeSeries: netSeries)
	let equityAccount = try Account(entity: entity, name: "Equity", balanceSheetRole: .commonStock, timeSeries: netSeries)
	let balanceSheet = try BalanceSheet(
		entity: entity,
		periods: periods,
		accounts: [assetAccount, equityAccount]
	)
	
	let cashAccount = try Account(entity: entity, name: "Cash", cashFlowRole: .otherOperatingActivities, timeSeries: netSeries)
	let cashFlowStatement = try CashFlowStatement(
		entity: entity,
		periods: periods,
		accounts: [cashAccount]
	)

	return (incomeStatement, balanceSheet, cashFlowStatement)
}

// 1. Identify key drivers with tornado diagram
let tornadoCV = try runTornadoAnalysis(
	baseCase: baseCase,
	entity: entity,
	periods: periods,
	inputDrivers: ["Price", "Volume", "Cost", "OpEx"],
	variationPercent: 0.20,
	steps: 2,
	builder: builder
) { projection in
	return projection.incomeStatement.netIncome[q1]!
}

print(plotTornadoDiagram(tornadoCV))

let topDriverCV = tornadoCV.inputs.first!
print("\n\(topDriverCV) is the most impactful driver")

// 2. Run Monte Carlo on top driver to see distribution
var netIncomeResults: [Double] = []
for _ in 0..<10_000 {
	// Simulate the top driver with uncertainty (Â±20% standard deviation)
	let baseValue = 100.0  // Base price from our scenario
	let uncertainty = baseValue * 0.2
	let simulatedPrice = distributionNormal(mean: baseValue, stdDev: uncertainty)

	// Calculate output with simulated price
	let volume = 1000.0
	let cost = 60.0
	let opex = 10_000.0
	let revenue = simulatedPrice * volume
	let cogs = cost * volume
	let output = revenue - cogs - opex

	netIncomeResults.append(output)
}

let simResultsCV = SimulationResults(values: netIncomeResults)
let histogramCV = simResultsCV.histogram(bins: 20)

print("\n\(topDriverCV) Impact Distribution:")
print(plotHistogram(histogramCV))

// 3. Analyze the combined insights
let targetCV = 25_000.0  // Target net income

print("\nKey Insights:")
print("- \(topDriverCV) has Â±\(tornadoCV.impacts[topDriverCV]!.currency(0)) impact (tornado)")
print("- 90% of outcomes fall between \(simResultsCV.percentiles.p5.currency(0)) and \(simResultsCV.percentiles.p95.currency(0)) (histogram)")
print("- Expected value: \(simResultsCV.statistics.mean.currency(0))")
print("- Probability of exceeding target (\(targetCV.currency(0))): \(simResultsCV.probabilityAbove(targetCV).percent())")
```

## Exporting Visualizations

Save visualizations to files for reports or documentation:

```swift
import Foundation

// Save histogram to file
let histogram = results.histogram(bins: 20)
let histogramPlot = plotHistogram(histogram)

let histogramPath = "outputs/revenue_distribution.txt"
try histogramPlot.write(toFile: histogramPath, atomically: true, encoding: .utf8)
print("Histogram saved to \(histogramPath)")

// Save tornado diagram to file
let tornado = try runTornadoAnalysis(...)
let tornadoPlot = plotTornadoDiagram(tornado)

let tornadoPath = "outputs/sensitivity_analysis.txt"
try tornadoPlot.write(toFile: tornadoPath, atomically: true, encoding: .utf8)
print("Tornado diagram saved to \(tornadoPath)")

// Combine into report
var report = """
# Financial Analysis Report
Generated: \(Date())

## Revenue Distribution Analysis

\(histogramPlot)

## Sensitivity Analysis

\(tornadoPlot)

## Summary
- Most impactful driver: \(tornado.inputs.first!)
- Expected revenue: \(results.statistics.mean.currency(0))
- Risk (95% VaR): \(results.riskMetrics.valueAtRisk(confidenceLevel: 0.95).currency(0))
"""

try report.write(toFile: "outputs/full_report.txt", atomically: true, encoding: .utf8)
```

## Best Practices

#### Histograms
1. **Choose appropriate bin count**: Too few loses detail, too many adds noise
2. **Label your axes**: Make it clear what the values represent
3. **Show sample size**: Include the number of data points
4. **Highlight key percentiles**: Mark P5, P50, P95 on the output
5. **Compare distributions**: Plot multiple histograms side-by-side

#### Tornado Diagrams
1. **Use consistent variation**: Â±10%, Â±20%, or Â±30% for all inputs
2. **Include base case**: Show the reference point clearly
3. **Rank by impact**: Keep drivers sorted (largest first)
4. **Show percentage impact**: Helps compare to base case
5. **Focus on top drivers**: Top 5-7 usually account for most variance

#### General
1. **Keep it simple**: Don't overload with information
2. **Use in context**: Explain what the chart shows
3. **Verify data**: Check that visualizations match expectations
4. **Combine insights**: Use multiple visualization types
5. **Document assumptions**: Note what went into the analysis

## Limitations

## Current Limitations
- Text-based only (no graphical plots)
- Fixed Unicode characters (requires Unicode terminal support)
- No interactive features
- No color coding (terminal-dependent)

## Future Enhancements
Planned for companion packages:
- **BusinessMathCharts**: Swift Charts integration for graphical plots
- **BusinessMathUI**: Optional SwiftUI interface for interactive visualization
- Color-coded outputs for modern terminals
- Interactive drill-down capabilities

## Next Steps

- Learn about <doc:4.2-ScenarioAnalysisGuide> to generate data for tornado diagrams
- Explore <doc:2.2-FinancialRatiosGuide> for metrics to visualize
- See <doc:1.1-GettingStarted> for simulation examples

## Related Topics

- ``plotHistogram(_:)``
- ``plotTornadoDiagram(_:)``
- ``SimulationResults``
- ``TornadoDiagramAnalysis``
- ``runTornadoAnalysis(baseCase:entity:periods:inputDrivers:variationPercent:steps:builder:outputExtractor:)``
