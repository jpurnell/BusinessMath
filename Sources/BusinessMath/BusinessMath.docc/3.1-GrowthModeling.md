# Growth Modeling and Forecasting

Analyze trends, model growth patterns, and forecast future values.

## Overview

Growth modeling is essential for business planning, revenue forecasting, and strategic decision-making. BusinessMath provides three complementary approaches:

- **Growth Rates**: Calculate simple and compound growth rates (CAGR)
- **Trend Models**: Fit mathematical models to historical data
- **Seasonality**: Extract and apply seasonal patterns

Combined, these tools enable sophisticated forecasting that accounts for both long-term trends and recurring patterns.

## Growth Rates

Growth rates measure the rate of change between values.

### Simple Growth Rate

```swift
// Revenue grew from $100k to $120k
let growth = growthRate(from: 100_000, to: 120_000)
// Result: 0.20 (20% growth)

// Negative growth (decline)
let decline = growthRate(from: 120_000, to: 100_000)
// Result: -0.1667 (-16.67% decline)
```

**Formula:**

```
Growth Rate = (Ending Value - Beginning Value) / Beginning Value
            = (Ending / Beginning) - 1
```

### Compound Annual Growth Rate (CAGR)

CAGR smooths out volatility to show steady equivalent growth:

```swift
// Revenue trajectory: $100k → $110k → $125k → $150k over 3 years
let compoundGrowth = cagr(
    beginningValue: 100_000,
    endingValue: 150_000,
    years: 3
)
// Result: ~0.1447 (14.47% per year)

// Verify: does 14.47% compound for 3 years give $150k?
let verification = 100_000 * pow(1.1447, 3)
// Result: ~150,000 ✓
```

**Formula:**

```
CAGR = (Ending Value / Beginning Value)^(1/years) - 1
```

### Applying Growth

Project future values using growth rates:

```swift
// Project $100k base with 15% annual growth for 5 years
let projection = applyGrowth(
    baseValue: 100_000,
    rate: 0.15,
    periods: 5,
    compounding: .annual
)
// Result: [100k, 115k, 132.25k, 152.09k, 174.90k, 201.14k]
```

### Compounding Frequencies

Different compounding frequencies affect growth:

```swift
let base = 100_000.0
let rate = 0.12  // 12% annual rate
let years = 5

// Annual compounding
let annual = applyGrowth(baseValue: base, rate: rate, periods: years, compounding: .annual)
print(annual.last!.number(0))
// Final: ~176,234

// Quarterly compounding (12%/4 = 3% per quarter, 20 quarters)
let quarterly = applyGrowth(baseValue: base, rate: rate, periods: years * 4, compounding: .quarterly)
print(quarterly.last!.number(0))
// Final: ~180,611 (higher due to more frequent compounding)

// Monthly compounding (12%/12 = 1% per month, 60 months)
let monthly = applyGrowth(baseValue: base, rate: rate, periods: years * 12, compounding: .monthly)
print(monthly.last!.number(0))
// Final: ~181,670

// Daily compounding
let daily = applyGrowth(baseValue: base, rate: rate, periods: years * 365, compounding: .daily)
print(daily.last!.number(0))
// Final: ~182,194

// Continuous compounding (e^(rt))
let continuous = applyGrowth(baseValue: base, rate: rate, periods: years, compounding: .continuous)
print(continuous.last!.number(0))
// Final: ~182,212 (theoretical maximum)
```

### Real-World Applications

**Revenue Growth Analysis:**

```swift
// Q1 2024: $500k, Q1 2025: $650k
let quarterlyGrowth = try growthRate(from: 500_000, to: 650_000)
// Result: 30% year-over-year growth

// Project next 4 quarters at this rate
let forecast = applyGrowth(
    baseValue: 650_000,
    rate: 0.30 / 4,  // Quarterly rate
    periods: 4,
    compounding: .quarterly
)
```

**Population Growth:**

```swift
// City grew from 100k to 125k residents over 5 years
let populationCAGR = cagr(beginningValue: 100_000, endingValue: 125_000, years: 5)
// Result: ~4.56% per year

// Project 10 years forward
let population2035 = 125_000 * pow(1 + populationCAGR, 10)
print(population2035.number(0))
```

**Investment Returns:**

```swift
// Portfolio: $50k → $86k over 8 years
let investmentReturn = cagr(beginningValue: 50_000, endingValue: 85_925, years: 8)
// Result: ~7.0% per year (good long-term return)
```

## Trend Models

Trend models fit mathematical functions to historical data for forecasting.

### Linear Trend

Linear trends model constant absolute growth:

```swift
// Historical revenue shows steady ~$5k/month increase
let linearTrendPeriods = (1...12).map { Period.month(year: 2024, month: $0) }
let linearTrendRevenueValues: [Double] = [100, 105, 110, 108, 115, 120, 118, 125, 130, 128, 135, 140]

let linearTrendRevenue = TimeSeries(periods: linearTrendPeriods, values: linearTrendRevenueValues)

// Fit linear trend
var linearTrend = LinearTrend<Double>()
try linearTrend.fit(to: linearTrendRevenue)

// Project 6 months forward
let linearForecast = try linearTrend.project(periods: 6)
print(linearForecast.valuesArray.map({"\($0.number(0))"}).joined(separator: ", "))
// Result: [142, 145, 148, 152, 155, 159] (approximately)
```

**Formula:**

```
y = mx + b

Where:
- y = predicted value
- m = slope (rate of change)
- x = time index
- b = intercept (starting value)
```

**Best for:**
- Steady absolute growth (e.g., adding same number of customers each month)
- Short-term forecasts
- Linear relationships

### Exponential Trend

Exponential trends model constant percentage growth:

```swift
// Revenue doubling every few years
let exponentialTrendPeriods = (0..<10).map { Period.year(2015 + $0) }
let exponentialTrendRevenue: [Double] = [100, 115, 130, 155, 175, 200, 235, 265, 310, 350]

let exponentialTrendHistorical = TimeSeries(periods: exponentialTrendPeriods, values: exponentialTrendRevenue)

// Fit exponential trend
var exponentialTrend = ExponentialTrend<Double>()
try exponentialTrend.fit(to: exponentialTrendHistorical)

// Project 5 years forward
let exponentialForecast = try exponentialTrend.project(periods: 5)
print(exponentialForecast.valuesArray.map({"\($0.number(0))"}).joined(separator: ", "))
// Result: Continues exponential growth pattern - [407, 468, 538, 619, 713]
```

**Formula:**

```
y = a × e^(bx)

Where:
- y = predicted value
- a = initial value
- b = growth rate
- x = time index
- e = Euler's number (2.71828...)
```

**Best for:**
- Constant percentage growth (e.g., 15% per year)
- Long-term trends
- Compound growth scenarios

### Logistic Trend

Logistic trends model growth that approaches a capacity limit (S-curve):

```swift
// User adoption starts slow, accelerates, then plateaus
let logisticTrendPeriods = (0..<24).map { Period.month(year: 2023 + $0/12, month: ($0 % 12) + 1) }
let logisticTrendUsers: [Double] = [100, 150, 250, 400, 700, 1200, 2000, 3500, 5500, 8000,
						11000, 14000, 17000, 19500, 21500, 23000, 24000, 24500,
						24800, 24900, 24950, 24970, 24985, 24990]

let logisticTrendHistorical = TimeSeries(periods: logisticTrendPeriods, values: logisticTrendUsers)

// Fit logistic trend with capacity of 25,000 users
var logisticTrend = LogisticTrend<Double>(capacity: 25_000)
try logisticTrend.fit(to: logisticTrendHistorical)

// Project 12 months forward
let logisticForecast = try logisticTrend.project(periods: 12)
print(logisticForecast.valuesArray.map({"\($0.number(0))"}).joined(separator: ", "))
// Result: Approaches but never exceeds 25,000 -
[22,966, 23,267, 23,526, 23,749, 23,939, 24,102, 24,240, 24,358, 24,458, 24,543, 24,614, 24,675]
```

**Formula:**

```
y = L / (1 + e^(-k(x-x₀)))

Where:
- y = predicted value
- L = capacity (maximum value)
- k = growth rate
- x = time index
- x₀ = midpoint of curve
```

**Best for:**
- Market saturation scenarios
- Product adoption curves
- Biological growth (population with carrying capacity)
- SaaS user growth with market limits

### Custom Trend

Define custom trend functions:

```swift
// Custom quadratic trend: y = 0.5x² + 10x + 100
// For playgrounds, define the closure separately with explicit type
let quadraticFunction: @Sendable (Double) -> Double = { x in
	return 0.5 * x * x + 10.0 * x + 100.0
}

var customTrend = CustomTrend<Double>(trendFunction: quadraticFunction)

// Fit to historical data to set metadata
let customTrendHistorical = TimeSeries(
	periods: [Period.month(year: 2025, month: 1)],
	values: [100.0]
)
try customTrend.fit(to: customTrendHistorical)

// Project future values using the custom function
let customForecast = try customTrend.project(periods: 12)
print(customForecast.valuesArray.map({"\($0.number(0))"}).joined(separator: ", "))
```

### Confidence Intervals for Trends

All trend models support confidence intervals to quantify forecast uncertainty:

```swift
// Historical data with some noise
let periods = (1...12).map { Period.month(year: 2024, month: $0) }
let values: [Double] = [100, 103, 111, 117, 119, 126, 131, 133, 141, 146, 149, 157]
let historical = TimeSeries(periods: periods, values: values)

// Linear trend with 95% confidence intervals
var linear = LinearTrend<Double>()
try linear.fit(to: historical)
let linearCI = try linear.projectWithConfidence(
    periods: 6,
    confidenceLevel: 0.95
)

print("6-month forecast with 95% confidence intervals:")
for i in 0..<6 {
    let period = linearCI.forecast.periods[i]
    let forecast = linearCI.forecast.valuesArray[i]
    let lower = linearCI.lowerBound.valuesArray[i]
    let upper = linearCI.upperBound.valuesArray[i]

    print("\(period.label): \(forecast.number(0)) [95% CI: \(lower.number(0)) - \(upper.number(0))]")
}
// Output shows widening confidence intervals over time
// Jan 2025: 165 [95% CI: 159 - 171]
// ...
// Jun 2025: 190 [95% CI: 179 - 201]  ← Wider interval farther out
```

**Key Features:**

- **Automatic Residual Tracking**: Models calculate residuals during `fit()` for CI computation
- **Forecast Horizon Effect**: Confidence intervals widen for longer-term forecasts
- **Model-Specific Constraints**:
  - ExponentialTrend: Lower bounds clamped to zero (no negative values)
  - LogisticTrend: Upper bounds respect capacity constraint
- **Statistical Foundation**: Uses standard error and z-scores from built-in functions

**Different Confidence Levels:**

```swift
var exponential = ExponentialTrend<Double>()
try exponential.fit(to: historical)

// Compare different confidence levels
let ci90 = try exponential.projectWithConfidence(periods: 6, confidenceLevel: 0.90)
let ci95 = try exponential.projectWithConfidence(periods: 6, confidenceLevel: 0.95)
let ci99 = try exponential.projectWithConfidence(periods: 6, confidenceLevel: 0.99)

// Higher confidence = wider intervals
// 90% CI: [185 - 200]
// 95% CI: [182 - 205]  ← Wider
// 99% CI: [177 - 212]  ← Widest
```

### Comparing Trends

Evaluate which model fits best:

```swift
let historical = TimeSeries(periods: periods, values: values)

// Fit multiple models
var linear = LinearTrend<Double>()
try linear.fit(to: historical)

var exponential = ExponentialTrend<Double>()
try exponential.fit(to: historical)

var logistic = LogisticTrend<Double>(capacity: 10_000)
try logistic.fit(to: historical)

// Compare on holdout data
let trainData = historical.range(from: periods[0], to: periods[8])
let testData = historical.range(from: periods[9], to: periods[11])

// Fit on training data, evaluate on test data
var linearModel = LinearTrend<Double>()
try linearModel.fit(to: trainData)
let linearForecast = try linearModel.project(periods: 3)

// Calculate error metrics using the built-in API
let linearMetrics = testData.forecastError(against: linearForecast)
print("Linear Model:")
print("  RMSE: \(linearMetrics.rmse.number(2))")
print("  MAE:  \(linearMetrics.mae.number(2))")
print("  MAPE: \(linearMetrics.mape.number(2))%")

var exponentialModel = ExponentialTrend<Double>()
try exponentialModel.fit(to: trainData)
let exponentialForecast = try exponentialModel.project(periods: 3)
let expMetrics = testData.forecastError(against: exponentialForecast)
print("\nExponential Model:")
print(expMetrics.summary)

// Choose model with lowest error
let bestModel = linearMetrics.rmse < expMetrics.rmse ? "Linear" : "Exponential"
print("\nBest model based on RMSE: \(bestModel)")
print("(RMSE penalizes large errors; use MAE if all errors equally important)")
```

## Seasonality

Seasonality captures recurring patterns (weekly, monthly, quarterly, annual).

### Seasonal Indices

Calculate seasonal factors:

```swift
// Quarterly revenue with Q4 holiday spike
let periods = (0..<12).map { Period.quarter(year: 2022 + $0/4, quarter: ($0 % 4) + 1) }
let revenue: [Double] = [100, 120, 110, 150,  // 2022
                         105, 125, 115, 160,  // 2023
                         110, 130, 120, 170]  // 2024

let ts = TimeSeries(periods: periods, values: revenue)

// Calculate seasonal indices (4 quarters per year)
let indices = try seasonalIndices(timeSeries: ts, periodsPerYear: 4)
print(indices.map({"\($0.number(2))"}).joined(separator: ", "))
// Result: [~0.85, ~1.00, ~0.91, ~1.24]
// Q1: 16% below average
// Q2: 1% above average
// Q3: 7% below average
// Q4: 22% above average (holiday season!)
```

**Interpretation:**
- Index = 1.0: Average seasonal performance
- Index > 1.0: Above average (peak season)
- Index < 1.0: Below average (off season)

### Seasonal Adjustment

Remove seasonality to see underlying trend:

```swift
// Remove seasonal effects
let deseasonalized = try seasonallyAdjust(timeSeries: ts, indices: indices)

// Original: [100, 120, 110, 150, ...]
// Deseasonalized: [~117, ~120, ~121, ~121, ...]
// Now you can see the true trend without seasonal noise
```

**Use cases:**
- Compare performance across different seasons fairly
- Identify true growth vs. seasonal effects
- Fit trend models to deseasonalized data

### Applying Seasonal Patterns

Add seasonality back to forecasts:

```swift
// Project deseasonalized trend forward
var trend = LinearTrend<Double>()
try trend.fit(to: deseasonalized)
let trendForecast = try trend.project(periods: 4)

// Reapply seasonal pattern
let seasonalForecast = try applySeasonal(timeSeries: trendForecast, indices: indices)
print(seasonalForecast.map({"\($0.number(0))"}).joined(separator: ", "))
// Result: Trend forecast × seasonal indices = realistic forecast
[116, 138, 126, 175]
```

### Time Series Decomposition

Separate time series into components:

```swift
let decomposition = try decomposeTimeSeries(
    timeSeries: ts,
    periodsPerYear: 4,
    method: .multiplicative
)

print("Trend:", decomposition.trend.valuesArray)
// Long-term direction (increasing, decreasing, flat)

print("Seasonal:", decomposition.seasonal.valuesArray)
// Recurring patterns (same each cycle)

print("Residual:", decomposition.residual.valuesArray)
// Random noise (what's left after removing trend and seasonal)

```

**Multiplicative decomposition:**

```
Actual = Trend × Seasonal × Residual
```

Use when seasonal variation proportional to level (e.g., 20% spike in Q4).

**Additive decomposition:**

```
Actual = Trend + Seasonal + Residual
```

Use when seasonal variation is constant (e.g., +$10k in Q4).

### Real-World Seasonality Examples

**Retail Sales:**

```swift
// High seasonality: Back-to-school (Q3), Holidays (Q4)
let retailIndices = [0.85, 0.90, 1.10, 1.15]  // Q1-Q4
```

**SaaS Metrics:**

```swift
// Moderate seasonality: Lower in summer (Q3), higher year-end (Q4)
let saasIndices = [1.02, 1.03, 0.92, 1.03]  // Q1-Q4
```

**Ice Cream Sales:**

```swift
// Extreme seasonality: Summer peak
let iceCreamIndices = [0.60, 1.10, 1.50, 0.80]  // Q1-Q4
```

**B2B Software:**

```swift
// Minimal seasonality: Enterprise sales relatively stable
let b2bIndices = [0.98, 1.01, 0.99, 1.02]  // Q1-Q4
```

## Complete Forecasting Workflow

Combine all techniques for robust forecasting:

```swift
// 1. Load historical data
let historical = TimeSeries(periods: historicalPeriods, values: historicalRevenue)

// 2. Extract seasonal pattern
let seasonalIndices = try seasonalIndices(timeSeries: historical, periodsPerYear: 4)

// 3. Deseasonalize to reveal underlying trend
let deseasonalized = try seasonallyAdjust(timeSeries: historical, indices: seasonalIndices)

// 4. Fit trend model to deseasonalized data
var trend = LinearTrend<Double>()
try trend.fit(to: deseasonalized)

// 5. Project trend forward
let forecastPeriods = 4  // Next 4 quarters
let trendForecast = try trend.project(periods: forecastPeriods)

// 6. Reapply seasonality to trend forecast
let seasonalForecast = try applySeasonal(timeSeries: trendForecast, indices: seasonalIndices)

// 7. Present forecast with confidence intervals
let trendCI = try trend.projectWithConfidence(
    periods: forecastPeriods,
    confidenceLevel: 0.95
)

for i in 0..<forecastPeriods {
    let period = seasonalForecast.periods[i]
    let forecast = seasonalForecast.valuesArray[i]
    // Scale CI bounds by same seasonal factor
    let seasonalFactor = seasonalForecast.valuesArray[i] / trendForecast.valuesArray[i]
    let lower = trendCI.lowerBound.valuesArray[i] * seasonalFactor
    let upper = trendCI.upperBound.valuesArray[i] * seasonalFactor

    print("\(period.label): \(forecast.currency(0)) [95% CI: \(lower.currency(0)) - \(upper.currency(0))]")
}
```

## Choosing the Right Approach

### Decision Tree

**Step 1: Does your data have seasonality?**
- Yes → Extract seasonal pattern first
- No → Skip to trend modeling

**Step 2: What kind of growth pattern?**
- Constant absolute growth ($X per period) → Linear Trend
- Constant percentage growth (X% per period) → Exponential Trend
- Growth approaching limit → Logistic Trend
- Complex pattern → Custom Trend or multiple models

**Step 3: How much history do you have?**
- < 2 full cycles → Use simple growth rates
- 2-3 cycles → Linear or exponential trend
- 3+ cycles → Full decomposition with seasonality

**Step 4: What's your forecast horizon?**
- Short-term (1-3 periods) → Any model works
- Medium-term (4-8 periods) → Trend models with seasonality
- Long-term (9+ periods) → Be cautious, validate assumptions

### Model Selection Guidelines

**Linear Trend:**
```swift
// Use when: Adding constant absolute amount each period
// Examples: Headcount growth, facility expansion
// Caution: Unrealistic for long-term (no limits)
```

**Exponential Trend:**
```swift
// Use when: Growing by constant percentage
// Examples: Revenue, user base, compound metrics
// Caution: Can explode unrealistically (no limits)
```

**Logistic Trend:**
```swift
// Use when: Growth has natural limit
// Examples: Market share, user adoption, saturation
// Caution: Requires good capacity estimate
```

**Seasonal + Trend:**
```swift
// Use when: Data has recurring patterns
// Examples: Retail sales, subscription metrics
// Caution: Requires 2+ full cycles of history
```

## Best Practices

### Validate Assumptions

```swift
// Check if exponential growth is reasonable
let currentRevenue = 1_000_000.0
let growthRate = 0.50  // 50% per year
let projection10y = currentRevenue * pow(1.50, 10)
// Result: $57.7M

// Is this realistic for your market?
// What would market share be?
// Are there capacity constraints?
```

### Use Multiple Scenarios

```swift
// Conservative scenario (5% growth)
let conservativeForecast = applyGrowth(baseValue: 1_000_000, rate: 0.05, periods: 5, compounding: .annual)

// Base case scenario (10% growth)
let baseForecast = applyGrowth(baseValue: 1_000_000, rate: 0.10, periods: 5, compounding: .annual)

// Optimistic scenario (15% growth)
let optimisticForecast = applyGrowth(baseValue: 1_000_000, rate: 0.15, periods: 5, compounding: .annual)

// Present all three with probabilities
```

### Backtest Your Models

```swift
// Split historical data
let allData = TimeSeries(periods: allPeriods, values: allValues)
let trainEnd = allPeriods[allPeriods.count - 4]  // Hold out last 4 periods

let trainData = allData.range(from: allPeriods[0], to: trainEnd)
let testData = allData.range(from: trainEnd + 1, to: allPeriods.last!)

// Fit on training data
var model = LinearTrend<Double>()
try model.fit(to: trainData)

// Predict test period
let predictions = try model.project(periods: 4)

// Compare to actual
// If predictions way off, model may not work for future either
```

### Update Regularly

```swift
// Don't set and forget!
// Update forecasts monthly/quarterly with latest data

let newData = TimeSeries(periods: newPeriods, values: newValues)

// Refit model
var updatedModel = LinearTrend<Double>()
try updatedModel.fit(to: newData)

// Generate updated forecast
let updatedForecast = try updatedModel.project(periods: forecastHorizon)
```

## See Also

- <doc:1.1-GettingStarted>
- <doc:1.2-TimeSeries>
- <doc:3.3-BuildingRevenueModel>
- ``TrendModel``
- ``LinearTrend``
- ``ExponentialTrend``
- ``LogisticTrend``
- ``seasonalIndices(timeSeries:periodsPerYear:)``
- ``decomposeTimeSeries(timeSeries:periodsPerYear:method:)``
