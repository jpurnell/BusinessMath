# Financial Statements API Reference

Complete API documentation for the role-based financial statement system including all enumerations, properties, and methods.

## Overview

This document provides comprehensive API reference for BusinessMath's financial statement system. For a tutorial-style introduction with step-by-step examples, see <doc:3.5-FinancialStatementsGuide>.

BusinessMath v2.0 provides a **role-based financial statement system** that accurately models real-world accounting where accounts can appear in multiple financial statements with different roles.

### Key Features

- ✅ **Multi-Role Support**: Accounts can have roles in multiple statements (Income Statement, Balance Sheet, Cash Flow Statement)
- ✅ **Flexible Design**: Single `accounts:` parameter for statement construction with automatic categorization
- ✅ **Type-Safe**: Full Swift generics support (`Account<T: Numeric & Comparable>`)
- ✅ **Validated**: Entity and period consistency checks across all accounts
- ✅ **Materialized Views**: Pre-compute aggregated metrics for performance

### Architecture

```
Entity (Company/Division)
   ↓
Account<T> (with one or more roles)
   ↓
Statement (Income Statement, Balance Sheet, or Cash Flow Statement)
   ↓
Materialized Statement (pre-computed aggregations)
```

---

## Core Concepts

### 1. Entity

Represents a company, division, or business unit:

```swift
public struct Entity: Hashable, Codable {
    public let id: String
    public let primaryType: EntityIdentifierType
    public let name: String
}

// Example
let entity = Entity(
    id: "AAPL",
    primaryType: .ticker,
    name: "Apple Inc."
)
```

**Entity Identifier Types:**
- `.ticker` - Stock ticker symbol (e.g., "AAPL")
- `.cusip` - 9-character CUSIP identifier
- `.isin` - International Securities Identification Number
- `.sedol` - Stock Exchange Daily Official List identifier
- `.internal` - Internal company ID

### 2. Period

Represents a fiscal time period:

```swift
public enum Period: Hashable, Codable {
    case quarter(year: Int, quarter: Int)
    case annual(year: Int)
    case monthly(year: Int, month: Int)
    case custom(start: Date, end: Date)
}

// Examples
let q1_2024 = Period.quarter(year: 2024, quarter: 1)
let fy2024 = Period.annual(year: 2024)
let jan2024 = Period.monthly(year: 2024, month: 1)
```

### 3. TimeSeries

Generic time series data structure:

```swift
public struct TimeSeries<T: Numeric & Comparable>: Codable {
    public let periods: [Period]
    public let values: [T]
}

// Example
let revenueSeries = TimeSeries(
    periods: [
        Period.quarter(year: 2024, quarter: 1),
        Period.quarter(year: 2024, quarter: 2),
        Period.quarter(year: 2024, quarter: 3),
        Period.quarter(year: 2024, quarter: 4)
    ],
    values: [100_000.0, 110_000.0, 120_000.0, 130_000.0]
)
```

---

## Account API

### Creating Accounts

Accounts require:
1. An `Entity` (which company/division)
2. A `name` (non-empty, non-whitespace)
3. **At least one role** (`incomeStatementRole`, `balanceSheetRole`, or `cashFlowRole`)
4. A `TimeSeries` (non-empty)

### Single-Role Accounts

#### Revenue Account (Income Statement)

```swift
let productRevenue = try Account(
    entity: entity,
    name: "Product Revenue",
    incomeStatementRole: .productRevenue,
    timeSeries: revenueSeries
)
```

**Available Income Statement Roles:**
- **Revenue**: `.revenue`, `.productRevenue`, `.subscriptionRevenue`, `.serviceRevenue`, `.licensingRevenue`, `.otherRevenue`
- **Cost of Revenue**: `.costOfRevenue`, `.costOfGoodsSold`, `.costOfServices`
- **Operating Expenses**: `.researchDevelopment`, `.salesMarketing`, `.generalAdministrative`, `.operatingExpenses`
- **Non-Cash Charges**: `.depreciationAmortization`, `.stockBasedCompensation`, `.impairmentCharges`
- **Other Items**: `.interestExpense`, `.interestIncome`, `.taxExpense`, `.otherIncome`

#### Asset Account (Balance Sheet)

```swift
let cash = try Account(
    entity: entity,
    name: "Cash and Cash Equivalents",
    balanceSheetRole: .cashAndEquivalents,
    timeSeries: cashSeries
)
```

**Available Balance Sheet Roles:**

**Current Assets:**
- `.cashAndEquivalents`, `.shortTermInvestments`, `.accountsReceivable`, `.inventory`, `.prepaidExpenses`, `.otherCurrentAssets`

**Non-Current Assets:**
- `.propertyPlantEquipment`, `.accumulatedDepreciation`, `.intangibleAssets`, `.goodwill`, `.longTermInvestments`, `.otherNonCurrentAssets`

**Current Liabilities:**
- `.accountsPayable`, `.accruedExpenses`, `.deferredRevenue`, `.shortTermDebt`, `.currentPortionLongTermDebt`, `.otherCurrentLiabilities`

**Non-Current Liabilities:**
- `.longTermDebt`, `.deferredTaxLiabilities`, `.pensionLiabilities`, `.otherNonCurrentLiabilities`

**Equity:**
- `.commonStock`, `.preferredStock`, `.additionalPaidInCapital`, `.retainedEarnings`, `.treasuryStock`, `.accumulatedOCI`

#### Cash Flow Account

```swift
let capex = try Account(
    entity: entity,
    name: "Capital Expenditures",
    cashFlowRole: .capitalExpenditures,
    timeSeries: capexSeries
)
```

**Available Cash Flow Roles:**

**Operating Activities:**
- `.netIncome`, `.depreciationAmortizationAddback`, `.stockBasedCompensationAddback`, `.deferredTaxes`, `.changeInReceivables`, `.changeInInventory`, `.changeInPayables`, `.changeInDeferredRevenue`, `.otherOperatingActivities`

**Investing Activities:**
- `.capitalExpenditures`, `.proceedsFromAssetSales`, `.acquisitions`, `.purchasesOfInvestments`, `.salesOfInvestments`, `.otherInvestingActivities`

**Financing Activities:**
- `.proceedsFromDebt`, `.repaymentOfDebt`, `.proceedsFromEquity`, `.shareRepurchases`, `.dividendsPaid`, `.otherFinancingActivities`

### Multi-Role Accounts

Accounts can have **multiple roles** across different statements:

```swift
// Depreciation appears in BOTH Income Statement and Cash Flow Statement
let depreciation = try Account(
    entity: entity,
    name: "Depreciation & Amortization",
    incomeStatementRole: .depreciationAmortization,    // IS: Expense
    cashFlowRole: .depreciationAmortizationAddback,     // CFS: Add-back
    timeSeries: depreciationSeries
)

// Inventory appears in BOTH Balance Sheet and Cash Flow Statement
let inventory = try Account(
    entity: entity,
    name: "Inventory",
    balanceSheetRole: .inventory,          // BS: Current Asset
    cashFlowRole: .changeInInventory,      // CFS: Working Capital Change
    timeSeries: inventorySeries
)
```

### Account Properties

```swift
public struct Account<T: Numeric & Comparable>: Codable {
    public let entity: Entity
    public let name: String
    public let incomeStatementRole: IncomeStatementRole?
    public let balanceSheetRole: BalanceSheetRole?
    public let cashFlowRole: CashFlowRole?
    public let timeSeries: TimeSeries<T>
}
```

### Account Validation

Accounts validate on creation:

```swift
// ❌ Throws: AccountError.emptyTimeSeries
let invalid1 = try Account(
    entity: entity,
    name: "Revenue",
    incomeStatementRole: .revenue,
    timeSeries: TimeSeries(periods: [], values: [])
)

// ❌ Throws: AccountError.invalidName
let invalid2 = try Account(
    entity: entity,
    name: "",  // Empty name
    incomeStatementRole: .revenue,
    timeSeries: series
)

// ❌ Throws: FinancialModelError.accountMustHaveAtLeastOneRole
let invalid3 = try Account(
    entity: entity,
    name: "No Role Account",
    timeSeries: series  // No role specified
)
```

---

## Income Statement

### Creating an Income Statement

```swift
let incomeStatement = try IncomeStatement(
    entity: entity,
    periods: periods,
    accounts: [
        productRevenue,
        serviceRevenue,
        costOfGoodsSold,
        researchDevelopment,
        salesMarketing,
        generalAdmin,
        depreciationExpense,
        interestExpense,
        taxExpense
    ]
)
```

The statement **automatically categorizes** accounts based on their `incomeStatementRole`:
- Revenue accounts → `revenueAccounts`
- Expense accounts → `expenseAccounts`

### Accessing Categorized Accounts

```swift
// Revenue accounts (where incomeStatementRole?.isRevenue == true)
let revenues = incomeStatement.revenueAccounts
// → [productRevenue, serviceRevenue]

// Expense accounts (where incomeStatementRole?.isExpense == true)
let expenses = incomeStatement.expenseAccounts
// → [costOfGoodsSold, researchDevelopment, ...]
```

### Computed Metrics

```swift
// Total Revenue (sum of all revenue accounts)
let totalRevenue = incomeStatement.totalRevenue
// → TimeSeries<T>

// Total Expenses (sum of all expense accounts)
let totalExpenses = incomeStatement.totalExpenses
// → TimeSeries<T>

// Net Income (totalRevenue - totalExpenses)
let netIncome = incomeStatement.netIncome
// → TimeSeries<T>

// Gross Profit (revenue - cost of revenue)
let grossProfit = incomeStatement.grossProfit
// → TimeSeries<T>

// Operating Income (gross profit - operating expenses)
let operatingIncome = incomeStatement.operatingIncome
// → TimeSeries<T>

// EBITDA (earnings before interest, taxes, depreciation, amortization)
let ebitda = incomeStatement.ebitda
// → TimeSeries<T>

// EBIT (earnings before interest and taxes)
let ebit = incomeStatement.ebit
// → TimeSeries<T>
```

### Accessing Values by Period

```swift
let q1 = Period.quarter(year: 2024, quarter: 1)

let q1Revenue = totalRevenue[q1]  // → 100,000.0
let q1NetIncome = netIncome[q1]   // → 25,000.0
```

### Materialization

Pre-compute all aggregated metrics:

```swift
let materialized = incomeStatement.materialize()

// All metrics are now stored values (not computed properties)
let totalRevenue = materialized.totalRevenue
let netIncome = materialized.netIncome
let ebitda = materialized.ebitda
```

### Income Statement Categories

Accounts are automatically grouped by category:

```swift
// Revenue categories
let productRevenues = incomeStatement.revenueAccounts.filter {
    $0.incomeStatementRole == .productRevenue
}

// Cost of revenue (COGS, COS)
let costOfRevenue = incomeStatement.expenseAccounts.filter {
    $0.incomeStatementRole?.isCostOfRevenue == true
}

// Operating expenses (R&D, S&M, G&A)
let opex = incomeStatement.expenseAccounts.filter {
    $0.incomeStatementRole?.isOperatingExpense == true
}

// Non-cash charges (D&A, SBC, impairments)
let nonCash = incomeStatement.expenseAccounts.filter {
    $0.incomeStatementRole?.isNonCashCharge == true
}
```

---

## Balance Sheet

### Creating a Balance Sheet

```swift
let balanceSheet = try BalanceSheet(
    entity: entity,
    periods: periods,
    accounts: [
        // Assets
        cash,
        accountsReceivable,
        inventory,
        ppe,
        // Liabilities
        accountsPayable,
        longTermDebt,
        // Equity
        commonStock,
        retainedEarnings
    ]
)
```

The statement **automatically categorizes** accounts based on their `balanceSheetRole`:
- Assets → `assetAccounts`
- Liabilities → `liabilityAccounts`
- Equity → `equityAccounts`

### Accessing Categorized Accounts

```swift
// Asset accounts
let assets = balanceSheet.assetAccounts
// → [cash, accountsReceivable, inventory, ppe]

// Liability accounts
let liabilities = balanceSheet.liabilityAccounts
// → [accountsPayable, longTermDebt]

// Equity accounts
let equity = balanceSheet.equityAccounts
// → [commonStock, retainedEarnings]
```

### Computed Metrics

```swift
// Total Assets (sum of all asset accounts)
let totalAssets = balanceSheet.totalAssets
// → TimeSeries<T>

// Total Liabilities (sum of all liability accounts)
let totalLiabilities = balanceSheet.totalLiabilities
// → TimeSeries<T>

// Total Equity (sum of all equity accounts)
let totalEquity = balanceSheet.totalEquity
// → TimeSeries<T>

// Current Assets (sum of current asset accounts)
let currentAssets = balanceSheet.currentAssets
// → TimeSeries<T>

// Current Liabilities (sum of current liability accounts)
let currentLiabilities = balanceSheet.currentLiabilities
// → TimeSeries<T>

// Working Capital (current assets - current liabilities)
let workingCapital = balanceSheet.workingCapital
// → TimeSeries<T>
```

### Balance Sheet Validation

The balance sheet equation is **NOT automatically enforced** to allow partial balance sheets:

```swift
// This is VALID (partial balance sheet)
let partialBS = try BalanceSheet(
    entity: entity,
    periods: periods,
    accounts: [cash, accountsReceivable]  // Only assets
)
```

To validate the accounting equation (Assets = Liabilities + Equity):

```swift
func isBalanced(balanceSheet: BalanceSheet<Double>) -> Bool {
    let periods = balanceSheet.periods

    for period in periods {
        let assets = balanceSheet.totalAssets[period] ?? 0
        let liabilities = balanceSheet.totalLiabilities[period] ?? 0
        let equity = balanceSheet.totalEquity[period] ?? 0

        let difference = abs(assets - (liabilities + equity))
        if difference > 0.01 {  // Tolerance for floating-point errors
            return false
        }
    }

    return true
}
```

### Balance Sheet Categories

```swift
// Current Assets (cash, AR, inventory, prepaid)
let currentAssets = balanceSheet.assetAccounts.filter {
    $0.balanceSheetRole?.isCurrentAsset == true
}

// Non-Current Assets (PPE, intangibles, goodwill)
let nonCurrentAssets = balanceSheet.assetAccounts.filter {
    $0.balanceSheetRole?.isNonCurrentAsset == true
}

// Current Liabilities (AP, accrued expenses, short-term debt)
let currentLiabilities = balanceSheet.liabilityAccounts.filter {
    $0.balanceSheetRole?.isCurrentLiability == true
}

// Non-Current Liabilities (long-term debt, deferred taxes)
let nonCurrentLiabilities = balanceSheet.liabilityAccounts.filter {
    $0.balanceSheetRole?.isNonCurrentLiability == true
}
```

---

## Cash Flow Statement

### Creating a Cash Flow Statement

```swift
let cashFlowStatement = try CashFlowStatement(
    entity: entity,
    periods: periods,
    accounts: [
        // Operating
        netIncome,
        depreciationAddback,
        stockCompAddback,
        changeInReceivables,
        changeInInventory,
        changeInPayables,
        // Investing
        capitalExpenditures,
        // Financing
        proceedsFromDebt,
        dividendsPaid
    ]
)
```

The statement **automatically categorizes** accounts based on their `cashFlowRole`:
- Operating activities → `operatingAccounts`
- Investing activities → `investingAccounts`
- Financing activities → `financingAccounts`

### Accessing Categorized Accounts

```swift
// Operating cash flow accounts
let operating = cashFlowStatement.operatingAccounts
// → [netIncome, depreciationAddback, ...]

// Investing cash flow accounts
let investing = cashFlowStatement.investingAccounts
// → [capitalExpenditures]

// Financing cash flow accounts
let financing = cashFlowStatement.financingAccounts
// → [proceedsFromDebt, dividendsPaid]
```

### Computed Metrics

```swift
// Operating Cash Flow (sum of all operating accounts)
let operatingCF = cashFlowStatement.operatingCashFlow
// → TimeSeries<T>

// Investing Cash Flow (sum of all investing accounts)
let investingCF = cashFlowStatement.investingCashFlow
// → TimeSeries<T>

// Financing Cash Flow (sum of all financing accounts)
let financingCF = cashFlowStatement.financingCashFlow
// → TimeSeries<T>

// Net Cash Flow (sum of all three categories)
let netCF = cashFlowStatement.netCashFlow
// → TimeSeries<T>

// Free Cash Flow (operating CF + investing CF)
let freeCF = cashFlowStatement.freeCashFlow
// → TimeSeries<T>
```

### Working Capital Changes

The cash flow role enum has a property `usesChangeInBalance` to indicate working capital accounts:

```swift
public enum CashFlowRole {
    // ...
    case changeInReceivables  // usesChangeInBalance = true
    case changeInInventory    // usesChangeInBalance = true
    case changeInPayables     // usesChangeInBalance = true

    public var usesChangeInBalance: Bool {
        switch self {
        case .changeInReceivables,
             .changeInInventory,
             .changeInPayables,
             .changeInDeferredRevenue:
            return true
        default:
            return false
        }
    }
}
```

---

## Multi-Role Accounts

### Common Multi-Role Patterns

#### 1. Depreciation & Amortization

Appears as an **expense in Income Statement** and an **add-back in Cash Flow Statement**:

```swift
let depreciation = try Account(
    entity: entity,
    name: "Depreciation & Amortization",
    incomeStatementRole: .depreciationAmortization,
    cashFlowRole: .depreciationAmortizationAddback,
    timeSeries: depreciationSeries
)

// Use in BOTH statements
let incomeStmt = try IncomeStatement(..., accounts: [revenue, depreciation])
let cashFlowStmt = try CashFlowStatement(..., accounts: [netIncome, depreciation])
```

#### 2. Stock-Based Compensation

Similar pattern to depreciation:

```swift
let stockComp = try Account(
    entity: entity,
    name: "Stock-Based Compensation",
    incomeStatementRole: .stockBasedCompensation,
    cashFlowRole: .stockBasedCompensationAddback,
    timeSeries: stockCompSeries
)
```

#### 3. Working Capital Accounts

Appear in **Balance Sheet as assets/liabilities** and **Cash Flow Statement as changes**:

```swift
let inventory = try Account(
    entity: entity,
    name: "Inventory",
    balanceSheetRole: .inventory,
    cashFlowRole: .changeInInventory,
    timeSeries: inventorySeries
)

let accountsReceivable = try Account(
    entity: entity,
    name: "Accounts Receivable",
    balanceSheetRole: .accountsReceivable,
    cashFlowRole: .changeInReceivables,
    timeSeries: arSeries
)

let accountsPayable = try Account(
    entity: entity,
    name: "Accounts Payable",
    balanceSheetRole: .accountsPayable,
    cashFlowRole: .changeInPayables,
    timeSeries: apSeries
)
```

#### 4. Hypothetical Three-Role Account

While rare, accounts can have all three roles:

```swift
let complexAccount = try Account(
    entity: entity,
    name: "Complex Account",
    incomeStatementRole: .interestExpense,
    balanceSheetRole: .longTermDebt,
    cashFlowRole: .repaymentOfDebt,
    timeSeries: series
)
```

---

## Complete Example

### Building a Three-Statement Model

```swift
import BusinessMath

// 1. Define entity and periods
let entity = Entity(
    id: "EXAMPLE",
    primaryType: .internal,
    name: "Example Corp"
)

let periods = [
    Period.quarter(year: 2024, quarter: 1),
    Period.quarter(year: 2024, quarter: 2),
    Period.quarter(year: 2024, quarter: 3),
    Period.quarter(year: 2024, quarter: 4)
]

// 2. Create revenue accounts
let productRevenue = try Account(
    entity: entity,
    name: "Product Revenue",
    incomeStatementRole: .productRevenue,
    timeSeries: TimeSeries(
        periods: periods,
        values: [100_000.0, 110_000.0, 120_000.0, 130_000.0]
    )
)

let serviceRevenue = try Account(
    entity: entity,
    name: "Service Revenue",
    incomeStatementRole: .serviceRevenue,
    timeSeries: TimeSeries(
        periods: periods,
        values: [20_000.0, 22_000.0, 24_000.0, 26_000.0]
    )
)

// 3. Create expense accounts
let cogs = try Account(
    entity: entity,
    name: "Cost of Goods Sold",
    incomeStatementRole: .costOfGoodsSold,
    timeSeries: TimeSeries(
        periods: periods,
        values: [40_000.0, 42_000.0, 44_000.0, 46_000.0]
    )
)

let rnd = try Account(
    entity: entity,
    name: "Research & Development",
    incomeStatementRole: .researchDevelopment,
    timeSeries: TimeSeries(
        periods: periods,
        values: [15_000.0, 16_000.0, 17_000.0, 18_000.0]
    )
)

// 4. Create multi-role account (IS + CFS)
let depreciation = try Account(
    entity: entity,
    name: "Depreciation & Amortization",
    incomeStatementRole: .depreciationAmortization,
    cashFlowRole: .depreciationAmortizationAddback,
    timeSeries: TimeSeries(
        periods: periods,
        values: [5_000.0, 5_000.0, 5_000.0, 5_000.0]
    )
)

// 5. Create balance sheet accounts
let cash = try Account(
    entity: entity,
    name: "Cash and Cash Equivalents",
    balanceSheetRole: .cashAndEquivalents,
    timeSeries: TimeSeries(
        periods: periods,
        values: [50_000.0, 60_000.0, 75_000.0, 90_000.0]
    )
)

// 6. Create working capital accounts (BS + CFS)
let accountsReceivable = try Account(
    entity: entity,
    name: "Accounts Receivable",
    balanceSheetRole: .accountsReceivable,
    cashFlowRole: .changeInReceivables,
    timeSeries: TimeSeries(
        periods: periods,
        values: [30_000.0, 35_000.0, 40_000.0, 45_000.0]
    )
)

let inventory = try Account(
    entity: entity,
    name: "Inventory",
    balanceSheetRole: .inventory,
    cashFlowRole: .changeInInventory,
    timeSeries: TimeSeries(
        periods: periods,
        values: [20_000.0, 22_000.0, 24_000.0, 26_000.0]
    )
)

// 7. Create liability and equity accounts
let longTermDebt = try Account(
    entity: entity,
    name: "Long-Term Debt",
    balanceSheetRole: .longTermDebt,
    timeSeries: TimeSeries(
        periods: periods,
        values: [100_000.0, 95_000.0, 90_000.0, 85_000.0]
    )
)

let commonStock = try Account(
    entity: entity,
    name: "Common Stock",
    balanceSheetRole: .commonStock,
    timeSeries: TimeSeries(
        periods: periods,
        values: [50_000.0, 50_000.0, 50_000.0, 50_000.0]
    )
)

// 8. Build Income Statement
let incomeStatement = try IncomeStatement(
    entity: entity,
    periods: periods,
    accounts: [
        productRevenue,
        serviceRevenue,
        cogs,
        rnd,
        depreciation  // Multi-role account
    ]
)

// 9. Build Balance Sheet
let balanceSheet = try BalanceSheet(
    entity: entity,
    periods: periods,
    accounts: [
        cash,
        accountsReceivable,  // Multi-role account
        inventory,           // Multi-role account
        longTermDebt,
        commonStock
    ]
)

// 10. Build Cash Flow Statement
// First, create net income account from IS
let netIncome = try Account(
    entity: entity,
    name: "Net Income",
    cashFlowRole: .netIncome,
    timeSeries: incomeStatement.netIncome
)

let cashFlowStatement = try CashFlowStatement(
    entity: entity,
    periods: periods,
    accounts: [
        netIncome,
        depreciation,           // Multi-role account (IS + CFS)
        accountsReceivable,     // Multi-role account (BS + CFS)
        inventory               // Multi-role account (BS + CFS)
    ]
)

// 11. Analyze the model
let q1 = Period.quarter(year: 2024, quarter: 1)

print("Q1 2024 Summary:")
print("  Revenue: \(incomeStatement.totalRevenue[q1]?.currency() ?? "N/A")")
print("  Net Income: \(incomeStatement.netIncome[q1]?.currency() ?? "N/A")")
print("  Total Assets: \(balanceSheet.totalAssets[q1]?.currency() ?? "N/A")")
print("  Operating CF: \(cashFlowStatement.operatingCashFlow[q1]?.currency() ?? "N/A")")
print("  Free CF: \(cashFlowStatement.freeCashFlow[q1]?.currency() ?? "N/A")")
```

---

## API Reference

### Account API

```swift
// Initializer
public init(
    entity: Entity,
    name: String,
    incomeStatementRole: IncomeStatementRole? = nil,
    balanceSheetRole: BalanceSheetRole? = nil,
    cashFlowRole: CashFlowRole? = nil,
    timeSeries: TimeSeries<T>
) throws

// Errors
public enum AccountError: Error {
    case invalidName
    case emptyTimeSeries
}

public enum FinancialModelError: Error {
    case accountMustHaveAtLeastOneRole
    case entityMismatch(expected: String, found: String, accountName: String)
    case periodMismatch(expected: [Period], found: [Period], accountName: String)
}
```

### Income Statement API

```swift
// Initializer
public init(
    entity: Entity,
    periods: [Period],
    accounts: [Account<T>]
) throws

// Properties
public let entity: Entity
public let periods: [Period]
public let accounts: [Account<T>]

// Computed Properties
public var revenueAccounts: [Account<T>]
public var expenseAccounts: [Account<T>]
public var totalRevenue: TimeSeries<T>
public var totalExpenses: TimeSeries<T>
public var netIncome: TimeSeries<T>
public var grossProfit: TimeSeries<T>
public var operatingIncome: TimeSeries<T>
public var ebitda: TimeSeries<T>
public var ebit: TimeSeries<T>

// Methods
public func materialize() -> MaterializedIncomeStatement<T>
```

### Balance Sheet API

```swift
// Initializer
public init(
    entity: Entity,
    periods: [Period],
    accounts: [Account<T>]
) throws

// Properties
public let entity: Entity
public let periods: [Period]
public let accounts: [Account<T>]

// Computed Properties
public var assetAccounts: [Account<T>]
public var liabilityAccounts: [Account<T>]
public var equityAccounts: [Account<T>]
public var totalAssets: TimeSeries<T>
public var totalLiabilities: TimeSeries<T>
public var totalEquity: TimeSeries<T>
public var currentAssets: TimeSeries<T>
public var currentLiabilities: TimeSeries<T>
public var workingCapital: TimeSeries<T>

// Methods
public func materialize() -> MaterializedBalanceSheet<T>
```

### Cash Flow Statement API

```swift
// Initializer
public init(
    entity: Entity,
    periods: [Period],
    accounts: [Account<T>]
) throws

// Properties
public let entity: Entity
public let periods: [Period]
public let accounts: [Account<T>]

// Computed Properties
public var operatingAccounts: [Account<T>]
public var investingAccounts: [Account<T>]
public var financingAccounts: [Account<T>]
public var operatingCashFlow: TimeSeries<T>
public var investingCashFlow: TimeSeries<T>
public var financingCashFlow: TimeSeries<T>
public var netCashFlow: TimeSeries<T>
public var freeCashFlow: TimeSeries<T>

// Methods
public func materialize() -> MaterializedCashFlowStatement<T>
```

---

## Best Practices

### 1. Use Materialized Statements for Performance

If you're accessing aggregated metrics multiple times, materialize the statement:

```swift
// ❌ Slow (recomputes every time)
for period in periods {
    let revenue = incomeStatement.totalRevenue[period]
    let expenses = incomeStatement.totalExpenses[period]
    let netIncome = incomeStatement.netIncome[period]
}

// ✅ Fast (computed once)
let materialized = incomeStatement.materialize()
for period in periods {
    let revenue = materialized.totalRevenue[period]
    let expenses = materialized.totalExpenses[period]
    let netIncome = materialized.netIncome[period]
}
```

### 2. Validate Entity Consistency

All accounts in a statement must belong to the same entity:

```swift
// ❌ Will throw FinancialModelError.entityMismatch
let stmt = try IncomeStatement(
    entity: entityA,
    periods: periods,
    accounts: [accountForEntityA, accountForEntityB]  // Different entities!
)
```

### 3. Validate Period Consistency

All accounts must have time series data for the same periods:

```swift
// ❌ Will throw FinancialModelError.periodMismatch
let account1 = try Account(
    entity: entity,
    name: "Revenue",
    incomeStatementRole: .revenue,
    timeSeries: TimeSeries(periods: [q1, q2, q3], values: [100, 110, 120])
)

let account2 = try Account(
    entity: entity,
    name: "Expenses",
    incomeStatementRole: .operatingExpenses,
    timeSeries: TimeSeries(periods: [q1, q2], values: [50, 55])  // Missing q3!
)

let stmt = try IncomeStatement(
    entity: entity,
    periods: [q1, q2, q3],
    accounts: [account1, account2]  // Period mismatch!
)
```

### 4. Use Role-Specific Properties

Role enums have helper properties for filtering:

```swift
// Income Statement roles
if account.incomeStatementRole?.isRevenue == true { ... }
if account.incomeStatementRole?.isCostOfRevenue == true { ... }
if account.incomeStatementRole?.isOperatingExpense == true { ... }
if account.incomeStatementRole?.isNonCashCharge == true { ... }

// Balance Sheet roles
if account.balanceSheetRole?.isAsset == true { ... }
if account.balanceSheetRole?.isCurrentAsset == true { ... }
if account.balanceSheetRole?.isLiability == true { ... }
if account.balanceSheetRole?.isEquity == true { ... }

// Cash Flow roles
if account.cashFlowRole?.isOperating == true { ... }
if account.cashFlowRole?.isInvesting == true { ... }
if account.cashFlowRole?.isFinancing == true { ... }
if account.cashFlowRole?.usesChangeInBalance == true { ... }
```

### 5. Name Accounts Clearly

Use descriptive names that match financial reporting standards:

```swift
// ✅ Good
let revenue = try Account(
    entity: entity,
    name: "Product Revenue - North America",
    incomeStatementRole: .productRevenue,
    timeSeries: series
)

// ❌ Avoid
let account1 = try Account(
    entity: entity,
    name: "Rev1",
    incomeStatementRole: .productRevenue,
    timeSeries: series
)
```

### 6. Handle Missing Data Gracefully

TimeSeries subscript returns optional values:

```swift
let q1Revenue = incomeStatement.totalRevenue[q1]

// ✅ Safe
if let revenue = q1Revenue {
    print("Q1 Revenue: \(revenue.currency())")
} else {
    print("Q1 Revenue: No data")
}

// ✅ Also safe (with default)
let revenue = q1Revenue ?? 0.0
```

### 7. Use Proper Numeric Types

Choose the appropriate numeric type for your use case:

```swift
// For financial amounts (most common)
let account = try Account<Double>( ... )

// For integer-only data (e.g., unit counts)
let unitAccount = try Account<Int>( ... )

// For high-precision calculations
import Foundation
let preciseAccount = try Account<Decimal>( ... )
```

---

## See Also

### Related Guides
- <doc:3.5-FinancialStatementsGuide> - Tutorial-style guide with step-by-step examples
- <doc:3.15-DataIngestionGuide> - Loading financial data from JSON and CSV
- <doc:3.4-BuildingFinancialReports> - Integrated financial modeling workflows
- <doc:4.2-ScenarioAnalysisGuide> - Modeling different business outcomes

### Additional Resources
- [MIGRATION_GUIDE_v2.0.md](../../../MIGRATION_GUIDE_v2.0.md) - Migration guide from v1.x to v2.0
- [FINANCIAL_STATEMENT_MIGRATION.md](../../../Instruction%20Set/FINANCIAL_STATEMENT_MIGRATION.md) - Technical implementation details
