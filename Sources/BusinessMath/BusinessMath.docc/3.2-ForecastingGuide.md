# Time Series Forecasting

Predict future values using statistical forecasting methods with BusinessMath.

## Overview

Forecasting is essential for business planning. BusinessMath provides battle-tested forecasting algorithms that help you predict future sales, demand, costs, and other business metrics.

This guide covers:
- Holt-Winters triple exponential smoothing for seasonal data
- Moving average forecasts for trend identification
- Anomaly detection for unusual patterns
- Confidence intervals for forecast uncertainty

## Holt-Winters Forecasting

Holt-Winters is one of the most widely used forecasting methods. It handles three components: level, trend, and seasonality.

### Monthly Sales Forecast

```swift
import BusinessMath

// Historical monthly sales (2 years)
let months = (1...24).map { Period.month(year: 2023 + ($0 - 1) / 12, month: (($0 - 1) % 12) + 1) }
let sales: [Double] = [
	// Year 1
	100, 110, 95, 105, 115, 125, 140, 135, 120, 110, 130, 150,
	// Year 2
	105, 115, 100, 110, 120, 130, 145, 140, 125, 115, 135, 155
]

let salesTimeSeries = TimeSeries(
	periods: months,
	values: sales,
	metadata: TimeSeriesMetadata(name: "Monthly Sales", unit: "Units")
)

// Create Holt-Winters model
let model = HoltWintersModel(
	alpha: 0.2,  // Level smoothing
	beta: 0.1,   // Trend smoothing
	gamma: 0.1,  // Seasonal smoothing
	seasonalPeriods: 12  // Monthly data with annual seasonality
)

// Generate forecast
let forecast = try model.forecast(
	timeSeries: salesTimeSeries,
	periods: 6  // Predict next 6 months
)

print("6-month forecast:")
for (period, value) in zip(forecast.periods, forecast.valuesArray) {
	print("\(period.label): \(value.number(0)) units")
}
```

### Revenue Forecast with Confidence Intervals

```swift
// Forecast with uncertainty bounds
let revenueTimeSeries = TimeSeries(
	periods: months,
	values: sales.map { $0 * 299.99 },  // $299.99 per unit
	metadata: TimeSeriesMetadata(name: "Revenue", unit: "USD")
)

let revenueForecast = try model.forecastWithConfidence(
	timeSeries: revenueTimeSeries,
	periods: 12,
	confidenceLevel: 0.95
)

print("\n12-month revenue forecast:")
for i in 0..<12 {
	let period = revenueForecast.forecast.periods[i]
	let forecast = revenueForecast.forecast.valuesArray[i]
	let lower = revenueForecast.lowerBound.valuesArray[i]
	let upper = revenueForecast.upperBound.valuesArray[i]

	print("\(period.label):")
	print("  Forecast: \(forecast.currency(0))")
	print("  95% CI: [\(lower.currency(0)), \(upper.currency(0))]")
}
```

## Moving Average Forecasts

Moving averages smooth out short-term fluctuations to reveal underlying trends.

### Simple Moving Average

```swift
// 3-month moving average for trend identification
let sma = salesTimeSeries.movingAverage(window: 3)

print("Last 6 months - Actual vs Trend:")
for i in (sales.count - 8)..<(sales.count - 2) {
	print("\(months[i].label): Actual \(sales[i]), Trend \(sma.valuesArray[i].number(0))")
}
```

### Weighted Moving Average

```swift
// Weight recent months more heavily
let weights = [0.5, 0.3, 0.2]  // Most recent = 50%, then 30%, then 20%

func weightedForecast(history: [Double], weights: [Double]) -> Double {
    let recent = Array(history.suffix(weights.count))
    return zip(recent.reversed(), weights).map(*).reduce(0, +)
}

let nextMonthForecast = weightedForecast(history: sales, weights: weights)
print("Next month forecast (weighted): \(Int(nextMonthForecast)) units")
```

## Anomaly Detection

Identify unusual values that don't fit the pattern.

### Statistical Anomaly Detection

```swift
// Use z-score method with rolling window
// windowSize must be less than data.count (use ~50% of data length)
let anomalyDetector = ZScoreAnomalyDetector<Double>(windowSize: 12)

// Detect anomalies with threshold of 3.0 standard deviations
let anomalies = anomalyDetector.detect(in: salesTimeSeries, threshold: 3.0)

if !anomalies.isEmpty {
    print("Anomalies detected:")
    for anomaly in anomalies {
        print("\(anomaly.period.label): \(anomaly.value) (expected: \(anomaly.expectedValue.number(0)))")
        print("  Deviation: \(anomaly.deviationScore.number(1)) standard deviations - \(anomaly.severity)")
    }
} else {
    print("No anomalies detected - data follows expected pattern")
}
```

**Key Parameters:**

- **windowSize**: Number of prior periods to use for baseline statistics
  - Should be less than total data length
  - Typical: 12 for monthly data (1 year), 20 for daily data (1 month)
  - Larger window = more stable baseline, but less sensitive to recent shifts

- **threshold**: How many standard deviations constitute an anomaly
  - 2.0 = more sensitive (catches smaller deviations)
  - 3.0 = standard (typical outlier detection)
  - 4.0+ = very conservative (only extreme outliers)

**Severity Classification:**
- Mild: 2-3 standard deviations
- Moderate: 3-4 standard deviations
- Severe: >4 standard deviations

### Business Rule Anomalies

```swift
// Flag months where sales dropped >20% from prior month
func detectDrops(sales: [Double], threshold: Double = 0.20) -> [(month: Int, drop: Double)] {
    var drops: [(Int, Double)] = []

    for i in 1..<sales.count {
        let change = (sales[i] - sales[i-1]) / sales[i-1]
        if change < -threshold {
            drops.append((i, change))
        }
    }

    return drops
}

let significantDrops = detectDrops(sales: sales)
if !significantDrops.isEmpty {
    print("\nSignificant sales drops:")
    for (month, drop) in significantDrops {
        print("\(months[month].label): \(Int(drop * 100))% decrease")
    }
}
```

## Forecast Accuracy

Measure how good your forecasts are.

### Train/Test Split Validation

**Important**: HoltWinters requires at least `2 * seasonalPeriods` data points to train. With monthly data (`seasonalPeriods: 12`), you need ≥24 points. For validation with smaller datasets, use LinearTrend or ExponentialTrend instead.

```swift
// Hold out last 6 months for validation
let trainData = Array(sales.prefix(18))
let testData = Array(sales.suffix(6))

let trainPeriods = Array(months.prefix(18))
let trainTimeSeries = TimeSeries(periods: trainPeriods, values: trainData)

let testPeriods = Array(months.suffix(6))
let testTimeSeries = TimeSeries(periods: testPeriods, values: testData)

// Use LinearTrend for validation (works with any dataset size)
var validationModel = LinearTrend<Double>()
try validationModel.fit(to: trainTimeSeries)
let validationForecast = try validationModel.project(periods: 6)

// Use built-in forecast error metrics
let forecastError = testTimeSeries.forecastError(against: validationForecast)
print("Forecast Accuracy:")
print(forecastError.summary)

if forecastError.mape < 10 {
    print("✓ Excellent forecast accuracy (MAPE < 10%)")
} else if forecastError.mape < 20 {
    print("✓ Good forecast accuracy (MAPE < 20%)")
} else {
    print("⚠ Consider adjusting model parameters or collecting more data")
}
```

The `ForecastError` struct provides multiple accuracy metrics:
- **MAPE**: Mean Absolute Percentage Error (scale-independent, 0-100%)
- **MAE**: Mean Absolute Error (average magnitude of errors)
- **RMSE**: Root Mean Squared Error (penalizes large errors more)
- **summary**: Formatted string with all metrics

## Tuning Forecast Parameters

### Grid Search for Optimal Parameters

**Note**: This example requires ≥24 data points for HoltWinters with `seasonalPeriods: 12`. For smaller datasets, use LinearTrend or ExponentialTrend instead.

```swift
let extendedSales: [Double] = [
	// Year 1
	100, 110, 95, 105, 115, 125, 140, 135, 120, 110, 130, 150,
	// Year 2
	105, 115, 100, 110, 120, 130, 145, 140, 125, 115, 135, 155,
	// Year 3
	110, 120, 105, 115, 125, 135, 150, 145, 130, 120, 140, 160,
	// Year 4
	120, 125, 110, 120, 130, 140, 145, 140, 135, 125, 145, 165
]
	// Assume we have more data - at least 30 points for 24 train + 6 test
	 let allData = Array(extendedSales.prefix(48))
	 let extendedTrainData = Array(allData.prefix(36))
	 let extendedTestData = Array(allData.suffix(12))
let extendedMonths = (1...48).map { Period.month(year: 2023 + ($0 - 1) / 12, month: (($0 - 1) % 12) + 1) }


let extendedTrainPeriods = Array(extendedMonths.prefix(36))
let extendedTrainTimeSeries = TimeSeries(periods: extendedTrainPeriods, values: extendedTrainData)

let extendedTestPeriods = Array(extendedMonths.suffix(12))
let extendedTestTimeSeries = TimeSeries(periods: extendedTestPeriods, values: extendedTestData)
	// Try different parameter combinations
	let alphaValues = [0.1, 0.2, 0.3]
	let betaValues = [0.05, 0.1, 0.15]
	let gammaValues = [0.05, 0.1, 0.15]

	var bestMAPE = Double.infinity
	var bestParams = (alpha: 0.2, beta: 0.1, gamma: 0.1)

	for alpha in alphaValues {
		for beta in betaValues {
			for gamma in gammaValues {
				let testModel = HoltWintersModel(
					alpha: alpha,
					beta: beta,
					gamma: gamma,
					seasonalPeriods: 12
				)

				// This requires trainTimeSeries to have ≥24 points
				let testForecast = try testModel.forecast(
					timeSeries: extendedTrainTimeSeries,
					periods: 6
				)

				let forecastError = extendedTestTimeSeries.forecastError(against: testForecast)

				if forecastError.mape < bestMAPE {
					bestMAPE = forecastError.mape
					bestParams = (alpha, beta, gamma)
				}
			}
		}
	}

	print("Best parameters: α=\(bestParams.alpha), β=\(bestParams.beta), γ=\(bestParams.gamma)")
	print("Best MAPE: \(bestMAPE.percent(2))")
```

## Practical Tips

### Choosing Forecast Horizons

- **Short-term (1-3 periods)**: Most accurate, use for operational planning
- **Medium-term (4-12 periods)**: Good for tactical planning, budget forecasts
- **Long-term (>12 periods)**: Least accurate, use with wide confidence intervals

### Seasonal Periods

Common seasonal patterns:
```swift
let dailyWithWeekly = HoltWintersModel(..., seasonalPeriods: 7)      // Weekly pattern
let weeklyWithMonthly = HoltWintersModel(..., seasonalPeriods: 4)    // Monthly pattern
let monthlyWithAnnual = HoltWintersModel(..., seasonalPeriods: 12)   // Annual pattern
let quarterlyWithAnnual = HoltWintersModel(..., seasonalPeriods: 4)  // Annual pattern
```

### When to Retrain

Update forecasts when:
1. New data becomes available (monthly/quarterly)
2. Business conditions change significantly
3. Forecast errors exceed acceptable thresholds
4. Seasonality patterns shift

### Choosing Models Based on Confidence Interval Needs

All major forecast models now support confidence intervals as a first-class API feature:

| Model Type | Confidence Intervals | Use When |
|------------|---------------------|----------|
| **HoltWintersModel** | ✅ Built-in via `predictWithConfidence()` | Need uncertainty quantification + seasonality |
| **MovingAverageModel** | ✅ Built-in via `predictWithConfidence()` | Need uncertainty quantification + simple trends |
| **LinearTrend** | ✅ Built-in via `projectWithConfidence()` | Simple trend forecasts with uncertainty |
| **ExponentialTrend** | ✅ Built-in via `projectWithConfidence()` | Growth forecasts with uncertainty |
| **LogisticTrend** | ✅ Built-in via `projectWithConfidence()` | Saturation forecasts with uncertainty |

**When confidence intervals matter:**
- Presenting forecasts to stakeholders who need uncertainty ranges
- Risk-sensitive planning (inventory, capacity, financing)
- Budget planning with conservative/optimistic scenarios
- Comparing forecast reliability across models

**When you can skip confidence intervals:**
- Internal rough projections
- Deterministic scenario modeling
- When you'll run Monte Carlo simulations instead

**Using Confidence Intervals with TrendModels:**

All trend models now support confidence intervals through `projectWithConfidence()`:

```swift
// LinearTrend with confidence intervals
var linear = LinearTrend<Double>()
try linear.fit(to: historical)
let linearCI = try linear.projectWithConfidence(
    periods: 12,
    confidenceLevel: 0.95
)

// ExponentialTrend with confidence intervals
var exponential = ExponentialTrend<Double>()
try exponential.fit(to: historical)
let expCI = try exponential.projectWithConfidence(
    periods: 12,
    confidenceLevel: 0.95
)

// LogisticTrend with confidence intervals
var logistic = LogisticTrend<Double>(capacity: 1000)
try logistic.fit(to: historical)
let logCI = try logistic.projectWithConfidence(
    periods: 12,
    confidenceLevel: 0.95
)

// All return ForecastWithConfidence with forecast, lowerBound, and upperBound
print("Forecast: \(linearCI.forecast.valuesArray[0])")
print("95% CI: [\(linearCI.lowerBound.valuesArray[0]), \(linearCI.upperBound.valuesArray[0])]")
```

## Next Steps

- Learn <doc:4.2-ScenarioAnalysisGuide> to model multiple forecast scenarios
- Explore <doc:5.1-OptimizationGuide> to optimize forecast parameters
- See <doc:2.3-RiskAnalyticsGuide> for forecast uncertainty analysis

## See Also

- ``HoltWintersModel``
- ``ZScoreAnomalyDetector``
- ``Anomaly``
- ``ForecastWithConfidence``
- ``TimeSeries/movingAverage(window:)``
- ``TimeSeries/growthRate(lag:)``
