# Building Financial Statements

Learn how to model complete financial statements using the role-based architecture for Income Statement, Balance Sheet, and Cash Flow Statement.

## Overview

BusinessMath v2.0 provides a **role-based financial statement framework** that accurately models real-world accounting. Accounts can have roles in multiple statements, allowing you to build accurate three-statement models.

> **What's New in v2.0:** The role-based architecture replaces the legacy type-based system. Accounts now explicitly declare their roles across financial statements, supporting multi-statement appearances (e.g., Depreciation in both IS and CFS).

## Understanding Financial Statements

Financial statements are the primary way businesses report their financial performance and position. BusinessMath models three core statements:

- **Income Statement**: Revenue, expenses, and profitability over a period
- **Balance Sheet**: Assets, liabilities, and equity at a point in time
- **Cash Flow Statement**: Cash inflows and outflows over a period

## Creating an Entity

Every financial model starts with an entity (company):

```swift
import BusinessMath

// Define the company
let acme = Entity(
    id: "ACME",
    primaryType: .ticker,
    name: "Acme Corporation"
)
```

## Building an Income Statement

The Income Statement shows profitability over time. In v2.0, accounts explicitly declare their `incomeStatementRole`:

```swift
// Define the periods we're modeling
let q1 = Period.quarter(year: 2025, quarter: 1)
let q2 = Period.quarter(year: 2025, quarter: 2)
let q3 = Period.quarter(year: 2025, quarter: 3)
let q4 = Period.quarter(year: 2025, quarter: 4)
let periods = [q1, q2, q3, q4]

// Product Revenue
let revenue = try Account(
    entity: acme,
    name: "Product Revenue",
    incomeStatementRole: .productRevenue,  // Role-based API
    timeSeries: TimeSeries(
        periods: periods,
        values: [1_000_000, 1_100_000, 1_200_000, 1_300_000]
    )
)

// Cost of Goods Sold
let cogs = try Account(
    entity: acme,
    name: "Cost of Goods Sold",
    incomeStatementRole: .costOfGoodsSold,  // Specific role
    timeSeries: TimeSeries(
        periods: periods,
        values: [400_000, 440_000, 480_000, 520_000]
    )
)

// Operating Expenses
let salary = try Account(
    entity: acme,
    name: "Salaries",
    incomeStatementRole: .generalAdministrative,
    timeSeries: TimeSeries(
        periods: periods,
        values: [200_000, 200_000, 200_000, 200_000]
    )
)

let marketing = try Account(
    entity: acme,
    name: "Marketing",
    incomeStatementRole: .salesMarketing,
    timeSeries: TimeSeries(
        periods: periods,
        values: [50_000, 60_000, 70_000, 80_000]
    )
)

let interestExpense = try Account(
    entity: acme,
    name: "Interest Expense",
    incomeStatementRole: .interestExpense,
    timeSeries: TimeSeries(
        periods: periods,
        values: [10_000, 10_000, 10_000, 10_000]
    )
)

let incomeTax = try Account(
    entity: acme,
    name: "Income Tax",
    incomeStatementRole: .taxExpense,
    timeSeries: TimeSeries(
        periods: periods,
        values: [60_000, 69_000, 78_000, 87_000]
    )
)

// Create the Income Statement with single accounts: parameter
let incomeStatement = try IncomeStatement(
    entity: acme,
    periods: periods,
    accounts: [revenue, cogs, salary, marketing, interestExpense, incomeTax]
)

// The statement automatically categorizes by role:
print("Revenue Accounts: \(incomeStatement.revenueAccounts.count)")  // 1
print("Expense Accounts: \(incomeStatement.expenseAccounts.count)")  // 5

// Access computed values
print("\nQ1 Revenue:          \(incomeStatement.totalRevenue[q1]!.currency())")
print("Q1 Gross Profit:     \(incomeStatement.grossProfit[q1]!.currency())")
print("Q1 Operating Income: \(incomeStatement.operatingIncome[q1]!.currency())")
print("Q1 Net Income:       \(incomeStatement.netIncome[q1]!.currency())")

// Calculate margins
if let revenue = incomeStatement.totalRevenue[q1],
   let grossProfit = incomeStatement.grossProfit[q1],
   let netIncome = incomeStatement.netIncome[q1] {
    print("Q1 Gross Margin: \((grossProfit / revenue * 100).number())%")
    print("Q1 Net Margin:   \((netIncome / revenue * 100).number())%")
}
```

## Building a Balance Sheet

The Balance Sheet shows financial position at a point in time. Accounts use `balanceSheetRole`:

```swift
// Assets
let cash = try Account(
    entity: acme,
    name: "Cash and Equivalents",
    balanceSheetRole: .cashAndEquivalents,  // Role-based API
    timeSeries: TimeSeries(
        periods: periods,
        values: [500_000, 600_000, 750_000, 900_000]
    )
)

let receivables = try Account(
    entity: acme,
    name: "Accounts Receivable",
    balanceSheetRole: .accountsReceivable,
    timeSeries: TimeSeries(
        periods: periods,
        values: [300_000, 330_000, 360_000, 390_000]
    )
)

let ppe = try Account(
    entity: acme,
    name: "Property, Plant & Equipment",
    balanceSheetRole: .propertyPlantEquipment,
    timeSeries: TimeSeries(
        periods: periods,
        values: [1_000_000, 980_000, 960_000, 940_000]
    )
)

// Liabilities
let payables = try Account(
    entity: acme,
    name: "Accounts Payable",
    balanceSheetRole: .accountsPayable,
    timeSeries: TimeSeries(
        periods: periods,
        values: [150_000, 165_000, 180_000, 195_000]
    )
)

let longTermDebt = try Account(
    entity: acme,
    name: "Long-term Debt",
    balanceSheetRole: .longTermDebt,
    timeSeries: TimeSeries(
        periods: periods,
        values: [500_000, 500_000, 500_000, 500_000]
    )
)

// Equity
let commonStock = try Account(
    entity: acme,
    name: "Common Stock",
    balanceSheetRole: .commonStock,
    timeSeries: TimeSeries(
        periods: periods,
        values: [1_000_000, 1_000_000, 1_000_000, 1_000_000]
    )
)

let retainedEarnings = try Account(
    entity: acme,
    name: "Retained Earnings",
    balanceSheetRole: .retainedEarnings,
    timeSeries: TimeSeries(
        periods: periods,
        values: [150_000, 245_000, 390_000, 535_000]
    )
)

// Create the Balance Sheet with single accounts: parameter
let balanceSheet = try BalanceSheet(
    entity: acme,
    periods: periods,
    accounts: [cash, receivables, ppe, payables, longTermDebt, commonStock, retainedEarnings]
)

// The statement automatically categorizes by role:
print("Asset Accounts:     \(balanceSheet.assetAccounts.count)")       // 3
print("Liability Accounts: \(balanceSheet.liabilityAccounts.count)")   // 2
print("Equity Accounts:    \(balanceSheet.equityAccounts.count)")      // 2

// Access computed values
print("Q1 Total Assets:      \(balanceSheet.totalAssets[q1]!.currency())")
print("Q1 Total Liabilities: \(balanceSheet.totalLiabilities[q1]!.currency())")
print("Q1 Total Equity:      \(balanceSheet.totalEquity[q1]!.currency())")

// Verify balance sheet equation: Assets = Liabilities + Equity
let assets = balanceSheet.totalAssets[q1]!
let liabilities = balanceSheet.totalLiabilities[q1]!
let equity = balanceSheet.totalEquity[q1]!
print("Balance Check: \(abs(assets - (liabilities + equity)) < 0.01 ? "✓" : "✗")")

// Calculate ratios
if let currentAssets = balanceSheet.currentAssets[q1],
   let currentLiabilities = balanceSheet.currentLiabilities[q1] {
    print("Q1 Current Ratio: \((currentAssets / currentLiabilities).number())")
}
```

## Building a Cash Flow Statement

The Cash Flow Statement tracks cash movements. Accounts use `cashFlowRole`:

```swift
// Operating Activities - Net Income (from Income Statement)
let netIncomeAccount = try Account(
    entity: acme,
    name: "Net Income",
    cashFlowRole: .netIncome,
    timeSeries: incomeStatement.netIncome
)

// Investing Activities
let capex = try Account(
    entity: acme,
    name: "Capital Expenditures",
    cashFlowRole: .capitalExpenditures,
    timeSeries: TimeSeries(
        periods: periods,
        values: [-50_000, -30_000, -40_000, -60_000]
    )
)

// Financing Activities
let debtProceeds = try Account(
    entity: acme,
    name: "Debt Proceeds",
    cashFlowRole: .proceedsFromDebt,
    timeSeries: TimeSeries(
        periods: periods,
        values: [0, 0, 0, 0]
    )
)

let dividends = try Account(
    entity: acme,
    name: "Dividends Paid",
    cashFlowRole: .dividendsPaid,
    timeSeries: TimeSeries(
        periods: periods,
        values: [-30_000, -35_000, -40_000, -45_000]
    )
)

// Create the Cash Flow Statement with single accounts: parameter
let cashFlowStatement = try CashFlowStatement(
    entity: acme,
    periods: periods,
    accounts: [netIncomeAccount, capex, debtProceeds, dividends]
)

// The statement automatically categorizes by role:
print("Operating Accounts: \(cashFlowStatement.operatingAccounts.count)")  // 1
print("Investing Accounts: \(cashFlowStatement.investingAccounts.count)")  // 1
print("Financing Accounts: \(cashFlowStatement.financingAccounts.count)")  // 2

// Access computed values
print("Q1 Operating Cash Flow: \(cashFlowStatement.operatingCashFlow[q1]!.currency())")
print("Q1 Investing Cash Flow: \(cashFlowStatement.investingCashFlow[q1]!.currency())")
print("Q1 Financing Cash Flow: \(cashFlowStatement.financingCashFlow[q1]!.currency())")
print("Q1 Net Cash Flow:       \(cashFlowStatement.netCashFlow[q1]!.currency())")

// Free Cash Flow (Operating - CapEx)
print("Q1 Free Cash Flow: \(cashFlowStatement.freeCashFlow[q1]!.currency())")
```

## Multi-Role Accounts (New in v2.0!)

Accounts can have roles in **multiple statements**, accurately modeling real-world accounting:

### Depreciation: Income Statement + Cash Flow Statement

```swift
// Depreciation appears in BOTH IS (expense) and CFS (add-back)
let depreciation = try Account(
    entity: acme,
    name: "Depreciation & Amortization",
    incomeStatementRole: .depreciationAmortization,      // IS: Expense
    cashFlowRole: .depreciationAmortizationAddback,      // CFS: Add-back
    timeSeries: TimeSeries(
        periods: periods,
        values: [20_000, 20_000, 20_000, 20_000]
    )
)

// Use in BOTH statements
let incomeStmt = try IncomeStatement(
    entity: acme,
    periods: periods,
    accounts: [revenue, cogs, depreciation]  // Uses incomeStatementRole
)

let cashFlowStmt = try CashFlowStatement(
    entity: acme,
    periods: periods,
    accounts: [netIncomeAccount, depreciation]  // Uses cashFlowRole
)
```

### Working Capital: Balance Sheet + Cash Flow Statement

```swift
// Inventory appears in BOTH BS (asset) and CFS (working capital change)
let inventory = try Account(
    entity: acme,
    name: "Inventory",
    balanceSheetRole: .inventory,          // BS: Current Asset
    cashFlowRole: .changeInInventory,      // CFS: Working Capital
    timeSeries: TimeSeries(
        periods: periods,
        values: [100_000, 110_000, 120_000, 130_000]
    )
)

// Use in BOTH statements
let balanceSheet = try BalanceSheet(
    entity: acme,
    periods: periods,
    accounts: [cash, inventory]  // Uses balanceSheetRole
)

let cashFlowStmt = try CashFlowStatement(
    entity: acme,
    periods: periods,
    accounts: [netIncomeAccount, inventory]  // Uses cashFlowRole (change in balance)
)
```

## Complete Three-Statement Model

Here's how to build a complete integrated model with multi-role accounts:

```swift
// 1. Create all accounts (some with multiple roles)
let depreciation = try Account(
    entity: acme,
    name: "Depreciation",
    incomeStatementRole: .depreciationAmortization,
    cashFlowRole: .depreciationAmortizationAddback,
    timeSeries: TimeSeries(periods: periods, values: [20_000, 20_000, 20_000, 20_000])
)

let inventory = try Account(
    entity: acme,
    name: "Inventory",
    balanceSheetRole: .inventory,
    cashFlowRole: .changeInInventory,
    timeSeries: TimeSeries(periods: periods, values: [100_000, 110_000, 120_000, 130_000])
)

// 2. Build all three statements using the same accounts array
let allAccounts = [
    revenue, cogs, salary, marketing, depreciation, interestExpense, incomeTax,
    cash, receivables, inventory, ppe,
    payables, longTermDebt,
    commonStock, retainedEarnings
]

let incomeStatement = try IncomeStatement(
    entity: acme,
    periods: periods,
    accounts: allAccounts  // Auto-filters by incomeStatementRole
)

let balanceSheet = try BalanceSheet(
    entity: acme,
    periods: periods,
    accounts: allAccounts  // Auto-filters by balanceSheetRole
)

// For cash flow, add net income account
let netIncomeAccount = try Account(
    entity: acme,
    name: "Net Income",
    cashFlowRole: .netIncome,
    timeSeries: incomeStatement.netIncome
)

let cashFlowStatement = try CashFlowStatement(
    entity: acme,
    periods: periods,
    accounts: allAccounts + [netIncomeAccount, capex, dividends]  // Auto-filters by cashFlowRole
)

// 3. Create a Financial Projection that ties them together
struct CompanyProjection {
    let entity: Entity
    let periods: [Period]
    let incomeStatement: IncomeStatement<Double>
    let balanceSheet: BalanceSheet<Double>
    let cashFlowStatement: CashFlowStatement<Double>

    // Validation: Check that statements are consistent
    func validate() -> Bool {
        for period in periods {
            // Balance sheet must balance
            guard let assets = balanceSheet.totalAssets[period],
                  let liabilities = balanceSheet.totalLiabilities[period],
                  let equity = balanceSheet.totalEquity[period] else {
                return false
            }

            if abs(assets - (liabilities + equity)) > 0.01 {
                return false
            }
        }
        return true
    }

    // Summary report
    func printSummary(for period: Period) {
        print("=== \(entity.name) - Q\(period.quarter ?? 0) \(period.year) ===")

        if let revenue = incomeStatement.totalRevenue[period],
           let netIncome = incomeStatement.netIncome[period] {
            print("\nIncome Statement:")
            print("  Revenue:    \(revenue.currency())")
            print("  Net Income: \(netIncome.currency())")
            print("  Net Margin: \((netIncome / revenue * 100).number())%")
        }

        if let totalAssets = balanceSheet.totalAssets[period],
           let totalEquity = balanceSheet.totalEquity[period],
           let totalLiabilities = balanceSheet.totalLiabilities[period] {
            print("\nBalance Sheet:")
            print("  Total Assets: \(totalAssets.currency())")
            print("  Total Equity: \(totalEquity.currency())")
            print("  Debt-to-Equity: \((totalLiabilities / totalEquity).number())x")
        }

        if let operatingCF = cashFlowStatement.operatingCashFlow[period],
           let freeCF = cashFlowStatement.freeCashFlow[period] {
            print("\nCash Flow:")
            print("  Operating CF:   \(operatingCF.currency())")
            print("  Free Cash Flow: \(freeCF.currency())")
        }
    }
}

let projection = CompanyProjection(
    entity: acme,
    periods: periods,
    incomeStatement: incomeStatement,
    balanceSheet: balanceSheet,
    cashFlowStatement: cashFlowStatement
)

// Validate and print
if projection.validate() {
    print("✓ Financial statements are balanced")
    projection.printSummary(for: q1)
} else {
    print("✗ Financial statements do not balance")
}
```

## Categorizing Accounts by Role

The role enums have helper properties for filtering:

```swift
// Find all current assets
let currentAssets = balanceSheet.assetAccounts.filter {
    $0.balanceSheetRole?.isCurrentAsset == true
}

// Find all operating expenses
let opex = incomeStatement.expenseAccounts.filter {
    $0.incomeStatementRole?.isOperatingExpense == true
}

// Find all non-cash charges
let nonCash = incomeStatement.expenseAccounts.filter {
    $0.incomeStatementRole?.isNonCashCharge == true
}

// Find cash flow accounts that use balance changes
let workingCapital = cashFlowStatement.operatingAccounts.filter {
    $0.cashFlowRole?.usesChangeInBalance == true
}
```

## Next Steps

- Learn about <doc:2.2-FinancialRatiosGuide> for analyzing financial performance
- Explore <doc:4.2-ScenarioAnalysisGuide> for modeling different outcomes
- See <doc:3.3-BuildingRevenueModel> for creating operational drivers
- Read the [Financial Statements API Reference](../../../Documentation/FinancialStatements.md) for complete details

> **Migrating from v1.x?** See [MIGRATION_GUIDE_v2.0.md](../../../MIGRATION_GUIDE_v2.0.md) for step-by-step upgrade instructions.

## Related Topics

- ``Entity``
- ``Account``
- ``IncomeStatement``
- ``BalanceSheet``
- ``CashFlowStatement``
- ``TimeSeries``
- ``Period``
- ``IncomeStatementRole``
- ``BalanceSheetRole``
- ``CashFlowRole``
