# Building Financial Statements

Learn how to model complete financial statements using the role-based architecture for Income Statement, Balance Sheet, and Cash Flow Statement.

## Overview

BusinessMath v2.0 provides a **role-based financial statement framework** that accurately models real-world accounting. Accounts can have roles in multiple statements, allowing you to build accurate three-statement models.

> **What's New in v2.0:** The role-based architecture replaces the legacy type-based system. Accounts now explicitly declare their roles across financial statements, supporting multi-statement appearances (e.g., Depreciation in both IS and CFS).

## Understanding Financial Statements

Financial statements are the primary way businesses report their financial performance and position. BusinessMath models three core statements:

- **Income Statement**: Revenue, expenses, and profitability over a period
- **Balance Sheet**: Assets, liabilities, and equity at a point in time
- **Cash Flow Statement**: Cash inflows and outflows over a period

## Creating an Entity

Every financial model starts with an entity (company):

```swift
import BusinessMath

// Define the company
let acme = Entity(
    id: "ACME",
    primaryType: .ticker,
    name: "Acme Corporation"
)
```

## Building an Income Statement

The Income Statement shows profitability over time. In v2.0, accounts explicitly declare their `incomeStatementRole`:

```swift
// Define the periods we're modeling
let q1 = Period.quarter(year: 2025, quarter: 1)
let q2 = Period.quarter(year: 2025, quarter: 2)
let q3 = Period.quarter(year: 2025, quarter: 3)
let q4 = Period.quarter(year: 2025, quarter: 4)
let periods = [q1, q2, q3, q4]

// Product Revenue
let revenueAccount = try Account(
	entity: acme,
	name: "Product Revenue",
	incomeStatementRole: .productRevenue,  // Role-based API
	timeSeries: TimeSeries(
		periods: periods,
		values: [1_000_000, 1_100_000, 1_200_000, 1_300_000]
	)
)

// Cost of Goods Sold
let cogs = try Account(
	entity: acme,
	name: "Cost of Goods Sold",
	incomeStatementRole: .costOfGoodsSold,  // Specific role
	timeSeries: TimeSeries(
		periods: periods,
		values: [400_000, 440_000, 480_000, 520_000]
	)
)

// Operating Expenses
let salary = try Account(
	entity: acme,
	name: "Salaries",
	incomeStatementRole: .generalAndAdministrative,
	timeSeries: TimeSeries(
		periods: periods,
		values: [200_000, 200_000, 200_000, 200_000]
	)
)

let marketing = try Account(
	entity: acme,
	name: "Marketing",
	incomeStatementRole: .salesAndMarketing,
	timeSeries: TimeSeries(
		periods: periods,
		values: [50_000, 60_000, 70_000, 80_000]
	)
)

let interestExpense = try Account(
	entity: acme,
	name: "Interest Expense",
	incomeStatementRole: .interestExpense,
	timeSeries: TimeSeries(
		periods: periods,
		values: [10_000, 10_000, 10_000, 10_000]
	)
)

let incomeTax = try Account(
	entity: acme,
	name: "Income Tax",
	incomeStatementRole: .incomeTaxExpense,
	timeSeries: TimeSeries(
		periods: periods,
		values: [60_000, 69_000, 78_000, 87_000]
	)
)

// Create the Income Statement with single accounts: parameter
let incomeStatement = try IncomeStatement(
	entity: acme,
	periods: periods,
	accounts: [revenueAccount, cogs, salary, marketing, interestExpense, incomeTax]
)

// The statement automatically categorizes by role:
print("Revenue Accounts: \(incomeStatement.revenueAccounts.count)")  // 1
print("Expense Accounts: \(incomeStatement.expenseAccounts.count)")  // 5

// Access computed values
print("\nQ1 Revenue:          \(incomeStatement.totalRevenue[q1]!.currency(0))")
print("Q1 Gross Profit:     \(incomeStatement.grossProfit[q1]!.currency(0))")
print("Q1 Operating Income: \(incomeStatement.operatingIncome[q1]!.currency(0))")
print("Q1 Net Income:       \(incomeStatement.netIncome[q1]!.currency(0))")

// Calculate margins
if let revenue = incomeStatement.totalRevenue[q1],
   let grossProfit = incomeStatement.grossProfit[q1],
   let netIncome = incomeStatement.netIncome[q1] {
	print("Q1 Gross Margin: \((grossProfit / revenue).percent())")
	print("Q1 Net Margin:   \((netIncome / revenue).percent())%")
}
```

## Building a Balance Sheet

The Balance Sheet shows financial position at a point in time. Accounts use `balanceSheetRole`:

```swift
// Assets
let cash = try Account(
	entity: acme,
	name: "Cash and Equivalents",
	balanceSheetRole: .cashAndEquivalents,  // Role-based API
	timeSeries: TimeSeries(
		periods: periods,
		values: [500_000, 600_000, 750_000, 900_000]
	)
)

let receivables = try Account(
	entity: acme,
	name: "Accounts Receivable",
	balanceSheetRole: .accountsReceivable,
	timeSeries: TimeSeries(
		periods: periods,
		values: [300_000, 330_000, 360_000, 390_000]
	)
)

let ppe = try Account(
	entity: acme,
	name: "Property, Plant & Equipment",
	balanceSheetRole: .propertyPlantEquipment,
	timeSeries: TimeSeries(
		periods: periods,
		values: [1_000_000, 980_000, 960_000, 940_000]
	)
)

// Liabilities
let payables = try Account(
	entity: acme,
	name: "Accounts Payable",
	balanceSheetRole: .accountsPayable,
	timeSeries: TimeSeries(
		periods: periods,
		values: [150_000, 165_000, 180_000, 195_000]
	)
)

let longTermDebt = try Account(
	entity: acme,
	name: "Long-term Debt",
	balanceSheetRole: .longTermDebt,
	timeSeries: TimeSeries(
		periods: periods,
		values: [500_000, 500_000, 500_000, 500_000]
	)
)

// Equity
let commonStock = try Account(
	entity: acme,
	name: "Common Stock",
	balanceSheetRole: .commonStock,
	timeSeries: TimeSeries(
		periods: periods,
		values: [1_000_000, 1_000_000, 1_000_000, 1_000_000]
	)
)

let retainedEarnings = try Account(
	entity: acme,
	name: "Retained Earnings",
	balanceSheetRole: .retainedEarnings,
	timeSeries: TimeSeries(
		periods: periods,
		values: [150_000, 245_000, 390_000, 535_000]
	)
)

// Create the Balance Sheet with single accounts: parameter
let balanceSheet = try BalanceSheet(
	entity: acme,
	periods: periods,
	accounts: [cash, receivables, ppe, payables, longTermDebt, commonStock, retainedEarnings]
)

// The statement automatically categorizes by role:
print("Asset Accounts:     \(balanceSheet.assetAccounts.count)")       // 3
print("Liability Accounts: \(balanceSheet.liabilityAccounts.count)")   // 2
print("Equity Accounts:    \(balanceSheet.equityAccounts.count)")      // 2

// Access computed values
print("Q1 Total Assets:      \(balanceSheet.totalAssets[q1]!.currency(0))")
print("Q1 Total Liabilities: \(balanceSheet.totalLiabilities[q1]!.currency(0))")
print("Q1 Total Equity:      \(balanceSheet.totalEquity[q1]!.currency(0))")

// Verify balance sheet equation: Assets = Liabilities + Equity
let assets = balanceSheet.totalAssets[q1]!
let liabilities = balanceSheet.totalLiabilities[q1]!
let equity = balanceSheet.totalEquity[q1]!
print("Balance Check: \(abs(assets - (liabilities + equity)) < 0.01 ? "✓" : "✗")")

// Calculate ratios
if let currentAssets = balanceSheet.currentAssets[q1],
   let currentLiabilities = balanceSheet.currentLiabilities[q1] {
	print("Q1 Current Ratio: \((currentAssets / currentLiabilities).number(1))")
}
```

## Building a Cash Flow Statement

The Cash Flow Statement tracks cash movements. Accounts use `cashFlowRole`:

```swift
// Operating Activities - Net Income (from Income Statement)
let netIncomeAccount = try Account(
	entity: acme,
	name: "Net Income",
	cashFlowRole: .netIncome,
	timeSeries: incomeStatement.netIncome
)

// Investing Activities
let capex = try Account(
	entity: acme,
	name: "Capital Expenditures",
	cashFlowRole: .capitalExpenditures,
	timeSeries: TimeSeries(
		periods: periods,
		values: [-50_000, -30_000, -40_000, -60_000]
	)
)

// Financing Activities
let debtProceeds = try Account(
	entity: acme,
	name: "Debt Proceeds",
	cashFlowRole: .proceedsFromDebt,
	timeSeries: TimeSeries(
		periods: periods,
		values: [0, 0, 0, 0]
	)
)

let dividends = try Account(
	entity: acme,
	name: "Dividends Paid",
	cashFlowRole: .dividendsPaid,
	timeSeries: TimeSeries(
		periods: periods,
		values: [-30_000, -35_000, -40_000, -45_000]
	)
)

// Create the Cash Flow Statement with single accounts: parameter
let cashFlowStatement = try CashFlowStatement(
	entity: acme,
	periods: periods,
	accounts: [netIncomeAccount, capex, debtProceeds, dividends]
)

// The statement automatically categorizes by role:
print("Operating Accounts: \(cashFlowStatement.operatingAccounts.count)")  // 1
print("Investing Accounts: \(cashFlowStatement.investingAccounts.count)")  // 1
print("Financing Accounts: \(cashFlowStatement.financingAccounts.count)")  // 2

// Access computed values
print("Q1 Operating Cash Flow: \(cashFlowStatement.operatingCashFlow[q1]!.currency(0))")
print("Q1 Investing Cash Flow: \(cashFlowStatement.investingCashFlow[q1]!.currency(0))")
print("Q1 Financing Cash Flow: \(cashFlowStatement.financingCashFlow[q1]!.currency(0))")
print("Q1 Net Cash Flow:       \(cashFlowStatement.netCashFlow[q1]!.currency(0))")

// Free Cash Flow (Operating - CapEx)
print("Q1 Free Cash Flow: \(cashFlowStatement.freeCashFlow[q1]!.currency(0))")
```

## Multi-Role Accounts (New in v2.0!)

Accounts can have roles in **multiple statements**, accurately modeling real-world accounting:

### Depreciation: Income Statement + Cash Flow Statement

```swift
// Depreciation appears in BOTH IS (expense) and CFS (add-back)
let depreciation = try Account(
    entity: acme,
    name: "Depreciation & Amortization",
    incomeStatementRole: .depreciationAmortization,      // IS: Expense
    cashFlowRole: .depreciationAmortizationAddback,      // CFS: Add-back
    timeSeries: TimeSeries(
        periods: periods,
        values: [20_000, 20_000, 20_000, 20_000]
    )
)

// Use in BOTH statements
let incomeStmt = try IncomeStatement(
    entity: acme,
    periods: periods,
    accounts: [revenue, cogs, depreciation]  // Uses incomeStatementRole
)

let cashFlowStmt = try CashFlowStatement(
    entity: acme,
    periods: periods,
    accounts: [netIncomeAccount, depreciation]  // Uses cashFlowRole
)
```

### Working Capital: Balance Sheet + Cash Flow Statement

```swift
// Inventory appears in BOTH BS (asset) and CFS (working capital change)
let inventory = try Account(
    entity: acme,
    name: "Inventory",
    balanceSheetRole: .inventory,          // BS: Current Asset
    cashFlowRole: .changeInInventory,      // CFS: Working Capital
    timeSeries: TimeSeries(
        periods: periods,
        values: [100_000, 110_000, 120_000, 130_000]
    )
)

// Use in BOTH statements
let balanceSheet = try BalanceSheet(
    entity: acme,
    periods: periods,
    accounts: [cash, inventory]  // Uses balanceSheetRole
)

let cashFlowStmt = try CashFlowStatement(
    entity: acme,
    periods: periods,
    accounts: [netIncomeAccount, inventory]  // Uses cashFlowRole (change in balance)
)
```

## Complete Three-Statement Model

Here's how to build a complete integrated model with multi-role accounts:

```swift
// 1. Create all accounts (some with multiple roles)
let depreciation = try Account(
    entity: acme,
    name: "Depreciation",
    incomeStatementRole: .depreciationAmortization,
    cashFlowRole: .depreciationAmortizationAddback,
    timeSeries: TimeSeries(periods: periods, values: [20_000, 20_000, 20_000, 20_000])
)

let inventory = try Account(
    entity: acme,
    name: "Inventory",
    balanceSheetRole: .inventory,
    cashFlowRole: .changeInInventory,
    timeSeries: TimeSeries(periods: periods, values: [100_000, 110_000, 120_000, 130_000])
)

// 2. Build all three statements using the same accounts array
let allAccounts = [
    revenue, cogs, salary, marketing, depreciation, interestExpense, incomeTax,
    cash, receivables, inventory, ppe,
    payables, longTermDebt,
    commonStock, retainedEarnings
]

let incomeStatement = try IncomeStatement(
    entity: acme,
    periods: periods,
    accounts: allAccounts  // Auto-filters by incomeStatementRole
)

let balanceSheet = try BalanceSheet(
    entity: acme,
    periods: periods,
    accounts: allAccounts  // Auto-filters by balanceSheetRole
)

// For cash flow, add net income account
let netIncomeAccount = try Account(
    entity: acme,
    name: "Net Income",
    cashFlowRole: .netIncome,
    timeSeries: incomeStatement.netIncome
)

let cashFlowStatement = try CashFlowStatement(
    entity: acme,
    periods: periods,
    accounts: allAccounts + [netIncomeAccount, capex, dividends]  // Auto-filters by cashFlowRole
)

// 3. Create a Financial Projection that ties them together
struct CompanyProjection {
    let entity: Entity
    let periods: [Period]
    let incomeStatement: IncomeStatement<Double>
    let balanceSheet: BalanceSheet<Double>
    let cashFlowStatement: CashFlowStatement<Double>

    // Validation: Check that statements are consistent
    func validate() -> Bool {
        for period in periods {
            // Balance sheet must balance
            guard let assets = balanceSheet.totalAssets[period],
                  let liabilities = balanceSheet.totalLiabilities[period],
                  let equity = balanceSheet.totalEquity[period] else {
                return false
            }

            if abs(assets - (liabilities + equity)) > 0.01 {
                return false
            }
        }
        return true
    }

    // Summary report
    func printSummary(for period: Period) {
        print("=== \(entity.name) - Q\(period.quarter ?? 0) \(period.year) ===")

        if let revenue = incomeStatement.totalRevenue[period],
           let netIncome = incomeStatement.netIncome[period] {
            print("\nIncome Statement:")
            print("  Revenue:    \(revenue.currency())")
            print("  Net Income: \(netIncome.currency())")
            print("  Net Margin: \((netIncome / revenue * 100).number())%")
        }

        if let totalAssets = balanceSheet.totalAssets[period],
           let totalEquity = balanceSheet.totalEquity[period],
           let totalLiabilities = balanceSheet.totalLiabilities[period] {
            print("\nBalance Sheet:")
            print("  Total Assets: \(totalAssets.currency())")
            print("  Total Equity: \(totalEquity.currency())")
            print("  Debt-to-Equity: \((totalLiabilities / totalEquity).number())x")
        }

        if let operatingCF = cashFlowStatement.operatingCashFlow[period],
           let freeCF = cashFlowStatement.freeCashFlow[period] {
            print("\nCash Flow:")
            print("  Operating CF:   \(operatingCF.currency())")
            print("  Free Cash Flow: \(freeCF.currency())")
        }
    }
}

let projection = CompanyProjection(
    entity: acme,
    periods: periods,
    incomeStatement: incomeStatement,
    balanceSheet: balanceSheet,
    cashFlowStatement: cashFlowStatement
)

// Validate and print
if projection.validate() {
    print("✓ Financial statements are balanced")
    projection.printSummary(for: q1)
} else {
    print("✗ Financial statements do not balance")
}
```

## Categorizing Accounts by Role

The role enums have helper properties for filtering:

```swift
// Find all current assets
let currentAssets = balanceSheet.assetAccounts.filter {
    $0.balanceSheetRole?.isCurrentAsset == true
}

// Find all operating expenses
let opex = incomeStatement.expenseAccounts.filter {
    $0.incomeStatementRole?.isOperatingExpense == true
}

// Find all non-cash charges
let nonCash = incomeStatement.expenseAccounts.filter {
    $0.incomeStatementRole?.isNonCashCharge == true
}

// Find cash flow accounts that use balance changes
let workingCapital = cashFlowStatement.operatingAccounts.filter {
    $0.cashFlowRole?.usesChangeInBalance == true
}
```

## Integration with Scenario Analysis

Financial statements integrate seamlessly with the Scenario Builder API through ``ScenarioRunner``. This allows you to model different business outcomes and compare results.

### Using ScenarioRunner

The ``ScenarioRunner`` executes scenarios by sampling drivers and building financial statements:

```swift
import BusinessMath

// 1. Define a scenario with driver overrides
var overrides: [String: AnyDriver<Double>] = [:]

// Probabilistic revenue driver
overrides["Revenue"] = AnyDriver(
	ProbabilisticDriver(
		name: "Revenue",
		distribution: DistributionNormal(1000000, 100000)
	)
)

// Deterministic growth rate
overrides["Growth"] = AnyDriver(
	DeterministicDriver(name: "Growth", value: 0.10)
)

// Margins with uncertainty
overrides["COGS Ratio"] = AnyDriver(
	ProbabilisticDriver(
		name: "COGS Ratio",
		distribution: DistributionNormal(0.40, 0.02)
	)
)

let scenario = FinancialScenario(
	name: "Base Case",
	description: "Expected scenario with market uncertainty",
	driverOverrides: overrides,
	assumptions: [
		"Market Growth": "Historical average with normal volatility",
		"Margins": "Based on past 3 years"
	]
)

// 2. Run the scenario
let runner = ScenarioRunner()
let baseProjection = try runner.run(
	scenario: scenario,
	entity: acme,
	periods: periods
) { drivers, periods in
	// 3. Sample drivers for each period
	let revenueValues = periods.map { period in
		let baseRevenue = drivers["Revenue"]!.sample(for: period)
		let growth = drivers["Growth"]!.sample(for: period)
		return baseRevenue * pow(1 + growth, Double(periods.firstIndex(of: period) ?? 0))
	}

	let cogsRatios = periods.map { drivers["COGS Ratio"]!.sample(for: $0) }
	let cogsValues = zip(revenueValues, cogsRatios).map { $0 * $1 }

	// 4. Build accounts with sampled values
	let revenue = try Account(
		entity: acme,
		name: "Revenue",
		incomeStatementRole: .productRevenue,
		timeSeries: TimeSeries(periods: periods, values: revenueValues)
	)

	let cogs = try Account(
		entity: acme,
		name: "Cost of Goods Sold",
		incomeStatementRole: .costOfGoodsSold,
		timeSeries: TimeSeries(periods: periods, values: cogsValues)
	)

	// Add operating expenses, assets, liabilities...
	let salary = try Account(
		entity: acme,
		name: "Salaries",
		incomeStatementRole: .generalAndAdministrative,
		timeSeries: TimeSeries(periods: periods, values: [200_000, 200_000, 200_000, 200_000])
	)

	// 5. Build financial statements
	let incomeStatement = try IncomeStatement(
		entity: acme,
		periods: periods,
		accounts: [revenue, cogs, salary]
	)

	let balanceSheet = try BalanceSheet(
		entity: acme,
		periods: periods,
		accounts: [cash, receivables, ppe, payables, longTermDebt, commonStock, retainedEarnings]
	)

	let cashFlowStatement = try CashFlowStatement(
		entity: acme,
		periods: periods,
		accounts: [netIncomeAccount, capex, dividends]
	)

	// 6. Return all three statements
	return (incomeStatement, balanceSheet, cashFlowStatement)
}

// 7. Access the results
print("=== \(baseProjection.scenarioName) ===")
print("Q1 Net Income: \(baseProjection.incomeStatement.netIncome[q1]!.currency())")
print("Q1 Total Assets: \(baseProjection.balanceSheet.totalAssets[q1]!.currency())")
print("Q1 Free Cash Flow: \(baseProjection.cashFlowStatement.freeCashFlow[q1]!.currency())")
```

### Comparing Multiple Scenarios

Run multiple scenarios to analyze outcomes:

```swift
// Base Case
let baseProjection = try runner.run(scenario: baseCase, entity: acme, periods: periods) { ... }

// Optimistic Case - Higher revenue, lower costs
var optimisticOverrides: [String: AnyDriver<Double>] = [:]
optimisticOverrides["Revenue"] = AnyDriver(
	DeterministicDriver(name: "Revenue", value: 1_200_000)
)

// Deterministic growth rate
optimisticOverrides["Growth"] = AnyDriver(
	DeterministicDriver(name: "Growth", value: 0.10)
)

optimisticOverrides["COGS Ratio"] = AnyDriver(
	DeterministicDriver(name: "COGS Ratio", value: 0.35)
)

let optimistic = FinancialScenario(
	name: "Optimistic",
	description: "Strong market conditions",
	driverOverrides: optimisticOverrides
)

let optimisticProjection = try runner.run(scenario: optimistic, entity: acme, periods: periods) { drivers, periods in
	// 3. Sample drivers for each period
	let revenueValues = periods.map { period in
		let baseRevenue = drivers["Revenue"]?.sample(for: period) ?? 0.0
		let growth = drivers["Growth"]?.sample(for: period) ?? 0.0
		return baseRevenue * pow(1 + growth, Double(periods.firstIndex(of: period) ?? 0))
	}

	let cogsRatios = periods.map { drivers["COGS Ratio"]!.sample(for: $0) }
	let cogsValues = zip(revenueValues, cogsRatios).map { $0 * $1 }

	// 4. Build accounts with sampled values
	let revenue = try Account(
		entity: acme,
		name: "Revenue",
		incomeStatementRole: .productRevenue,
		timeSeries: TimeSeries(periods: periods, values: revenueValues)
	)

	let cogs = try Account(
		entity: acme,
		name: "Cost of Goods Sold",
		incomeStatementRole: .costOfGoodsSold,
		timeSeries: TimeSeries(periods: periods, values: cogsValues)
	)

	// Add operating expenses, assets, liabilities...
	let salary = try Account(
		entity: acme,
		name: "Salaries",
		incomeStatementRole: .generalAndAdministrative,
		timeSeries: TimeSeries(periods: periods, values: [200_000, 200_000, 200_000, 200_000])
	)

	// 5. Build financial statements
	let incomeStatement = try IncomeStatement(
		entity: acme,
		periods: periods,
		accounts: [revenue, cogs, salary]
	)

	let balanceSheet = try BalanceSheet(
		entity: acme,
		periods: periods,
		accounts: [cash, receivables, ppe, payables, longTermDebt, commonStock, retainedEarnings]
	)

	let cashFlowStatement = try CashFlowStatement(
		entity: acme,
		periods: periods,
		accounts: [netIncomeAccount, capex, dividends]
	)

	// 6. Return all three statements
	return (incomeStatement, balanceSheet, cashFlowStatement)
}

// Pessimistic Case - Lower revenue, higher costs
var pessimisticOverrides: [String: AnyDriver<Double>] = [:]
pessimisticOverrides["Revenue"] = AnyDriver(
	DeterministicDriver(name: "Revenue", value: 800_000)
)
// Deterministic growth rate
pessimisticOverrides["Growth"] = AnyDriver(
	DeterministicDriver(name: "Growth", value: 0.10)
)
pessimisticOverrides["COGS Ratio"] = AnyDriver(
	DeterministicDriver(name: "COGS Ratio", value: 0.45)
)

let pessimistic = FinancialScenario(
	name: "Pessimistic",
	description: "Weak market conditions",
	driverOverrides: pessimisticOverrides
)

let pessimisticProjection = try runner.run(scenario: pessimistic, entity: acme, periods: periods) { drivers, periods in
	// 3. Sample drivers for each period
let revenueValues = periods.map { period in
	let baseRevenue = drivers["Revenue"]!.sample(for: period)
	let growth = drivers["Growth"]!.sample(for: period)
	return baseRevenue * pow(1 + growth, Double(periods.firstIndex(of: period) ?? 0))
}

let cogsRatios = periods.map { drivers["COGS Ratio"]!.sample(for: $0) }
let cogsValues = zip(revenueValues, cogsRatios).map { $0 * $1 }

	// 4. Build accounts with sampled values
let revenue = try Account(
	entity: acme,
	name: "Revenue",
	incomeStatementRole: .productRevenue,
	timeSeries: TimeSeries(periods: periods, values: revenueValues)
)

let cogs = try Account(
	entity: acme,
	name: "Cost of Goods Sold",
	incomeStatementRole: .costOfGoodsSold,
	timeSeries: TimeSeries(periods: periods, values: cogsValues)
)

	// Add operating expenses, assets, liabilities...
let salary = try Account(
	entity: acme,
	name: "Salaries",
	incomeStatementRole: .generalAndAdministrative,
	timeSeries: TimeSeries(periods: periods, values: [200_000, 200_000, 200_000, 200_000])
)

	// 5. Build financial statements
let incomeStatement = try IncomeStatement(
	entity: acme,
	periods: periods,
	accounts: [revenue, cogs, salary]
)

let balanceSheet = try BalanceSheet(
	entity: acme,
	periods: periods,
	accounts: [cash, receivables, ppe, payables, longTermDebt, commonStock, retainedEarnings]
)

let cashFlowStatement = try CashFlowStatement(
	entity: acme,
	periods: periods,
	accounts: [netIncomeAccount, capex, dividends]
)

	// 6. Return all three statements
return (incomeStatement, balanceSheet, cashFlowStatement)
}

// Compare net income across scenarios
print("\nQ1 Net Income Comparison:")
print("  Base:       \(baseProjection.incomeStatement.netIncome[q1]!.currency())")
print("  Optimistic: \(optimisticProjection.incomeStatement.netIncome[q1]!.currency())")
print("  Pessimistic: \(pessimisticProjection.incomeStatement.netIncome[q1]!.currency())")

// Calculate range
let netIncomes = [
	baseProjection.incomeStatement.netIncome[q1]!,
	optimisticProjection.incomeStatement.netIncome[q1]!,
	pessimisticProjection.incomeStatement.netIncome[q1]!
]
let range = netIncomes.max()! - netIncomes.min()!
print("  Range: \(range.currency())")
```

### Using the DSL-Style ScenarioSet API

For simpler scenarios, use the high-level DSL API:

```swift
let scenarios = ScenarioSet {
    Baseline {
        revenue(1_000_000)
        growth(0.10)
        margin(0.60)
    }
    .withProbability(0.50)

    Pessimistic {
        revenue(800_000)
        growth(0.05)
        margin(0.55)
    }
    .withProbability(0.25)

    Optimistic {
        revenue(1_200_000)
        growth(0.15)
        margin(0.65)
    }
    .withProbability(0.25)
}

// Calculate expected value
let expectedRevenue = scenarios.expectedValue(for: "revenue")
print("Expected Q1 Revenue: \(expectedRevenue.currency())")

// Apply scenario to baseline
let baseValue = 1_000_000.0
let pessimisticValue = scenarios.apply(
    scenarios.scenario(named: "Pessimistic")!,
    to: baseValue,
    for: "revenue"
)
print("Pessimistic Revenue: \(pessimisticValue.currency())")
```

### Error Handling

When working with scenarios and financial statements, handle errors appropriately:

```swift
do {
    let projection = try runner.run(scenario: scenario, entity: acme, periods: periods) { drivers, periods in
        // Build statements
        let incomeStatement = try IncomeStatement(
            entity: entity,
            periods: periods,
            accounts: accounts
        )

        // Validate balance sheet equation
        let balanceSheet = try BalanceSheet(
            entity: entity,
            periods: periods,
            accounts: accounts
        )

        return (incomeStatement, balanceSheet, cashFlowStatement)
    }

    print("✓ Scenario executed successfully")
} catch let error as FinancialModelError {
    print("Financial model error: \(error)")
} catch let error as AccountError {
    print("Account error: \(error)")
} catch {
    print("Unexpected error: \(error)")
}
```

## Next Steps

- Learn about <doc:2.2-FinancialRatiosGuide> for analyzing financial performance
- Explore <doc:4.2-ScenarioAnalysisGuide> for modeling different outcomes
- See <doc:3.3-BuildingRevenueModel> for creating operational drivers
- Read <doc:3.16-FinancialStatementsReference> for complete API details
- See <doc:3.15-DataIngestionGuide> for loading financial data from JSON/CSV

> **Migrating from v1.x?** See [MIGRATION_GUIDE_v2.0.md](../../../MIGRATION_GUIDE_v2.0.md) for step-by-step upgrade instructions.

## Related Topics

### Core Financial Statement Types
- ``Entity``
- ``Account``
- ``IncomeStatement``
- ``BalanceSheet``
- ``CashFlowStatement``
- ``TimeSeries``
- ``Period``

### Role Enumerations
- ``IncomeStatementRole``
- ``BalanceSheetRole``
- ``CashFlowRole``

### Scenario Integration
- ``ScenarioRunner``
- ``FinancialScenario``
- ``FinancialProjection``
- ``ScenarioSet``
- ``ScenarioConfig``

### Error Handling
- ``FinancialModelError``
- ``AccountError``
