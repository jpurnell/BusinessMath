# Monte Carlo Simulation with Time Series

Build probabilistic financial forecasts with uncertainty quantification and confidence intervals.

## Overview

This tutorial demonstrates how to combine Monte Carlo simulation with time series to create robust financial projections that account for uncertainty. You'll learn how to:

- Apply normally distributed growth rates to financial metrics
- Project income statement line items with uncertainty
- Calculate confidence intervals (90%, 95%) for forecasts
- Extract mean, median, and percentile projections
- Combine multiple uncertain drivers (revenue, costs, margins)
- Build complete income statement forecasts with risk analysis

**Time estimate:** 35-45 minutes

## Prerequisites

- Basic understanding of Swift
- Familiarity with probability distributions (normal, triangular)
- Understanding of time series (see <doc:1.2-TimeSeries>)
- Knowledge of income statement structure

## What is Monte Carlo Simulation?

Monte Carlo simulation runs thousands of scenarios, each with different random values drawn from probability distributions. Instead of a single forecast, you get a **range of possible outcomes** with probabilities.

**Example:** Revenue could be anywhere from $80K to $120K next quarter
- **Point estimate**: $100K (traditional forecast)
- **Monte Carlo**: Mean $100K, 90% confidence interval [$85K, $115K]

The second approach is much more informative for decision-making!

## Part 1: Single Metric with Growth Uncertainty

Let's start simple: project revenue with uncertain growth rates.

### Example 1: Revenue Forecast with Compounding Growth

```swift
import BusinessMath

// Historical revenue (starting point)
let baseRevenue = 1_000_000.0  // $1M

// Growth rate uncertainty: mean 10%, std dev 5%
// This models: "We expect 10% growth per quarter, but it could vary ±5%"
let growthDriver = ProbabilisticDriver<Double>.normal(
	name: "Quarterly Growth Rate",
	mean: 0.10,      // Expected 10% growth per quarter
	stdDev: 0.05     // ±5% uncertainty (68% of outcomes within ±1 std dev)
)

// Project over next 4 quarters
let quarters = [
	Period.quarter(year: 2025, quarter: 1),
	Period.quarter(year: 2025, quarter: 2),
	Period.quarter(year: 2025, quarter: 3),
	Period.quarter(year: 2025, quarter: 4)
]

// Key insight: We need to run complete growth paths in each Monte Carlo iteration
// This function generates one complete revenue path with compounding growth
func generateRevenuePath(
	startingRevenue: Double,
	periods: [Period],
	growthDriver: ProbabilisticDriver<Double>
) -> [Double] {
	var revenues: [Double] = []
	var currentRevenue = startingRevenue

	for period in periods {
		// Sample growth rate for this period
		let growth = growthDriver.sample(for: period)
		// Apply compounding: Revenue(t) = Revenue(t-1) × (1 + growth)
		currentRevenue = currentRevenue * (1.0 + growth)
		revenues.append(currentRevenue)
	}

	return revenues
}

// Run Monte Carlo simulation manually to maintain compounding across periods
let iterations = 10_000

// Pre-allocate arrays for better performance
// Store values by period: allValues[periodIndex][iterationIndex]
var allValues: [[Double]] = Array(repeating: [], count: quarters.count)
for i in 0..<quarters.count {
	allValues[i].reserveCapacity(iterations)
}

// Run iterations - this is the fast part
for _ in 0..<iterations {
	var currentRevenue = baseRevenue

	for (periodIndex, period) in quarters.enumerated() {
		let growth = growthDriver.sample(for: period)
		currentRevenue = currentRevenue * (1.0 + growth)
		allValues[periodIndex].append(currentRevenue)
	}
}

// Calculate statistics for each period - optimized
var statistics: [Period: SimulationStatistics] = [:]
var percentiles: [Period: Percentiles] = [:]

for (periodIndex, period) in quarters.enumerated() {
	let results = SimulationResults(values: allValues[periodIndex])
	statistics[period] = results.statistics
	percentiles[period] = results.percentiles
}

// Analyze results
print("Revenue Forecast with Compounding Growth")
print("=========================================")
print("Base Revenue: \(baseRevenue.currency(0))")
print("Quarterly Growth: 10% ± 5% (compounding)")
print()
print("Quarter\t\tMean\t\tMedian\t\t90% CI\t\t\t\t\t  Growth")
print("-------\t\t---------\t----------\t------------------------  --------")

for (index, quarter) in quarters.enumerated() {
	let stats = statistics[quarter]!
	let pctiles = percentiles[quarter]!
	let growthFromBase = (stats.mean - baseRevenue) / baseRevenue
	print("\(quarter.label)\(stats.mean.number(0).paddingLeft(toLength: 14))\(pctiles.p50.currency(0).paddingLeft(toLength: 13))\t\("[\(pctiles.p5.currency(0)), \(pctiles.p95.currency(0))]".paddingLeft(toLength: 24))\(growthFromBase.percent(1,.always(includingZero: true)).paddingLeft(toLength: 8))")
}

// Extract time series at different confidence levels
// Build time series from our calculated statistics
let expectedValues = quarters.map { statistics[$0]!.mean }
let medianValues = quarters.map { percentiles[$0]!.p50 }
let p5Values = quarters.map { percentiles[$0]!.p5 }
let p95Values = quarters.map { percentiles[$0]!.p95 }

let expectedRevenue = TimeSeries(periods: quarters, values: expectedValues)
let medianRevenue = TimeSeries(periods: quarters, values: medianValues)
let conservativeRevenue = TimeSeries(periods: quarters, values: p5Values)
let optimisticRevenue = TimeSeries(periods: quarters, values: p95Values)

print("\nTime Series Projections:")
print("Conservative (P5): \(conservativeRevenue.valuesArray.map { $0.currency(0) })")
print("  Expected (mean): \(expectedRevenue.valuesArray.map { $0.currency(0) })")
print(" Optimistic (P95): \(optimisticRevenue.valuesArray.map { $0.currency(0) })")

// Show compounding effect
let finalRevenue = statistics[quarters[3]]!.mean
let totalGrowth = (finalRevenue - baseRevenue) / baseRevenue
let simpleGrowth = 0.10 * 4  // 4 quarters × 10%
print("\nCompounding Effect:")
print("Total growth over 4 quarters: \(totalGrowth.percent(1))")
print("Simple growth (4 × 10%): \(simpleGrowth.percent(1))")
print("Compounding benefit: \((totalGrowth - simpleGrowth).percent(1))")
```

**Expected output:**
```
Revenue Forecast with Compounding Growth
=========================================
Base Revenue: $1,000,000
Quarterly Growth: 10% ± 5% (compounding)

Quarter		Mean		Median		90% CI					  Growth
-------		---------	----------	------------------------  --------
2025-Q1     1,100,587   $1,099,896	[$1,019,564, $1,183,779]  +10.1%
2025-Q2     1,210,477   $1,208,943	[$1,084,460, $1,341,017]  +21.0%
2025-Q3     1,331,891   $1,328,548	[$1,165,310, $1,509,437]  +33.2%
2025-Q4     1,466,034   $1,460,530	[$1,256,213, $1,691,136]  +46.6%

Time Series Projections:
Conservative (P5): ["$1,019,564", "$1,084,460", "$1,165,310", "$1,256,213"]
  Expected (mean): ["$1,100,587", "$1,210,477", "$1,331,891", "$1,466,034"]
 Optimistic (P95): ["$1,183,779", "$1,341,017", "$1,509,437", "$1,691,136"]

Compounding Effect:
Total growth over 4 quarters: 46.6%
Simple growth (4 × 10%): 40.0%
Compounding benefit: 6.6%
```

**Key Insights:**
- **Compounding accelerates growth**: 46.4% total vs 40% simple growth
- **Uncertainty widens over time**: 90% CI width grows from $164K (Q1) to $578K (Q4)
- **Conservative case still grows**: Even P5 reaches $1.175M by Q4 (+17.5%)
- **Each quarter builds on previous**: Q2 is 10% above Q1, not 10% above base

**Important Implementation Detail:**

The key to proper compounding is generating **complete paths** in each Monte Carlo iteration:

```swift
// ✓ Correct: Complete path per iteration
for iteration in 1...10_000 {
    var revenue = baseRevenue
    for period in periods {
        revenue *= (1 + sampleGrowth())  // Compounds
        recordValue(period, revenue)
    }
}

// ✗ Incorrect: Each period sampled independently
for period in periods {
    for iteration in 1...10_000 {
        let revenue = baseRevenue * (1 + sampleGrowth())  // No compounding!
        recordValue(period, revenue)
    }
}
```

The first approach maintains state (currentRevenue) across periods within each iteration, enabling proper compounding.

**Performance Optimization:**

For best performance with large simulations:

1. **Pre-allocate arrays** with `reserveCapacity()` to avoid repeated reallocations
2. **Store by period** rather than by path to minimize array operations
3. **Inline the path generation** instead of calling a separate function
4. **Use SimulationResults** which efficiently sorts only once for percentiles

This approach handles 10,000 iterations × 20 periods in under 1 second on modern hardware.

## Part 2: Complete Income Statement Forecast

Now let's build a full income statement with multiple uncertain line items.

### Example 3: Multi-Line Income Statement with Uncertainty

```swift
// Define probabilistic drivers for each income statement line
struct IncomeStatementDrivers {
	// Revenue drivers
	let unitsSold: ProbabilisticDriver<Double>
	let averagePrice: ProbabilisticDriver<Double>

	// Cost drivers
	let cogs: ProbabilisticDriver<Double>  // % of revenue
	let opex: ProbabilisticDriver<Double>  // Fixed operating expenses

	init() {
		// Units Sold: Normal distribution
		// Mean 10,000 units, std dev 1,000 units (10% CoV)
		self.unitsSold = .normal(
			name: "Units Sold",
			mean: 10_000.0,
			stdDev: 1_000.0
		)

		// Average Price: Triangular distribution
		// Most likely $100, could range $95-$110
		self.averagePrice = .triangular(
			name: "Average Price",
			low: 95.0,
			high: 110.0,
			base: 100.0
		)

		// COGS as % of revenue: Normal distribution
		// Mean 60%, std dev 3%
		self.cogs = .normal(
			name: "COGS %",
			mean: 0.60,
			stdDev: 0.03
		)

		// Operating Expenses: Normal distribution
		// Mean $200K, std dev $20K
		self.opex = .normal(
			name: "Operating Expenses",
			mean: 200_000.0,
			stdDev: 20_000.0
		)
	}
}

let drivers = IncomeStatementDrivers()
let periods = Period.year(2025).quarters()

// Define derived metrics using driver composition
// Revenue = Units × Price
let revenueDriver = ProductDriver(
	name: "Revenue",
	lhs: drivers.unitsSold,
	rhs: drivers.averagePrice
)

// Gross Profit = Revenue × (1 - COGS%)
let grossProfitDriver = TimeVaryingDriver<Double>(name: "Gross Profit") { period in
	let revenue = revenueDriver.sample(for: period)
	let cogsPercent = drivers.cogs.sample(for: period)
	return revenue * (1.0 - cogsPercent)
}

// Operating Income = Gross Profit - OpEx
let operatingIncomeDriver = TimeVaryingDriver<Double>(name: "Operating Income") { period in
	let grossProfit = grossProfitDriver.sample(for: period)
	let opex = drivers.opex.sample(for: period)
	return grossProfit - opex
}

// Run simulations for each metric
let revenueProjection = DriverProjection(driver: revenueDriver, periods: periods)
let revenueResults = revenueProjection.projectMonteCarlo(iterations: 10_000)

let grossProfitProjection = DriverProjection(driver: grossProfitDriver, periods: periods)
let grossProfitResults = grossProfitProjection.projectMonteCarlo(iterations: 10_000)

let opIncomeProjection = DriverProjection(driver: operatingIncomeDriver, periods: periods)
let opIncomeResults = opIncomeProjection.projectMonteCarlo(iterations: 10_000)

// Display comprehensive income statement forecast
print("\nIncome Statement Forecast - 2025")
print("==================================")
print()

for (index, quarter) in periods.enumerated() {
	print("\(quarter.label)")
	print(String(repeating: "-", count: 80))

	// Revenue
	let revStats = revenueResults.statistics[quarter]!
	let revPctiles = revenueResults.percentiles[quarter]!
	print("Revenue")
	print("  Expected: \(revStats.mean.currency(0))")
	print("  Std Dev: \(revStats.stdDev.currency(0)) (CoV: \((revStats.stdDev / revStats.mean).percent(1)))")
	print("  90% CI: [\(revPctiles.p5.currency(0)), \(revPctiles.p95.currency(0))]")

	// Gross Profit
	let gpStats = grossProfitResults.statistics[quarter]!
	let gpPctiles = grossProfitResults.percentiles[quarter]!
	let gpMargin = gpStats.mean / revStats.mean
	print("\nGross Profit")
	print("  Expected: \(gpStats.mean.currency(0)) (\(gpMargin.percent(1)) margin)")
	print("  Std Dev: \(gpStats.stdDev.currency(0))")
	print("  90% CI: [\(gpPctiles.p5.currency(0)), \(gpPctiles.p95.currency(0))]")

	// Operating Income
	let opStats = opIncomeResults.statistics[quarter]!
	let opPctiles = opIncomeResults.percentiles[quarter]!
	let opMargin = opStats.mean / revStats.mean
	print("\nOperating Income")
	print("  Expected: \(opStats.mean.currency(0)) (\(opMargin.percent(1)) margin)")
	print("  Std Dev: \(opStats.stdDev.currency(0))")
	print("  90% CI: [\(opPctiles.p5.currency(0)), \(opPctiles.p95.currency(0))]")

	// Risk metrics
	let profitabilityProbability = Double(opPctiles.p5 > 0 ? 1 :
											(opPctiles.p25 > 0 ? 0.75 :
												(opPctiles.p50 > 0 ? 0.50 : 0.25)))
	print("\nRisk Assessment")
	print("  Probability of profit: ~\(profitabilityProbability.percent(1))")

	if index < periods.count - 1 {
		print()
	}
}

```

**Expected output:**
```
Income Statement Forecast - 2025
==================================

2025-Q1
--------------------------------------------------------------------------------
Revenue
  Expected: $1,016,060
  Std Dev: $106,538 (CoV: 10.5%)
  90% CI: [$846,368, $1,192,050]

Gross Profit
  Expected: $406,096 (40.0% margin)
  Std Dev: $52,325
  90% CI: [$324,282, $495,094]

Operating Income
  Expected: $207,201 (20.4% margin)
  Std Dev: $56,497
  90% CI: [$118,516, $303,277]

Risk Assessment
  Probability of profit: ~100.0%

2025-Q2
--------------------------------------------------------------------------------
Revenue
  Expected: $1,015,546
  Std Dev: $107,896 (CoV: 10.6%)
  90% CI: [$840,956, $1,194,608]

Gross Profit
  Expected: $406,599 (40.0% margin)
  Std Dev: $52,605
  90% CI: [$323,367, $496,726]

Operating Income
  Expected: $206,656 (20.3% margin)
  Std Dev: $56,395
  90% CI: [$116,290, $301,445]

Risk Assessment
  Probability of profit: ~100.0%

2025-Q3
--------------------------------------------------------------------------------
Revenue
  Expected: $1,015,622
  Std Dev: $106,366 (CoV: 10.5%)
  90% CI: [$843,323, $1,190,755]

Gross Profit
  Expected: $407,370 (40.1% margin)
  Std Dev: $52,484
  90% CI: [$324,136, $496,858]

Operating Income
  Expected: $206,861 (20.4% margin)
  Std Dev: $57,035
  90% CI: [$116,020, $303,410]

Risk Assessment
  Probability of profit: ~100.0%

2025-Q4
--------------------------------------------------------------------------------
Revenue
  Expected: $1,017,036
  Std Dev: $107,458 (CoV: 10.6%)
  90% CI: [$843,645, $1,195,991]

Gross Profit
  Expected: $406,587 (40.0% margin)
  Std Dev: $52,824
  90% CI: [$323,968, $496,203]

Operating Income
  Expected: $206,102 (20.3% margin)
  Std Dev: $56,609
  90% CI: [$115,850, $300,244]

Risk Assessment
  Probability of profit: ~100.0%
```

**Insights:**
- **Coefficient of Variation (CoV)** shows relative uncertainty: 10.7% for revenue
- **90% Confidence Intervals** provide range for planning and budgeting
- **Operating income has higher variance** than revenue (uncertainty compounds)
- **Risk assessment** quantifies downside probability

## Part 3: Growth-Based Projections

Apply growth rates to starting values and project forward.

### Example 4: Revenue Growth with Mean Reversion

```swift
// Starting revenue
	let baseRevenue = 1_000_000.0

// Define growth driver with declining variance (mean reversion)
struct GrowthModel {
	let initialGrowth: Double = 0.15  // 15% initial growth
	let longTermGrowth: Double = 0.05  // 5% terminal growth
	let periods: Int

	func growthRate(for periodIndex: Int) -> ProbabilisticDriver<Double> {
		// Linear interpolation from initial to long-term
		let t = Double(periodIndex) / Double(periods - 1)
		let meanGrowth = initialGrowth * (1 - t) + longTermGrowth * t

		// Declining uncertainty over time
		let stdDev = 0.05 * (1 - t * 0.5)  // Starts at 5%, declines to 2.5%

		return .normal(
			name: "Growth Rate Q\(periodIndex + 1)",
			mean: meanGrowth,
			stdDev: stdDev
		)
	}
}

let growthModel = GrowthModel(periods: 8)
let quarters2Years = (1...8).map { Period.quarter(year: 2025 + ($0 - 1) / 4, quarter: (($0 - 1) % 4) + 1) }

// Optimized simulation with proper compounding
	let iterations = 10_000
var allValues2Years: [[Double]] = Array(repeating: [], count: quarters2Years.count)
for i in 0..<quarters2Years.count {
	allValues2Years[i].reserveCapacity(iterations)
}

// Run all iterations
for _ in 0..<iterations {
	var currentRevenue = baseRevenue

	for (periodIndex, period) in quarters2Years.enumerated() {
		// Get growth driver for this period (declining mean and variance)
		let growthDriver = growthModel.growthRate(for: periodIndex)
		let growth = growthDriver.sample(for: period)

		// Compound growth
		currentRevenue = currentRevenue * (1.0 + growth)
		allValues2Years[periodIndex].append(currentRevenue)
	}
}

// Calculate statistics
var statistics2Years: [Period: SimulationStatistics] = [:]
var percentiles2Years: [Period: Percentiles] = [:]

for (periodIndex, period) in quarters2Years.enumerated() {
	let results = SimulationResults(values: allValues2Years[periodIndex])
	statistics2Years[period] = results.statistics
	percentiles2Years[period] = results.percentiles
}

// Display results
print("\nRevenue Growth Forecast with Mean Reversion")
print("=============================================")
print("Base Revenue: \(baseRevenue.currency())")
print("Initial Growth: 15% → Terminal Growth: 5%")
print()
print("Quarter\t\tExpected\tGrowth from Base\t90% CI")
print(String(repeating: "-", count: 80))

for (index, quarter) in quarters2Years.enumerated() {
	let stats = statistics2Years[quarter]!
	let pctiles = percentiles2Years[quarter]!
	let growthFromBase = (stats.mean - baseRevenue) / baseRevenue
	print("\(quarter.label.padding(toLength: 10, withPad: " ", startingAt: 0)) \(stats.mean.currency(0).paddingLeft(toLength: 11)) \(growthFromBase.percent(1).paddingLeft(toLength: 17)) \("[\(pctiles.p5.currency(0)),\t\(pctiles.p95.currency(0))]".paddingLeft(toLength: 26))")
}

let finalRevenue2Years = statistics2Years[quarters.last!]!.mean
let totalGrowth2Years = (finalRevenue2Years - baseRevenue) / baseRevenue
print("\nTotal Growth over 2 years: \(totalGrowth2Years.percent(1))")

```

**Expected output:**
```
Revenue Growth Forecast with Mean Reversion
=============================================
Base Revenue: $1,000,000.00
Initial Growth: 15% → Terminal Growth: 5%

Quarter		Expected	Growth from Base	90% CI
--------------------------------------------------------------------------------
2025-Q1     $1,150,159             15.0%   [$1,067,483,	$1,232,925]
2025-Q2     $1,306,761             30.7%   [$1,180,569,	$1,436,681]
2025-Q3     $1,465,710             46.6%   [$1,299,918,	$1,642,513]
2025-Q4     $1,623,336             62.3%   [$1,422,137,	$1,844,088]
2026-Q1     $1,773,551             77.4%   [$1,537,680,	$2,036,085]
2026-Q2     $1,913,287             91.3%   [$1,641,400,	$2,210,947]
2026-Q3     $2,036,026            103.6%   [$1,734,984,	$2,371,801]
2026-Q4     $2,138,787            113.9%   [$1,812,885,	$2,496,412]

Total Growth over 2 years: 62.3%
```

**Insights:**
- **Growth rate declines**: Starts at 15%, converges to 5% terminal rate
- **Uncertainty narrows**: Confidence interval width as % of mean decreases over time
- **Compounding effect**: 99.5% total growth = roughly doubling revenue
- **Mean reversion visible**: Growth from period-to-period slows (30.6% → 15.6% incremental)

## Part 4: Calculating Confidence Intervals

Extract precise confidence intervals for risk analysis.

### Example 5: Custom Confidence Intervals

```swift
// Helper function to calculate arbitrary confidence intervals
func confidenceInterval(
	results: ProjectionResults<Double>,
	period: Period,
	confidence: Double  // e.g., 0.90 for 90%, 0.95 for 95%
) -> (lower: Double, upper: Double) {
	let alpha = (1.0 - confidence) / 2.0  // Split the rest equally

	let lowerPercentile = alpha
	let upperPercentile = 1.0 - alpha

	let pctiles = results.percentiles[period]!

	// Map to closest available percentiles
	let lower: Double
	if lowerPercentile <= 0.05 {
		lower = pctiles.p5
	} else if lowerPercentile <= 0.25 {
		// Interpolate between p5 and p25
		let t = (lowerPercentile - 0.05) / 0.20
		lower = pctiles.p5 * (1 - t) + pctiles.p25 * t
	} else {
		lower = pctiles.p25
	}

	let upper: Double
	if upperPercentile >= 0.95 {
		upper = pctiles.p95
	} else if upperPercentile >= 0.75 {
		// Interpolate between p75 and p95
		let t = (upperPercentile - 0.75) / 0.20
		upper = pctiles.p75 * (1 - t) + pctiles.p95 * t
	} else {
		upper = pctiles.p75
	}

	return (lower, upper)
}

// Example usage
let revenueDriverCI = ProbabilisticDriver<Double>.normal(
	name: "Revenue",
	mean: 1_000_000.0,
	stdDev: 100_000.0
)

let projectionCI = DriverProjection(driver: revenueDriverCI, periods: quarters2Years)
let resultsCI = projectionCI.projectMonteCarlo(iterations: 10_000)

print("\nConfidence Intervals for Revenue Forecast")
print("==========================================")

for quarter in quarters2Years {
	let stats = resultsCI.statistics[quarter]!

	let ci90 = confidenceInterval(results: resultsCI, period: quarter, confidence: 0.90)
	let ci95 = confidenceInterval(results: resultsCI, period: quarter, confidence: 0.95)
	let ci99 = confidenceInterval(results: resultsCI, period: quarter, confidence: 0.99)

	print("\n\(quarter.label)")
	print("  Mean: \(stats.mean.currency(0))")
	print("  90% CI: [\(ci90.lower.currency(0)), \(ci90.upper.currency(0))]")
	print("  95% CI: [\(ci95.lower.currency(0)), \(ci95.upper.currency(0))]")
	print("  99% CI: [\(ci99.lower.currency(0)), \(ci99.upper.currency(0))]")
}
```

**Expected output:**
```
Confidence Intervals for Revenue Forecast
==========================================

2025-Q1
  Mean: $999,571
  90% CI: [$834,207, $1,163,116]
  95% CI: [$834,207, $1,163,116]
  99% CI: [$834,207, $1,163,116]

2025-Q2
  Mean: $1,001,323
  90% CI: [$840,071, $1,165,570]
  95% CI: [$840,071, $1,165,570]
  99% CI: [$840,071, $1,165,570]

2025-Q3
  Mean: $1,000,151
  90% CI: [$836,376, $1,166,741]
  95% CI: [$836,376, $1,166,741]
  99% CI: [$836,376, $1,166,741]

2025-Q4
  Mean: $999,535
  90% CI: [$831,931, $1,165,190]
  95% CI: [$831,931, $1,165,190]
  99% CI: [$831,931, $1,165,190]

2026-Q1
  Mean: $999,819
  90% CI: [$836,594, $1,164,634]
  95% CI: [$836,594, $1,164,634]
  99% CI: [$836,594, $1,164,634]

2026-Q2
  Mean: $999,267
  90% CI: [$834,727, $1,161,353]
  95% CI: [$834,727, $1,161,353]
  99% CI: [$834,727, $1,161,353]

2026-Q3
  Mean: $1,000,285
  90% CI: [$838,036, $1,163,262]
  95% CI: [$838,036, $1,163,262]
  99% CI: [$838,036, $1,163,262]

2026-Q4
  Mean: $998,216
  90% CI: [$833,550, $1,164,771]
  95% CI: [$833,550, $1,164,771]
  99% CI: [$833,550, $1,164,771]
```

## Part 5: Advanced Patterns

### Pattern 1: Exporting Results to CSV

```swift
// Extract time series for each confidence level
let mean = resultsCI.expected()
let p5 = resultsCI.percentile(0.05)
let p25 = resultsCI.percentile(0.25)
let p50 = resultsCI.median()
let p75 = resultsCI.percentile(0.75)
let p95 = resultsCI.percentile(0.95)

print("\nPeriod,Mean,P5,P25,Median,P75,P95")
for (index, period) in periods.enumerated() {
	print("\(period.label),\(mean.valuesArray[index]),\(p5.valuesArray[index]),\(p25.valuesArray[index]),\(p50.valuesArray[index])$\(p75.valuesArray[index]),\(p95.valuesArray[index])")
}
```

### Pattern 2: Risk Metrics

```swift
// Calculate downside risk and upside potential
for quarter in quarters {
	let stats = results.statistics[quarter]!
	let pctiles = results.percentiles[quarter]!

	let downsideRisk = stats.mean - pctiles.p5
	let upsidePotential = pctiles.p95 - stats.mean
	let asymmetry = upsidePotential / downsideRisk

	print("\n\(quarter.label)")
	print("  Expected: \(stats.mean.currency(0))")
	print("  Downside Risk (P5): \(downsideRisk.currency(0))")
	print("  Upside Potential (P95): \(upsidePotential.currency(0))")
	print("  Risk/Reward Ratio: \(asymmetry.number(2))")

	if asymmetry > 1.0 {
		print("  → Favorable risk/reward profile")
	} else if asymmetry < 1.0 {
		print("  → Unfavorable risk/reward profile")
	} else {
		print("  → Balanced risk/reward")
	}
}
```

### Pattern 3: Sensitivity Analysis with Monte Carlo

Combine with data tables to see impact of distribution parameters:

```swift
// Test different uncertainty levels
let stdDevScenarios = [50_000.0, 100_000.0, 150_000.0, 200_000.0]

print("\nSensitivity to Uncertainty Level")
print("==================================")
print("Std Dev\t\t90% CI Width\tCoefficient of Variation")
print(String(repeating: "-", count: 60))

for stdDev in stdDevScenarios {
    let driver = ProbabilisticDriver<Double>.normal(
        name: "Revenue",
        mean: 1_000_000.0,
        stdDev: stdDev
    )

    let proj = DriverProjection(driver: driver, periods: [quarters[0]])
    let res = proj.projectMonteCarlo(iterations: 10_000)

    let pctiles = res.percentiles[quarters[0]]!
    let stats = res.statistics[quarters[0]]!
    let ciWidth = pctiles.p95 - pctiles.p5
    let cov = stats.stdDev / stats.mean * 100

    print("$\(String(format: "%.0f", stdDev))\t\t$\(String(format: "%.0f", ciWidth))\t\t\(String(format: "%.1f%%", cov))")
}
```

## Best Practices

### 1. Choose Appropriate Distributions

```swift
// ✓ Good: Normal for variables that can be + or -
let growthRate = ProbabilisticDriver<Double>.normal(
    name: "Growth Rate",
    mean: 0.10,
    stdDev: 0.05
)

// ✓ Good: Triangular for variables with known min/max/mode
let price = ProbabilisticDriver<Double>.triangular(
    name: "Price",
    low: 95.0,
    high: 110.0,
    base: 100.0
)

// ✗ Bad: Normal for strictly positive variables (can generate negatives)
// Use lognormal or truncated distributions instead
```

### 2. Run Sufficient Iterations

```swift
// ✗ Too few: High variance in results
let iterations = 100  // Unstable statistics

// ✓ Good: Stable percentiles (recommended)
let iterations = 10_000  // < 1 second for 20 periods

// ✓ High precision: For critical decisions
let iterations = 100_000  // ~5 seconds for 20 periods
```

**Performance benchmarks** (Release build, M1 Mac):
- 10,000 iterations × 4 periods: ~0.1 seconds
- 10,000 iterations × 20 periods: ~0.5 seconds
- 100,000 iterations × 20 periods: ~5 seconds

Playgrounds are 5-10× slower; compile with `-c release` for production speed.

### 3. Validate Results

```swift
// Check that results make sense
for quarter in quarters {
    let stats = results.statistics[quarter]!
    let pctiles = results.percentiles[quarter]!

    // Mean should be close to distribution mean
    assert(abs(stats.mean - 1_000_000) / 1_000_000 < 0.05, "Mean drift too large")

    // P50 should be close to mean for symmetric distributions
    assert(abs(pctiles.p50 - stats.mean) / stats.mean < 0.05, "Asymmetry unexpected")

    // Confidence intervals should be ordered
    assert(pctiles.p5 < pctiles.p25)
    assert(pctiles.p25 < pctiles.p50)
    assert(pctiles.p50 < pctiles.p75)
    assert(pctiles.p75 < pctiles.p95)
}
```

### 4. Document Assumptions

```swift
print("\nModel Assumptions:")
print("- Revenue growth: Normal(10%, 5%) per quarter")
print("- COGS: 60% ± 3% of revenue")
print("- Operating expenses: $200K ± $20K per quarter")
print("- No correlation between periods (conservative)")
print("- No seasonality considered")
print("- Exchange rates assumed constant")
```

## Part 6: GPU-Accelerated Expression Models (Advanced)

For high-performance simulations with thousands of iterations, use ``MonteCarloExpressionModel`` for 10-100× speedup via GPU acceleration.

### Example 6: Single-Period Profit with GPU Acceleration

```swift
import BusinessMath

// Define model using expression builder
let profitModel = MonteCarloExpressionModel { builder in
    let revenue = builder[0]
    let costs = builder[1]
    return revenue - costs
}

// Create GPU-enabled simulation
var simulation = MonteCarloSimulation(
    iterations: 100_000,  // GPU handles large iterations efficiently
    enableGPU: true,
    expressionModel: profitModel
)

// Add inputs
simulation.addInput(SimulationInput(
    name: "Revenue",
    distribution: DistributionNormal(1_000_000.0, 100_000.0)
))

simulation.addInput(SimulationInput(
    name: "Costs",
    distribution: DistributionNormal(700_000.0, 50_000.0)
))

// Run simulation
let start = Date()
let results = try simulation.run()
let elapsed = Date().timeIntervalSince(start) * 1000

print("=== GPU-Accelerated Profit Simulation ===")
print("Iterations: 100,000")
print("Compute time: \(elapsed.number(1)) ms")
print("Used GPU: \(results.usedGPU)")
print()
print("Mean: \(results.statistics.mean.currency(0))")
print("StdDev: \(results.statistics.stdDev.currency(0))")
print("90% CI: [\(results.percentiles.p5.currency(0)), \(results.percentiles.p95.currency(0))]")
```

**Expected output:**
```
=== GPU-Accelerated Profit Simulation ===
Iterations: 100,000
Compute time: 68.9 ms
Used GPU: true

Mean: $299,987
StdDev: $111,812
90% CI: [$116,234, $483,891]
```

**Performance comparison:**
- **GPU (expression model)**: 69 ms for 100K iterations
- **CPU (traditional loop)**: 5,000-10,000 ms for 100K iterations
- **Speedup**: 70-150× faster!

### When to Use Expression Models vs Drivers

**Use Expression Models when:**
- High iteration counts (≥10,000)
- Performance is critical
- Model is compute-intensive
- Memory is constrained

**Use Drivers when:**
- Time series with compounding across periods
- Complex multi-period dependencies
- Need custom sampling logic
- Iteration count < 10,000

For comprehensive coverage of GPU-accelerated Monte Carlo with conditionals, correlation, and advanced features, see <doc:4.3-MonteCarloExpressionModelsGuide>.

## Summary

You've learned how to:

✓ Apply probabilistic growth rates to financial projections
✓ Build complete income statement forecasts with uncertainty
✓ Calculate 90%, 95%, and custom confidence intervals
✓ Extract mean, median, and percentile time series
✓ Combine multiple uncertain drivers (revenue, costs, margins)
✓ Quantify downside risk and upside potential
✓ Export results for further analysis
✓ Accelerate simulations with GPU-enabled expression models

Monte Carlo simulation transforms point forecasts into **probability distributions**, enabling:
- **Better decision-making** with understanding of risks
- **Scenario planning** across thousands of possibilities
- **Risk quantification** with precise confidence intervals
- **Stakeholder communication** with ranges instead of single numbers

## Next Steps

- Explore <doc:4.2-ScenarioAnalysisGuide> for structured scenario modeling
- **Learn <doc:4.3-MonteCarloExpressionModelsGuide> for GPU-accelerated models (10-100× faster)**
- Study <doc:2.3-RiskAnalyticsGuide> for advanced risk metrics (VaR, CVaR)
- See <doc:1.2-TimeSeries> for time series operations and transformations

## See Also

- ``DriverProjection``
- ``ProbabilisticDriver``
- ``ProjectionResults``
- ``TimeSeries``
- ``Period``
