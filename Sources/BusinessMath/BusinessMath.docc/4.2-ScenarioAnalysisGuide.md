# Scenario & Sensitivity Analysis

Learn how to model multiple scenarios and analyze which inputs have the greatest impact on your outcomes.

## Overview

BusinessMath provides powerful tools for scenario planning and sensitivity analysis. This tutorial shows you how to:
- Create multiple financial scenarios (base, best, worst case)
- Analyze how outputs change when inputs vary (sensitivity analysis)
- Identify the most impactful drivers (tornado diagrams)
- Run Monte Carlo simulations for risk analysis

## Content

## Understanding Scenarios

A scenario represents a complete set of assumptions about the future. Businesses typically model:
- **Base Case**: Most likely outcome
- **Best Case**: Optimistic assumptions
- **Worst Case**: Conservative assumptions
- **Custom Scenarios**: Specific situations (e.g., "Economic Recession")

## Creating Your First Scenario

Start with operational drivers and a builder function:

```swift
import BusinessMath

// Define the company and periods
let company = Entity(
 id: "TECH001",
 primaryType: .ticker,
 name: "TechCo"
)

let q1 = Period.quarter(year: 2025, quarter: 1)
let quarters = [q1, q1 + 1, q1 + 2, q1 + 3]

// Create base case drivers - use PRIMITIVES that represent independent inputs
// Key insight: Define COGS Rate instead of absolute COGS to model business economics
let baseRevenue = DeterministicDriver(name: "Revenue", value: 1_000_000)
let baseCOGSRate = DeterministicDriver(name: "COGS Rate", value: 0.60)  // 60% of revenue
let baseOpEx = DeterministicDriver(name: "OpEx", value: 200_000)

var baseOverrides: [String: AnyDriver<Double>] = [:]
baseOverrides["Revenue"] = AnyDriver(baseRevenue)
baseOverrides["COGS Rate"] = AnyDriver(baseCOGSRate)
baseOverrides["OpEx"] = AnyDriver(baseOpEx)

// Create base case scenario
let baseCase = FinancialScenario(
 name: "Base Case",
 description: "Expected performance",
 driverOverrides: baseOverrides
)

// Define how to build financial statements from drivers
// Important: Calculate COGS as Revenue × COGS Rate (formula driver)
let builder: ScenarioRunner.StatementBuilder = { drivers, periods in
 // Extract primitive driver values
 let revenue = drivers["Revenue"]!.sample(for: periods[0])
 let cogsRate = drivers["COGS Rate"]!.sample(for: periods[0])
 let opex = drivers["OpEx"]!.sample(for: periods[0])

 // Calculate COGS from the relationship: COGS = Revenue × COGS Rate
 let cogs = revenue * cogsRate

// Build Income Statement
let revenueAccount = try Account(
   entity: company,
   name: "Revenue",
   incomeStatementRole: .revenue,
   timeSeries: TimeSeries(periods: periods, values: Array(repeating: revenue, count: periods.count))
)

let cogsAccount = try Account(
   entity: company,
   name: "COGS",
   incomeStatementRole: .costOfGoodsSold,
   timeSeries: TimeSeries(periods: periods, values: Array(repeating: cogs, count: periods.count))
)

let opexAccount = try Account(
   entity: company,
   name: "Operating Expenses",
   incomeStatementRole: .operatingExpenseOther,
   timeSeries: TimeSeries(periods: periods, values: Array(repeating: opex, count: periods.count))
)

let incomeStatement = try IncomeStatement(
	entity: company,
	periods: periods,
	accounts: [revenueAccount, cogsAccount, opexAccount]
)

// Build simple Balance Sheet (required for complete projection)
let cashAccount = try Account(
   entity: company,
   name: "Cash",
   balanceSheetRole: .cashAndEquivalents,
   timeSeries: TimeSeries(periods: periods, values: [500_000, 550_000, 600_000, 650_000])
)

let equityAccount = try Account(
   entity: company,
   name: "Equity",
   balanceSheetRole: .commonStock,
   timeSeries: TimeSeries(periods: periods, values: [500_000, 550_000, 600_000, 650_000])
)

let balanceSheet = try BalanceSheet(
	entity: company,
	periods: periods,
	accounts: [cashAccount, equityAccount]
)

// Build simple Cash Flow Statement
let cfAccount = try Account(
   entity: company,
   name: "Operating Cash Flow",
   cashFlowRole: .netIncome,
   timeSeries: incomeStatement.netIncome
)

let cashFlowStatement = try CashFlowStatement(
   entity: company,
   periods: periods,
   accounts: [cfAccount]
)

return (incomeStatement, balanceSheet, cashFlowStatement)
}

// Run the base case
let runner = ScenarioRunner()
let baseProjection = try runner.run(
scenario: baseCase,
entity: company,
periods: quarters,
builder: builder
)

print("Base Case Q1 Net Income: \(baseProjection.incomeStatement.netIncome[q1]!.currency(0))")
```

## Creating Multiple Scenarios

Build best and worst case scenarios by overriding primitive drivers:

```swift
// Best Case: Higher revenue + better margins + lower OpEx
let bestRevenue = DeterministicDriver(name: "Revenue", value: 1_200_000)  // +20%
let bestCOGSRate = DeterministicDriver(name: "COGS Rate", value: 0.45)    // 45% (better margins!)
let bestOpEx = DeterministicDriver(name: "Operating Expenses", value: 180_000)          // -10%

var bestOverrides: [String: AnyDriver<Double>] = [:]
bestOverrides["Revenue"] = AnyDriver(bestRevenue)
bestOverrides["COGS Rate"] = AnyDriver(bestCOGSRate)
bestOverrides["Operating Expenses"] = AnyDriver(bestOpEx)

let bestCase = FinancialScenario(
    name: "Best Case",
    description: "Higher sales + better margins",
    driverOverrides: bestOverrides
)

// Worst Case: Lower revenue + margin compression + higher OpEx
let worstRevenue = DeterministicDriver(name: "Revenue", value: 800_000)   // -20%
let worstCOGSRate = DeterministicDriver(name: "COGS Rate", value: 0.825)  // 82.5% (margin compression!)
let worstOpEx = DeterministicDriver(name: "Operating Expenses", value: 220_000)         // +10%

var worstOverrides: [String: AnyDriver<Double>] = [:]
worstOverrides["Revenue"] = AnyDriver(worstRevenue)
worstOverrides["COGS Rate"] = AnyDriver(worstCOGSRate)
worstOverrides["Operating Expenses"] = AnyDriver(worstOpEx)

let worstCase = FinancialScenario(
    name: "Worst Case",
    description: "Lower sales + margin compression",
    driverOverrides: worstOverrides
)

// Run all scenarios
let bestProjection = try runner.run(
    scenario: bestCase,
    entity: company,
    periods: quarters,
    builder: builder
)

let worstProjection = try runner.run(
    scenario: worstCase,
    entity: company,
    periods: quarters,
    builder: builder
)

// Compare results
print("=== Q1 Net Income Comparison ===")
print("Best Case:  \(bestProjection.incomeStatement.netIncome[q1]!.currency(0, signStrategy: .accounting))")
print("Base Case:  \(baseProjection.incomeStatement.netIncome[q1]!.currency(0, signStrategy: .accounting))")
print("Worst Case: \(worstProjection.incomeStatement.netIncome[q1]!.currency(0, signStrategy: .accounting))")

let range = bestProjection.incomeStatement.netIncome[q1]! -
			worstProjection.incomeStatement.netIncome[q1]!
print("Range: \(range.currency(0, signStrategy: .accounting))")
```

## One-Way Sensitivity Analysis

Analyze how one input affects the output:

```swift
// How does Revenue affect Net Income?
let revenueSensitivity = try runSensitivity(
	baseCase: baseCase,
	entity: company,
	periods: quarters,
	inputDriver: "Revenue",
	inputRange: 800_000...1_200_000,  // ±20%
	steps: 9,  // Test 9 evenly-spaced values
	builder: builder
) { projection in
	// Extract Q1 Net Income as our output metric
	return projection.incomeStatement.netIncome[q1]!
}

// View results
print("\n=== Revenue Sensitivity Analysis ===")
for (revenue, netIncome) in zip(revenueSensitivity.inputValues, revenueSensitivity.outputValues) {
	print("Revenue: \(revenue.currency()) → Net Income: \(netIncome.currency())")
}

// Calculate slope (sensitivity)
let deltaRevenue = revenueSensitivity.inputValues.last! - revenueSensitivity.inputValues.first!
let deltaIncome = revenueSensitivity.outputValues.last! - revenueSensitivity.outputValues.first!
let sensitivity = deltaIncome / deltaRevenue
print("\nSensitivity: For every $1 increase in revenue, net income increases by \(sensitivity.currency())")
print("This represents a \(sensitivity.percent())% contribution margin (after COGS)")
```

> **Key Insight**: With COGS Rate at 60%, the contribution margin is 40%. Every $1 of revenue contributes $0.40 to covering fixed costs and profit after variable costs.

## Tornado Diagram Analysis

Identify which drivers have the greatest impact:

```swift
// Analyze all key drivers at once
let tornado = try runTornadoAnalysis(
    baseCase: baseCase,
    entity: company,
    periods: quarters,
    inputDrivers: ["Revenue", "COGS Rate", "Operating Expenses"],  // Note: Use COGS Rate, not absolute Costs
    variationPercent: 0.20,  // Vary each by ±20%
    steps: 2,  // Just test high and low values
    builder: builder
) { projection in
    return projection.incomeStatement.netIncome[q1]!
}

// Results are ranked by impact
print("\n=== Tornado Diagram (Ranked by Impact) ===")
for input in tornado.inputs {
	let impact = tornado.impacts[input]!
	let low = tornado.lowValues[input]!
	let high = tornado.highValues[input]!
	let percentImpact = (impact / tornado.baseCaseOutput)

	print("\(input):")
	print("  Low:    \(low.currency(0))")
	print("  High:   \(high.currency(0))")
	print("  Impact: \(impact.currency(0)) (\(percentImpact.percent(1)))")
}

// Visualize with command-line tornado diagram
let plot = plotTornadoDiagram(tornado)
print("\n" + plot)
```

## Two-Way Sensitivity Analysis

Analyze interactions between two inputs to understand trade-offs:

```swift
// How do Revenue and COGS Rate interact?
// This reveals the volume vs. margin trade-off
let twoWaySensitivity = try runTwoWaySensitivity(
    baseCase: baseCase,
    entity: company,
    periods: quarters,
    inputDriver1: "Revenue",
    inputRange1: 800_000...1_200_000,
    steps1: 5,
    inputDriver2: "COGS Rate",
    inputRange2: 0.48...0.72,  // 48% to 72% COGS
    steps2: 5,
    builder: builder
) { projection in
    return projection.incomeStatement.netIncome[q1]!
}

// Print data table showing volume/margin trade-offs
print("\n=== Two-Way Sensitivity: Revenue × COGS Rate ===")
print("COGS Rate →")
var header = "Revenue ↓    "
for cogsRate in twoWaySensitivity.inputValues2 {
	header += (cogsRate * 100).number(0).padding(toLength: 8, withPad: " ", startingAt: 0) + "% "
}
print(header)
print(String(repeating: "-", count: 60))

for (i, revenue) in twoWaySensitivity.inputValues1.enumerated() {
	var rowLine = revenue.currency(0).padding(toLength: 12, withPad: " ", startingAt: 0) + " "
	for j in 0..<twoWaySensitivity.inputValues2.count {
		let netIncome = twoWaySensitivity.results[i][j]
		rowLine += netIncome.currency(0).paddingLeft(toLength: 9)
	}
	print(rowLine)
}
```

> **Strategic Insight**: This table reveals the **volume vs. margin trade-off**. A company at $800K revenue with 48% COGS Rate (high margins) can achieve similar profitability as $1.2M revenue with 72% COGS Rate (low margins). This shows margin quality can be more important than scale.

## Monte Carlo Simulation with Drivers

Model uncertainty with probabilistic inputs using the scenario framework:

```swift
// Create probabilistic drivers with proper distributions
let uncertainRevenue = ProbabilisticDriver<Double>(
	name: "Revenue",
	distribution: DistributionNormal(1_000_000.0, 100_000.0)  // ±$100K uncertainty
)

// Model margin uncertainty instead of absolute cost uncertainty
let uncertainCOGSRate = ProbabilisticDriver<Double>(
	name: "COGS Rate",
	distribution: DistributionNormal(0.60, 0.05)  // 60% ± 5% margin uncertainty
)

var monteCarloOverrides: [String: AnyDriver<Double>] = [:]
monteCarloOverrides["Revenue"] = AnyDriver(uncertainRevenue)
monteCarloOverrides["COGS Rate"] = AnyDriver(uncertainCOGSRate)
monteCarloOverrides["Operating Expenses"] = AnyDriver(baseOpEx)  // Keep OpEx fixed

let uncertainScenario = FinancialScenario(
	name: "Monte Carlo",
	description: "Probabilistic scenario with volume and margin uncertainty",
	driverOverrides: monteCarloOverrides
)

// Run simulation (10,000 iterations)
let simulation = try runFinancialSimulation(
	scenario: uncertainScenario,
	entity: company,
	periods: quarters,
	iterations: 10_000,
	builder: builder
)

// Define metric extractor for net income
let netIncomeMetric: (FinancialProjection) -> Double = { projection in
	return projection.incomeStatement.netIncome[q1]!
}

// Analyze results - basic statistics
print("\n=== Monte Carlo Simulation Results (10,000 iterations) ===")
let meanIncome = simulation.mean(metric: netIncomeMetric)
print("Mean Net Income: \(meanIncome.currency(0))")

// Calculate percentiles
print("\nPercentiles:")
let p5 = simulation.percentile(0.05, metric: netIncomeMetric)
let p25 = simulation.percentile(0.25, metric: netIncomeMetric)
let p50 = simulation.percentile(0.50, metric: netIncomeMetric)  // Median
let p75 = simulation.percentile(0.75, metric: netIncomeMetric)
let p95 = simulation.percentile(0.95, metric: netIncomeMetric)

print("  5th:  \(p5.currency(0))")
print("  25th: \(p25.currency(0))")
print("  50th: \(p50.currency(0)) (median)")
print("  75th: \(p75.currency(0))")
print("  95th: \(p95.currency(0))")

// Risk metrics
print("\nRisk Metrics:")
let var95 = simulation.valueAtRisk(0.95, metric: netIncomeMetric)
let cvar95 = simulation.conditionalValueAtRisk(0.95, metric: netIncomeMetric)
print("Value at Risk (95%): \(var95.currency(0))")
print("CVaR (95%): \(cvar95.currency(0))")

// Confidence intervals
let ci90 = simulation.confidenceInterval(0.90, metric: netIncomeMetric)
print("90% Confidence Interval: [\(ci90.lowerBound.currency(0)), \(ci90.upperBound.currency(0))]")

// Probability analysis
print("\nProbability Analysis:")
let probLoss = simulation.probabilityOfLoss(metric: netIncomeMetric)
let probBelow100k = simulation.probabilityBelow(100_000, metric: netIncomeMetric)
let probAbove200k = simulation.probabilityAbove(200_000, metric: netIncomeMetric)
print("Probability of loss (NI < $0): \(probLoss.percent(1))")
print("Probability NI < $100k: \(probBelow100k.percent(1))")
print("Probability NI > $200k: \(probAbove200k.percent(1))")
```

## GPU-Accelerated Monte Carlo with Expression Models

For high-performance single-period analysis, use ``MonteCarloExpressionModel`` for 10-100× speedup:

```swift
// Define profit model using expression API
let profitModel = MonteCarloExpressionModel { builder in
    let revenue = builder[0]
    let cogsRate = builder[1]
    let opex = builder[2]

    // Calculate COGS from revenue
    let cogs = revenue * cogsRate

    // Calculate profit
    let grossProfit = revenue - cogs
    let netIncome = grossProfit - opex

    // Apply conditional logic: tax only if profitable
    let isProfitable = netIncome.greaterThan(0.0)
    let taxRate = 0.21
    let afterTax = isProfitable.ifElse(
        then: netIncome * (1.0 - taxRate),
        else: netIncome
    )

    return afterTax
}

// Create GPU-enabled simulation
var gpuSim = MonteCarloSimulation(
    iterations: 100_000,  // GPU handles high iteration counts efficiently
    enableGPU: true,
    expressionModel: profitModel
)

// Add probability distributions
gpuSim.addInput(SimulationInput(
    name: "Revenue",
    distribution: DistributionNormal(1_000_000.0, 100_000.0)
))

gpuSim.addInput(SimulationInput(
    name: "COGS Rate",
    distribution: DistributionNormal(0.60, 0.05)
))

gpuSim.addInput(SimulationInput(
    name: "OpEx",
    distribution: DistributionNormal(200_000.0, 20_000.0)
))

// Run simulation with GPU acceleration
let start = Date()
let gpuResults = try gpuSim.run()
let elapsed = Date().timeIntervalSince(start) * 1000

print("\n=== GPU-Accelerated Monte Carlo (100,000 iterations) ===")
print("Compute time: \(elapsed.number(1)) ms")
print("Used GPU: \(gpuResults.usedGPU)")
print()
print("After-Tax Net Income:")
print("  Mean: \(gpuResults.statistics.mean.currency(0))")
print("  StdDev: \(gpuResults.statistics.stdDev.currency(0))")
print("  90% CI: [\(gpuResults.percentiles.p5.currency(0)), \(gpuResults.percentiles.p95.currency(0))]")
print()
print("Risk of Loss: \(gpuResults.probabilityBelow(0).percent(2))")

// Compare to base case
let baseProfit = 1_000_000.0 * (1.0 - 0.60) - 200_000.0
let baseTax = baseProfit * 0.21
let baseAfterTax = baseProfit - baseTax
print("Base case after-tax: \(baseAfterTax.currency(0))")
print("Monte Carlo mean: \(gpuResults.statistics.mean.currency(0))")
```

**Expected output:**
```
=== GPU-Accelerated Monte Carlo (100,000 iterations) ===
Compute time: 68.4 ms
Used GPU: true

After-Tax Net Income:
  Mean: $125,287
  StdDev: $88,923
  90% CI: [-$20,583, $270,641]

Risk of Loss: 7.8%

Base case after-tax: $158,000
Monte Carlo mean: $125,287
```

**Key advantages of expression models:**
- **10-100× faster**: 100K iterations in ~70 ms (vs 5-10 seconds on CPU)
- **10× less memory**: Streaming computation, no array storage
- **Conditional logic**: Built-in support for `ifElse`, comparisons
- **Automatic optimization**: Bytecode compiler simplifies expressions

For comprehensive coverage including correlation, option pricing, and performance optimization, see <doc:4.3-MonteCarloExpressionModelsGuide>.

## Modeling Business Economics: Compositional Drivers

### The Pattern: Primitives vs. Formulas

A critical design pattern for ergonomic scenario analysis is distinguishing **primitive inputs** from **calculated formulas**.

**Primitive Drivers** are independent inputs you can control:
- `Revenue` - sales volume
- `COGS Rate` - what percentage of revenue goes to production (e.g., 0.60 = 60%)
- `Operating Expenses` - fixed operating expenses

**Formula Drivers** are relationships calculated in the builder from primitives:
- `COGS = Revenue × COGS Rate` - computed in the builder, not passed as a driver

### Why This Matters

**1. Realistic Economics**
```swift
// ✅ Good: COGS scales with Revenue
let cogs = revenue * cogsRate  // 60% of revenue
// Result: 40% contribution margin (realistic)

// ❌ Anti-pattern: Independent COGS
let cogs = drivers["COGS"]!.sample(...)  // Fixed $600K
// Result: 100% revenue passthrough (unrealistic for variable costs)
```

**2. Flexible Scenario Testing**
With compositional drivers, you can test:
- **Volume scenarios**: Override just `Revenue` (margins stay constant)
- **Margin scenarios**: Override just `COGS Rate` (volume stays constant)
- **Combined scenarios**: Override both (like Best/Worst case)

```swift
// Test margin improvement without volume change
var marginScenario: [String: AnyDriver<Double>] = [:]
marginScenario["COGS Rate"] = AnyDriver(DeterministicDriver(name: "COGS Rate", value: 0.55))
// Revenue stays at base, COGS automatically recalculates to 55% of revenue
```

**3. Natural Sensitivity Analysis**
When you run sensitivity on `Revenue`, COGS automatically scales:
```swift
// Revenue $800K → COGS $480K (60%) → Contribution $320K
// Revenue $1.2M → COGS $720K (60%) → Contribution $480K
// Sensitivity: $0.40 per $1 revenue (40% contribution margin) ✓
```

**4. Probabilistic Composition**
Uncertainties in primitives compose correctly:
```swift
let uncertainRevenue = ProbabilisticDriver.normal(mean: 1_000_000, stdDev: 100_000)
let uncertainCOGSRate = ProbabilisticDriver.normal(mean: 0.60, stdDev: 0.05)

// In builder: let cogs = revenue * cogsRate
// Uncertainty in both Revenue and COGS Rate compounds naturally in COGS
```

### When to Use This Pattern

Use compositional drivers when:
- Costs scale with revenue (variable costs like COGS, sales commissions)
- Relationships exist between inputs (e.g., higher volume → better unit pricing)
- You want to test different economic scenarios (margin expansion vs. volume growth)

Keep drivers independent when:
- Truly fixed costs (rent, salaries)
- Unrelated business metrics
- You have specific override needs for absolute values

## Best Practices

## Compositional Drivers

1. **Model Economic Relationships**: Define COGS Rate instead of absolute COGS for variable costs
2. **Name Clearly**: Use "Rate", "Percentage", or "Per Unit" in names (e.g., "COGS Rate" not "COGS")
3. **Document Formulas**: Comment where formulas are calculated in the builder
4. **Validate Relationships**: Ensure calculated values make business sense

## Scenario Design

1. **Start Simple**: Begin with 3 scenarios (base, best, worst)
2. **Be Realistic**: Base assumptions on historical data and market research
3. **Document Assumptions**: Clearly state what each scenario represents
4. **Test Extremes**: Include stress tests for extreme but plausible events

## Sensitivity Analysis

1. **Focus on Key Drivers**: Don't test every input - focus on the most uncertain
2. **Use Consistent Ranges**: ±10%, ±20%, or ±30% are common choices
3. **Interpret Results**: Large impact + high uncertainty = highest risk
4. **Update Regularly**: Rerun as new information becomes available

## Monte Carlo Simulation

1. **Choose Appropriate Distributions**:
   - Revenue: Normal or Log-Normal
   - Costs: Normal
   - Percentages: Beta distribution
   - Count data: Poisson
2. **Set Reasonable Parameters**: Base σ on historical volatility
3. **Run Enough Iterations**: 10,000 is usually sufficient
4. **Validate Results**: Check that mean matches base case

## Next Steps

- **Learn <doc:4.3-MonteCarloExpressionModelsGuide> for GPU-accelerated Monte Carlo (10-100× faster)**
- Explore <doc:4.1-MonteCarloTimeSeriesGuide> for time series Monte Carlo projections
- Study <doc:2.2-FinancialRatiosGuide> for analyzing scenario results
- See <doc:3.3-BuildingRevenueModel> for more complex drivers

## Related Topics

- ``FinancialScenario``
- ``ScenarioRunner``
- ``FinancialProjection``
- ``runSensitivity(baseCase:entity:periods:inputDriver:inputRange:steps:builder:outputExtractor:)``
- ``runTornadoAnalysis(baseCase:entity:periods:inputDrivers:variationPercent:steps:builder:outputExtractor:)``
- ``FinancialSimulation``
- ``runFinancialSimulation(scenario:entity:periods:iterations:builder:)``
- ``ProbabilisticDriver``
- ``plotTornadoDiagram(_:)``
