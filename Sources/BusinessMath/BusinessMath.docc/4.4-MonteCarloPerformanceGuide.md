# Monte Carlo Performance Guide

Learn how to optimize Monte Carlo simulations for maximum performance.

## Overview

This guide explains the performance characteristics of Monte Carlo simulations in BusinessMath, covering:
- When to use GPU acceleration
- Understanding GPU vs CPU trade-offs
- CPU optimization techniques (Ziggurat algorithm)
- Performance benchmarking

## GPU Acceleration

### Understanding Expression Models vs Closure Models

BusinessMath provides two Monte Carlo APIs with different performance characteristics:

1. **Closure-Based Models** (CPU only)
   - Use natural Swift closures with any custom logic
   - Call external functions, use loops, conditionals
   - Flexible but cannot compile to GPU bytecode

2. **Expression-Based Models** (GPU-accelerated)
   - Use `MonteCarloExpressionModel` DSL
   - Restricted to mathematical expressions
   - Compiles to Metal GPU shaders for 10-100× speedup

**Key Insight**: GPU shaders require static, compilable operations. Custom functions cannot run on GPU—they must be rewritten as mathematical expressions.

### When GPU Helps

GPU acceleration provides the best speedup for:

1. **Complex Models** (10+ operations per iteration)
   - Financial models with multiple calculations
   - Models with many mathematical operations
   - Typical speedup: **5-15x**

2. **Very Large Simulations** (1M+ iterations)
   - Long-running simulations where setup cost amortizes
   - Complex models with massive iteration counts
   - Typical speedup: **Up to 20x**

### When GPU Doesn't Help

GPU overhead dominates performance for:

1. **Simple Models** (2-5 operations)
   - Basic addition, subtraction
   - Minimal computation per iteration
   - Typical speedup: **Only 2-3x**

2. **Small Simulations** (< 10K iterations)
   - GPU automatically disabled for < 1000 iterations
   - Setup overhead exceeds computation time

### GPU Overhead Sources

The GPU incurs overhead from:

- **Buffer Allocation**: ~8-10MB for 100K iterations
- **Data Upload**: Distributions and bytecode transfer to GPU
- **Metal Compilation**: One-time cost (~50ms, cached via singleton)
- **Result Download**: Transferring results back to CPU
- **Synchronization**: Waiting for GPU to complete

For simple models, this overhead can be **335x the actual computation time**!

## What CAN Be Modeled (GPU-Compatible)

### Core Supported Operations

`MonteCarloExpressionModel` supports all standard mathematical operations that compile to GPU bytecode:

#### Arithmetic Operations

```swift
let model = MonteCarloExpressionModel { builder in
    let revenue = builder[0]
    let costs = builder[1]
    let taxRate = builder[2]

    // +, -, *, /
    let profit = revenue - costs
    let netProfit = profit * (1.0 - taxRate)

    return netProfit
}
```

#### Mathematical Functions

```swift
let model = MonteCarloExpressionModel { builder in
    let stockPrice = builder[0]
    let volatility = builder[1]
    let time = builder[2]

    // sqrt, log, exp, abs, power
    let drift = stockPrice.exp()
    let diffusion = volatility * time.sqrt()
    let finalPrice = (drift + diffusion).abs()

    return finalPrice
}
```

#### Conditional Expressions

```swift
let model = MonteCarloExpressionModel { builder in
    let demand = builder[0]
    let capacity = builder[1]
    let price = builder[2]

    // condition.ifElse(then: value1, else: value2)
    let exceedsCapacity = demand.greaterThan(capacity)
    let actualSales = exceedsCapacity.ifElse(then: capacity, else: demand)
    let revenue = actualSales * price

    return revenue
}
```

#### Min/Max Operations

```swift
let model = MonteCarloExpressionModel { builder in
    let profit = builder[0]
    let targetProfit = builder[1]

    // min, max
    let cappedProfit = profit.min(targetProfit)
    let nonNegative = profit.max(0.0)

    return nonNegative
}
```

### Complete Example: Option Pricing (GPU-Compatible)

```swift
// Black-Scholes call option payoff
let callOption = MonteCarloExpressionModel { builder in
    let spotPrice = builder[0]
    let strike = builder[1]
    let riskFreeRate = builder[2]
    let volatility = builder[3]
    let time = builder[4]
    let randomNormal = builder[5]

    // Geometric Brownian Motion
    let drift = (riskFreeRate - volatility * volatility * 0.5) * time
    let diffusion = volatility * time.sqrt() * randomNormal
    let finalPrice = spotPrice * (drift + diffusion).exp()

    // Call option payoff: max(S - K, 0)
    let payoff = (finalPrice - strike).max(0.0)

    return payoff
}

var simulation = MonteCarloSimulation(
    iterations: 100_000,
    enableGPU: true,
    expressionModel: callOption
)

simulation.addInput(SimulationInput(name: "SpotPrice", distribution: DistributionNormal(100, 0)))
simulation.addInput(SimulationInput(name: "Strike", distribution: DistributionNormal(100, 0)))
simulation.addInput(SimulationInput(name: "RiskFreeRate", distribution: DistributionNormal(0.05, 0)))
simulation.addInput(SimulationInput(name: "Volatility", distribution: DistributionNormal(0.20, 0)))
simulation.addInput(SimulationInput(name: "Time", distribution: DistributionNormal(1.0, 0)))
simulation.addInput(SimulationInput(name: "RandomNormal", distribution: DistributionNormal(0, 1)))

let results = try simulation.run()

print("Call Option Value: $\(results.statistics.mean.number(2))")
print("Executed on: \(results.usedGPU ? "GPU ⚡" : "CPU")")
```

## Reusable Expression Functions

### Creating GPU-Compatible Functions

While arbitrary Swift functions can't compile to GPU, you can define reusable expression functions using the same DSL:

```swift
// Define a reusable tax calculation function
let calculateTax = ExpressionFunction(inputs: 2) { builder in
    let income = builder[0]
    let rate = builder[1]
    return income * rate
}

// Use it in a model (compiles to GPU!)
let profitModel = MonteCarloExpressionModel { builder in
    let revenue = builder[0]
    let costs = builder[1]
    let taxRate = builder[2]

    let profit = revenue - costs
    let taxes = calculateTax.call(profit, taxRate)  // ✓ Reusable!

    return profit - taxes
}
```

**Key Benefit**: Code reuse with GPU compatibility. The function is "inlined" during expression tree construction.

## Advanced GPU Features

### Fixed-Size Array Operations

Use arrays for portfolio calculations while maintaining GPU compatibility:

```swift
let portfolioModel = MonteCarloExpressionModel { builder in
    // 5-asset portfolio
    let weights = builder.array([0, 1, 2, 3, 4])
    let returns = builder.array([0.08, 0.10, 0.12, 0.09, 0.11])

    // Portfolio return: dot product
    let portfolioReturn = weights.dot(returns)

    return portfolioReturn
}
```

**Supported Array Operations**:
- **Reduction**: `sum()`, `product()`, `min()`, `max()`, `mean()`
- **Element-wise**: `map()`, `zipWith()`
- **Linear algebra**: `dot()`, `norm()`, `normalize()`
- **Statistical**: `variance()`, `stdDev()`

### Loop Unrolling (Fixed-Size Loops)

Multi-period calculations with compile-time unrolling:

```swift
let compoundingModel = MonteCarloExpressionModel { builder in
    let principal = builder[0]
    let annualRate = builder[1]

    // Compound for 10 years (unrolled at compile time)
    let finalValue = builder.forEach(0..<10, initial: principal) { year, value in
        return value * (1.0 + annualRate)
    }

    return finalValue
}
```

**How It Works**:
- Loop is completely unrolled at compile time
- Generates explicit operations (no runtime iteration)
- Compiles to GPU bytecode with zero performance overhead

**Practical Limits**:
- **Compile time**: Up to ~20 iterations (compile time grows linearly)
- **GPU bytecode**: Each iteration counts toward 128-operation GPU limit
  - Example: 10 iterations × 5 operations per iteration = 50 operations
  - Leave room for other calculations in your model
- **Recommendation**: Start with 5-10 iterations for complex models

> **Tip**: If you exceed the 128-operation GPU limit, the simulation automatically falls back to CPU execution. You'll see a warning but the simulation will complete successfully.

### Matrix Operations

Fixed-size matrices for covariance calculations:

```swift
let portfolioVarianceModel = MonteCarloExpressionModel { builder in
    let w1 = builder[0]
    let w2 = builder[1]
    let w3 = 1.0 - w1 - w2  // Budget constraint

    let weights = builder.array([w1, w2, w3])

    // 3×3 covariance matrix
    let covariance = builder.matrix(rows: 3, cols: 3, values: [
        [0.04, 0.01, 0.02],
        [0.01, 0.05, 0.015],
        [0.02, 0.015, 0.03]
    ])

    // Portfolio variance: w^T Σ w (quadratic form)
    let variance = covariance.quadraticForm(weights)

    return variance.sqrt()  // Return volatility
}
```

**Supported Matrix Operations**:
- **Matrix-vector**: `multiply(vector)`, `quadraticForm(vector)`
- **Matrix-matrix**: `multiply(matrix)`, `add(matrix)`, `transpose()`
- **Statistical**: `trace()`, `diagonal()`

### Example: Good GPU Use Case

```swift
// Complex financial model: multiple operations per iteration
let model = MonteCarloExpressionModel { builder in
    let units = builder[0]
    let price = builder[1]
    let fixedCosts = builder[2]
    let variableCost = builder[3]
    let taxRate = builder[4]

    let revenue = units * price
    let variableCosts = units * variableCost
    let totalCosts = fixedCosts + variableCosts
    let ebit = revenue - totalCosts
    let netIncome = ebit * (1.0 - taxRate)

    return netIncome  // 9 operations per iteration
}

var simulation = MonteCarloSimulation(
    iterations: 500_000,  // Large iteration count
    enableGPU: true,
    expressionModel: model
)

// Expected: 10-15x speedup
```

### Example: Poor GPU Use Case

```swift
// Simple model: only 1 operation
let model = MonteCarloExpressionModel { builder in
    builder[0] + builder[1]  // Just addition
}

var simulation = MonteCarloSimulation(
    iterations: 10_000,  // Small iteration count
    enableGPU: true,
    expressionModel: model
)

// Expected: Only 2x speedup (GPU overhead dominates)
```

## What CANNOT Be Modeled (CPU Only)

### Truly Unsupported Operations

These patterns cannot compile to GPU and require CPU execution:

#### Swift Functions (Closure-Based)

```swift
// ❌ WRONG: Cannot call closure-based Swift functions on GPU
func calculateTax(_ income: Double, _ rate: Double) -> Double {
    return income * rate
}

let model = MonteCarloExpressionModel { builder in
    let revenue = builder[0]
    let taxRate = builder[1]
    return calculateTax(revenue, taxRate)  // ❌ Won't compile!
}
```

**Fix Option 1**: Inline the logic
```swift
// ✓ CORRECT: Inline the calculation
let model = MonteCarloExpressionModel { builder in
    let revenue = builder[0]
    let taxRate = builder[1]
    return revenue * taxRate  // ✓ GPU-compatible
}
```

**Fix Option 2 (Better)**: Use ExpressionFunction for reusability
```swift
// ✓ BEST: Define reusable expression function
let calculateTax = ExpressionFunction(inputs: 2) { builder in
    let income = builder[0]
    let rate = builder[1]
    return income * rate
}

let model = MonteCarloExpressionModel { builder in
    let revenue = builder[0]
    let taxRate = builder[1]
    let taxes = calculateTax.call(revenue, taxRate)  // ✓ GPU-compatible!
    return revenue - taxes
}
```

#### Variable Loop Bounds

```swift
// ❌ Not supported: Variable loop bounds
let badModel = MonteCarloExpressionModel { builder in
    let n = Int(builder[0])  // Runtime value

    // Cannot use runtime value as loop bound
    let sum = builder.forEach(0..<n, initial: 0.0) { i, acc in
        acc + builder[i]
    }

    return sum
}
```

**Limitation**: Loop bounds must be compile-time constants. Variable loop bounds still require CPU.

## CPU Performance Optimization

### Current Implementation: Box-Muller Transform

The current CPU implementation uses the **Box-Muller transform** for generating normal random numbers:

```
Performance: ~100 CPU cycles per sample
Components:
  - log():   ~40 cycles
  - sqrt():  ~15 cycles
  - cos():   ~50 cycles
  - sin():   ~50 cycles (for second sample)
```

**Overhead**: For simple models, this makes CPU **10x slower than optimal**.

### Future Optimization: Ziggurat Algorithm

The **Ziggurat algorithm** provides 5-10x faster normal random number generation:

#### How Ziggurat Works

1. **Decompose the Bell Curve**: The normal distribution is divided into ~256 horizontal rectangles
2. **Fast Path (98% of samples)**: Simple table lookup + comparison (~10 cycles)
3. **Slow Path (2% of samples)**: Fallback to precise calculations (~120 cycles)
4. **Average Performance**: ~12 cycles per sample

#### Ziggurat vs Box-Muller

| Method | Cycles/Sample | Operations |
|--------|---------------|------------|
| **Box-Muller** (current) | ~100 | 2× log, 1× sqrt, 2× trig |
| **Ziggurat** (future) | ~12 | 1-2 lookups, 1-2 comparisons |
| **Speedup** | **8x faster** | Mostly table lookups |

#### Expected Impact

Implementing Ziggurat would:
- Improve CPU performance from 686ms → ~100ms (for 100K iterations)
- Make GPU vs CPU comparison more balanced (4-5x instead of 1.6x)
- Reduce simple model overhead by 85%

### When to Optimize CPU

CPU optimization is most valuable for:
- Closure-based models (can't use GPU)
- Models with correlations (GPU doesn't support)
- Simple models where GPU overhead dominates
- Cross-platform code (non-Apple hardware)

## Performance Measurement

### Benchmarking Best Practices

1. **Warm-up Run**: First GPU run includes compilation overhead
2. **Multiple Iterations**: Average over 3-5 runs for stability
3. **Realistic Models**: Test with your actual use case
4. **Check GPU Usage**: Verify `results.usedGPU` is true

### Example Benchmark

```swift
import Foundation
import BusinessMath

Task {
    do {
        let model = MonteCarloExpressionModel { builder in
            // Your model here
            builder[0] + builder[1]
        }

        // Warm-up
        var warmupSim = MonteCarloSimulation(iterations: 1000, enableGPU: true, expressionModel: model)
        warmupSim.addInput(SimulationInput(name: "A", distribution: DistributionNormal(100, 10)))
        warmupSim.addInput(SimulationInput(name: "B", distribution: DistributionNormal(50, 5)))
        _ = try warmupSim.run()

        // Measure GPU
        let gpuStart = Date()
        var gpuSim = MonteCarloSimulation(iterations: 100_000, enableGPU: true, expressionModel: model)
        gpuSim.addInput(SimulationInput(name: "A", distribution: DistributionNormal(100, 10)))
        gpuSim.addInput(SimulationInput(name: "B", distribution: DistributionNormal(50, 5)))
        let gpuResults = try gpuSim.run()
        let gpuTime = Date().timeIntervalSince(gpuStart)

        // Measure CPU
        let cpuStart = Date()
        var cpuSim = MonteCarloSimulation(iterations: 100_000, enableGPU: false, expressionModel: model)
        cpuSim.addInput(SimulationInput(name: "A", distribution: DistributionNormal(100, 10)))
        cpuSim.addInput(SimulationInput(name: "B", distribution: DistributionNormal(50, 5)))
        let cpuResults = try cpuSim.run()
        let cpuTime = Date().timeIntervalSince(cpuStart)

        print("Speedup: \(cpuTime / gpuTime)x")
    } catch {
        print("Benchmark failed: \(error)")
    }
}
```

## Performance Summary

| Model Complexity | Iterations | Expected GPU Speedup |
|-----------------|------------|---------------------|
| Simple (2-5 ops) | 10K | No benefit (overhead dominates) |
| Simple (2-5 ops) | 100K+ | 2-3x |
| Complex (10+ ops) | 100K | 5-10x |
| Complex (10+ ops) | 1M+ | 10-20x |

**Key Takeaway**: GPU acceleration shines for complex models with large iteration counts. For simple models, focus on CPU optimization or accept modest GPU speedups.

## Complete Example: All Features Combined

This realistic portfolio model demonstrates arrays, loops, and matrices working together on GPU:

```swift
let completeModel = MonteCarloExpressionModel { builder in
    // Inputs: 3 asset weights (smaller portfolio to stay within GPU limits)
    let weights = builder.array([0, 1, 2])

    // Expected returns
    let returns = builder.array([0.08, 0.10, 0.12])

    // 3×3 covariance matrix (smaller to reduce bytecode operations)
    let covariance = builder.matrix(rows: 3, cols: 3, values: [
        [0.04, 0.01, 0.015],
        [0.01, 0.0625, 0.02],
        [0.015, 0.02, 0.09]
    ])

    // 1. Portfolio return (array operation)
    let portfolioReturn = weights.dot(returns)

    // 2. Portfolio volatility (matrix operation)
    let portfolioVol = covariance.quadraticForm(weights).sqrt()

    // 3. Sharpe ratio
    let riskFreeRate = 0.03
    let sharpe = (portfolioReturn - riskFreeRate) / portfolioVol

    // 4. 5-year wealth accumulation (reduced from 10 to stay within GPU limits)
    let initialInvestment = 1_000_000.0
    let finalWealth = builder.forEach(0..<5, initial: initialInvestment) { year, wealth in
        wealth * (1.0 + portfolioReturn)
    }

    return finalWealth
}

var simulation = MonteCarloSimulation(
    iterations: 100_000,
    enableGPU: true,
    expressionModel: completeModel
)

// Add inputs for 3 asset weights
for i in 0..<3 {
    simulation.addInput(SimulationInput(
        name: "Weight\(i)",
        distribution: DistributionNormal(0.33, 0.05)  // ~33% each with variation
    ))
}

let results = try simulation.run()

print("Expected Final Wealth: \(results.statistics.mean.currency(0))")
print("95% Confidence: \(results.percentiles.p5.currency(0)) - \(results.percentiles.p95.currency(0))")
print("Executed on: \(results.usedGPU ? "GPU ⚡" : "CPU")")

// Performance: 100,000 iterations in ~0.5s on M2 Max GPU ⚡
```

This example demonstrates:
- **Array operations** for portfolio calculations
- **Matrix operations** for covariance and risk
- **Loop unrolling** for multi-period compounding
- **Mathematical expressions** for Sharpe ratio
- All running efficiently on GPU with 10-20× speedup

> **GPU Operation Limit**: Metal GPU shaders have a maximum of **128 bytecode operations**. Complex models combining matrices, loops, and arrays may exceed this limit. If you encounter `invalidInput("Number of bytecode operations must be 1-128")`, reduce complexity by:
> - Using smaller matrices (3×3 instead of 5×5)
> - Fewer loop iterations (5 years instead of 10)
> - Splitting complex models into separate simulations
> - Removing intermediate calculations where possible

## GPU Operation Limits

### Understanding the 128-Operation Limit

Metal GPU shaders have a **hard limit of 128 bytecode operations**. Each expression in your model compiles to one or more operations:

| Operation Type | Bytecode Operations | Example |
|----------------|---------------------|---------|
| Basic arithmetic (+, -, ×, ÷) | 1 | `a + b` |
| Mathematical functions | 1-2 | `sqrt()`, `exp()`, `log()` |
| Array dot product (size N) | N | `weights.dot(returns)` for 5 elements = 5 ops |
| Matrix quadratic form (N×N) | N² + N | 3×3 matrix = 12 ops |
| Loop iteration unrolled | Varies | 5 iterations × body ops |

### Example: Calculating Operation Count

```swift
let model = MonteCarloExpressionModel { builder in
    let weights = builder.array([0, 1, 2])           // 0 ops (just references)
    let returns = builder.array([0.08, 0.10, 0.12])  // 0 ops (constants)

    // Dot product: 3 multiplications + 2 additions = 5 ops
    let portfolioReturn = weights.dot(returns)        // 5 ops

    // Matrix quadratic form (3×3): ~12 ops
    let portfolioVol = covariance.quadraticForm(weights).sqrt()  // 13 ops

    // Sharpe: 2 arithmetic operations
    let sharpe = (portfolioReturn - 0.03) / portfolioVol        // 2 ops

    // 5-year loop: body has 2 ops × 5 iterations
    let finalWealth = builder.forEach(0..<5, initial: 1_000_000.0) { _, wealth in
        wealth * (1.0 + portfolioReturn)              // 2 ops × 5 = 10 ops
    }

    return finalWealth                                // 1 op
}

// Total: 5 + 13 + 2 + 10 + 1 = 31 operations ✓ Well within limit
```

### When You Exceed the Limit

If your model exceeds 128 operations, you'll see:
```
⚠️ GPU execution failed: invalidInput("Number of bytecode operations must be 1-128")
Falling back to CPU execution.
```

The simulation will still run successfully on CPU, but you'll lose the GPU speedup.

### Strategies to Reduce Operation Count

#### 1. Reduce Matrix Size

```swift
// ❌ 5×5 matrix = 30 operations for quadratic form
let covariance = builder.matrix(rows: 5, cols: 5, values: [...])

// ✓ 3×3 matrix = 12 operations for quadratic form
let covariance = builder.matrix(rows: 3, cols: 3, values: [...])
```

#### 2. Reduce Loop Iterations

```swift
// ❌ 20 years × 2 ops = 40 operations
let wealth = builder.forEach(0..<20, initial: principal) { ... }

// ✓ 5 years × 2 ops = 10 operations
let wealth = builder.forEach(0..<5, initial: principal) { ... }
```

#### 3. Split Complex Models

```swift
// Instead of one complex model with 150 operations...
let model = MonteCarloExpressionModel { builder in
    let part1 = complexCalculation1(...)  // 80 ops
    let part2 = complexCalculation2(...)  // 70 ops
    return part1 + part2  // Total: 151 ops ❌
}

// Split into two separate simulations:
let model1 = MonteCarloExpressionModel { builder in
    return complexCalculation1(...)  // 80 ops ✓
}

let model2 = MonteCarloExpressionModel { builder in
    return complexCalculation2(...)  // 70 ops ✓
}
```

#### 4. Simplify Intermediate Calculations

```swift
// ❌ Many intermediate steps
let a = x.sqrt()
let b = y.exp()
let c = a * b
let d = c / 2.0
let e = d + 1.0
return e

// ✓ Combine where possible
return (x.sqrt() * y.exp() / 2.0) + 1.0
```

### Estimating Operation Count

**Quick Estimation Formula**:
- Each array operation (size N): ~N operations
- Each matrix operation (N×N): ~N² operations
- Each loop iteration: (body operations) × (iteration count)
- Each arithmetic/math function: 1-2 operations

**Rule of Thumb**: If your model has:
- Matrix larger than 7×7, OR
- Loop with >15 iterations, OR
- Multiple matrices/loops combined

Consider testing with smaller sizes first.

## Common Pitfalls and Solutions

### Pitfall 1: Mixing Closure and Expression Models

```swift
// ❌ Wrong: Using closure syntax for GPU
var sim = MonteCarloSimulation(iterations: 100_000) { inputs in
    return inputs[0] + inputs[1]  // Runs on CPU only!
}
```

**Solution**: Use `MonteCarloExpressionModel` for GPU:
```swift
// ✓ Correct: Expression model for GPU
let model = MonteCarloExpressionModel { builder in
    return builder[0] + builder[1]
}

var sim = MonteCarloSimulation(
    iterations: 100_000,
    enableGPU: true,
    expressionModel: model
)
```

### Pitfall 2: Calling External Functions

```swift
// ❌ Wrong: Calling Swift functions
let model = MonteCarloExpressionModel { builder in
    return myComplexCalculation(builder[0])  // Won't compile to GPU!
}
```

**Solution**: Use `ExpressionFunction`:
```swift
// ✓ Correct: Define as expression function
let myComplexCalculation = ExpressionFunction(inputs: 1) { builder in
    let x = builder[0]
    return x * x + x.sqrt()
}

let model = MonteCarloExpressionModel { builder in
    return myComplexCalculation.call(builder[0])  // Compiles to GPU!
}
```

### Pitfall 3: Dynamic Array Sizes

```swift
// ❌ Wrong: Runtime-determined array size
let model = MonteCarloExpressionModel { builder in
    let size = Int(builder[0])
    let arr = builder.array((0..<size).map { $0 })  // Runtime error!
    return arr.sum()
}
```

**Solution**: Use compile-time constant sizes:
```swift
// ✓ Correct: Fixed size known at compile time
let model = MonteCarloExpressionModel { builder in
    let arr = builder.array([0, 1, 2, 3, 4])  // Fixed size
    return arr.sum()
}
```

## Decision Tree: GPU vs CPU

Use this decision tree to choose the right approach:

```
Is your model complex (10+ operations)?
├─ Yes: Use GPU (expect 5-20× speedup)
│   └─ Can you express it without closures?
│       ├─ Yes: Use MonteCarloExpressionModel
│       └─ No: Consider refactoring or use CPU
│
└─ No (simple model):
    └─ Is iteration count > 100K?
        ├─ Yes: Try GPU (expect 2-3× speedup)
        └─ No: Use CPU (GPU overhead not worth it)
```

## See Also

 <doc:4.3-MonteCarloExpressionModelsGuide> - Complete guide to expression model syntax
 <doc:4.1-MonteCarloTimeSeriesGuide> - Time series forecasting with Monte Carlo
 <doc:4.2-ScenarioAnalysisGuide> - Scenario-based planning and analysis

## Additional Resources

For more detailed tutorials and examples:
- **Blog Post**: "GPU-Accelerated Monte Carlo: Expression Models and Performance" (Week 6, Day 2)
- **Playground**: `Week06/GPU-MonteCarlo.playground` - Interactive examples
- **Source**: Content adapted from BusinessMath blog series

> **Note**: This guide consolidates performance best practices and GPU acceleration techniques from the BusinessMath blog series. For step-by-step tutorials with visual examples, see [the complete blog posts.](https://justinpurnell.com/BusinessMath)
