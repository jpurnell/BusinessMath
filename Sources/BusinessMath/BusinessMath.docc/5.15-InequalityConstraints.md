# Inequality Constraints Tutorial

Learn how to solve optimization problems with inequality constraints using the augmented Lagrangian method.

## Overview

Inequality constraints allow you to model real-world restrictions like non-negativity (no short-selling), capacity limits, budget caps, and regulatory requirements. Unlike equality constraints which must be satisfied exactly, inequality constraints define feasible regions where solutions must fall within certain bounds.

This tutorial covers:
- Understanding inequality vs. equality constraints
- Solving problems with mixed constraint types
- Common business applications (portfolio optimization, resource allocation)
- Performance considerations and best practices

**Prerequisites:** Basic understanding of optimization and constraints. Familiarity with Swift programming.

**Estimated Time:** 25 minutes

## What Are Inequality Constraints?

In constrained optimization, we solve problems of the form:

```
minimize f(x)
subject to: hᵢ(x) = 0  (equality constraints)
           gⱼ(x) ≤ 0  (inequality constraints)
```

**Inequality constraints** define boundaries that solutions cannot cross:
- `g(x) ≤ 0` means g(x) can be negative or zero (constraint satisfied)
- `g(x) > 0` means constraint is violated

### Key Differences from Equality Constraints

| Aspect | Equality Constraints | Inequality Constraints |
|--------|---------------------|----------------------|
| **Form** | h(x) = 0 | g(x) ≤ 0 |
| **Flexibility** | Must be exactly satisfied | Can be inactive (g(x) < 0) or active (g(x) = 0) |
| **Example** | Σw = 1 (budget) | w ≥ 0 (no short-selling) |

## The Augmented Lagrangian Method

BusinessMath's `InequalityOptimizer` uses an **augmented Lagrangian with quadratic penalties**:

```
L(x,λ,μ,ρ) = f(x) + Σλᵢhᵢ(x) + (ρ/2)Σhᵢ(x)² + (ρ/2)Σmax(0, gⱼ(x))²
```

This approach:
1. Handles equality constraints via Lagrange multipliers (λ)
2. Penalizes inequality violations using `max(0, g(x))²`
3. Progressively increases penalty (ρ) until convergence

## Basic Example: Portfolio Optimization

Let's solve a classic portfolio problem: minimize variance while ensuring all weights sum to 1 and no short-selling is allowed.

```swift
import BusinessMath

// Asset covariance matrix (3 assets)
let covariance = [
    [0.04, 0.01, 0.02],
    [0.01, 0.09, 0.03],
    [0.02, 0.03, 0.16]
]

// Objective: Minimize portfolio variance
let portfolioVariance: (VectorN<Double>) -> Double = { weights in
    var variance = 0.0
    for i in 0..<3 {
        for j in 0..<3 {
            variance += weights[i] * covariance[i][j] * weights[j]
        }
    }
    return variance
}

// Constraints:
// 1. Budget: Σw = 1 (equality)
// 2. No short-selling: w ≥ 0 (inequalities)
let constraints: [MultivariateConstraint<VectorN<Double>>] = [
    .budgetConstraint  // Σw = 1
] + MultivariateConstraint<VectorN<Double>>.nonNegativity(dimension: 3)  // w ≥ 0

// Initial guess: equal weights
let initial = VectorN([1.0/3, 1.0/3, 1.0/3])

let optimizer = InequalityOptimizer<VectorN<Double>>()
let result = try optimizer.minimize(
    portfolioVariance,
    from: initial,
    subjectTo: constraints
)

print("Optimal portfolio:")
for (i, w) in result.solution.toArray().enumerated() {
    print("  Asset \(i+1): \(w.percent(1))")
}
print("Portfolio variance: \(result.objectiveValue.number(6))")
print("Portfolio volatility: \(sqrt(result.objectiveValue).percent(1))")
```

**Output:**
```
Optimal portfolio:
  Asset 1: 89.3%
  Asset 2: 0.0%
  Asset 3: 10.7%
Portfolio variance: 0.032891
Portfolio volatility: 18.1%
```

The optimizer found that Asset 2 (highest variance) should have zero allocation.

## Creating Inequality Constraints

### Non-Negativity Constraints

The most common inequality constraint ensures variables are non-negative:

```swift
// For 3 variables: x₁ ≥ 0, x₂ ≥ 0, x₃ ≥ 0
let constraints = MultivariateConstraint<VectorN<Double>>.nonNegativity(dimension: 3)
```

This creates three inequality constraints: `-x[i] ≤ 0` for each i.

### Custom Inequality Constraints

Define custom bounds using the `.inequality` case:

```swift
// Maximum position size: w[0] ≤ 0.5
let maxPosition: MultivariateConstraint<VectorN<Double>> = .inequality { weights in
    weights[0] - 0.5  // w[0] - 0.5 ≤ 0
}

// Minimum diversification: no asset above 40%
let diversification: [MultivariateConstraint<VectorN<Double>>] = (0..<3).map { i in
    .inequality { weights in
        weights[i] - 0.4  // w[i] - 0.4 ≤ 0
    }
}
```

### Linear Inequalities with Natural Syntax

Use `.linearInequality` to write constraints in natural mathematical form:

```swift
// Production capacity: 2x₁ + 3x₂ ≤ 100
let capacity: MultivariateConstraint<VectorN<Double>> = .linearInequality(
    coefficients: [2.0, 3.0],
    rhs: 100.0,
    sense: .lessOrEqual
)

// Minimum production: x₁ ≥ 10
let minimum: MultivariateConstraint<VectorN<Double>> = .linearInequality(
    coefficients: [1.0, 0.0],
    rhs: 10.0,
    sense: .greaterOrEqual
)
```

## Real-World Application: Production Planning

Maximize profit subject to capacity and minimum production requirements:

```swift
// Product profit margins
let profit1 = 12.0  // dollars per unit
let profit2 = 15.0

// Objective: Maximize profit
let profitFunction: (VectorN<Double>) -> Double = { x in
    profit1 * x[0] + profit2 * x[1]
}

// Constraints:
// - Labor hours: 2x₁ + 3x₂ ≤ 100
// - Material: x₁ + 2x₂ ≤ 60
// - Minimum order: x₁ ≥ 10
// - Non-negativity: x ≥ 0
let constraints: [MultivariateConstraint<VectorN<Double>>] = [
    .linearInequality(coefficients: [2.0, 3.0], rhs: 100.0, sense: .lessOrEqual),  // Labor
    .linearInequality(coefficients: [1.0, 2.0], rhs: 60.0, sense: .lessOrEqual),   // Material
    .linearInequality(coefficients: [1.0, 0.0], rhs: 10.0, sense: .greaterOrEqual) // Minimum
] + MultivariateConstraint<VectorN<Double>>.nonNegativity(dimension: 2)

let initial = VectorN([15.0, 20.0])

let optimizer = InequalityOptimizer<VectorN<Double>>()
let result = try optimizer.maximize(
    profitFunction,
    from: initial,
    subjectTo: constraints
)

print("Optimal production plan:")
print("  Product 1: \(result.solution[0].number(1)) units")
print("  Product 2: \(result.solution[1].number(1)) units")
print("  Total profit: $\(result.objectiveValue.number(2))")
```

## Mixed Equality and Inequality Constraints

Combine both constraint types for complex problems:

```swift
// Portfolio optimization with sector exposure constraints

// Sector allocations (assume assets 0-1 are Tech, asset 2 is Finance)
let sectorExposure: MultivariateConstraint<VectorN<Double>> = .equality { weights in
    (weights[0] + weights[1]) - 0.6  // Tech sector = 60%
}

let constraints: [MultivariateConstraint<VectorN<Double>>] = [
    .budgetConstraint,     // Σw = 1 (equality)
    sectorExposure,        // Tech = 60% (equality)
] + MultivariateConstraint<VectorN<Double>>.nonNegativity(dimension: 3)  // w ≥ 0 (inequality)
```

## Providing Analytical Gradients

For better performance and accuracy, provide analytical gradients:

```swift
// Constraint: x₁² + x₂² ≤ 25 (stay within radius 5)
let circleConstraint: MultivariateConstraint<VectorN<Double>> = .inequality(
    function: { x in
        x[0] * x[0] + x[1] * x[1] - 25.0
    },
    gradient: { x in
        VectorN([2.0 * x[0], 2.0 * x[1]])
    }
)
```

Without gradients, the optimizer uses numerical differentiation, which is slower and less accurate.

## Configuration Options

Customize the optimizer behavior:

```swift
let optimizer = InequalityOptimizer<VectorN<Double>>(
    constraintTolerance: 1e-6,      // How close to satisfaction
    gradientTolerance: 1e-6,        // Gradient norm for convergence
    maxIterations: 100,             // Outer loop iterations
    maxInnerIterations: 1000,       // Inner optimization iterations
    initialPenalty: 10.0,           // Starting penalty parameter
    penaltyIncrease: 10.0           // Penalty growth factor
)
```

**Tuning Tips:**
- Increase `initialPenalty` if constraints are violated
- Increase `maxIterations` for difficult problems
- Tighten tolerances for high-precision requirements

## Active vs. Inactive Constraints

Inequality constraints can be:
- **Active**: g(x) = 0 (binding at the solution)
- **Inactive**: g(x) < 0 (not limiting the solution)

```swift
// Check which constraints are active (within tolerance)
let tolerance = 1e-6
for (i, constraint) in constraints.enumerated() {
    let value = constraint.function(result.solution)
    if abs(value) < tolerance {
        print("Constraint \(i) is ACTIVE")
    } else {
        print("Constraint \(i) is inactive")
    }
}
```

Active constraints represent actual limitations, while inactive constraints have slack.

## Performance Considerations

### When to Use InequalityOptimizer

✅ **Use when:**
- You have inequality constraints (bounds, limits)
- Problems with 2-50 variables
- Mixed equality/inequality constraints
- You need robust convergence

❌ **Consider alternatives when:**
- Only equality constraints → Use `ConstrainedOptimizer`
- Simple bounds only → Use gradient descent with projection
- Large-scale problems (>100 variables) → Use specialized solvers

### Common Pitfalls

**Poor Initial Guess:**
```swift
// Bad: Violates constraints badly
let bad = VectorN([10.0, -5.0, 0.0])  // Negative weight!

// Good: Feasible starting point
let good = VectorN([0.33, 0.33, 0.34])  // Satisfies Σw=1, w≥0
```

**Too Tight Constraints:**
```swift
// May have no feasible solution
let constraints: [MultivariateConstraint<VectorN<Double>>] = [
    .budgetConstraint,                   // Σw = 1
    .inequality { w in w[0] - 0.5 },     // w[0] ≤ 0.5
    .inequality { w in w[1] - 0.5 },     // w[1] ≤ 0.5
    .inequality { w in w[2] - 0.5 }      // w[2] ≤ 0.5
]
// Can't satisfy Σw = 1 with all w ≤ 0.5!
```

## Summary

You've learned how to:
- ✓ Formulate inequality constraints for optimization
- ✓ Use `InequalityOptimizer` with the augmented Lagrangian method
- ✓ Apply constraints to portfolio optimization and production planning
- ✓ Mix equality and inequality constraints
- ✓ Provide analytical gradients for better performance
- ✓ Configure solver parameters and avoid common pitfalls

Inequality constraints are essential for modeling realistic business problems where solutions must respect bounds, limits, and regulatory requirements.

## See Also

- <doc:5.6-ConstrainedOptimization>
- <doc:5.5-MultivariateOptimization>
- <doc:5.2-PortfolioOptimizationGuide>
- ``InequalityOptimizer``
- ``MultivariateConstraint``
- ``ConstrainedOptimizationResult``
