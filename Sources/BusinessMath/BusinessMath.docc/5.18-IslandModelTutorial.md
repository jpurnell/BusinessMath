# Island Model Genetic Algorithm Tutorial

Complete guide to using the Island Model for distributed genetic algorithm optimization in BusinessMath.

## Table of Contents

- [Quick Start](#quick-start)
- [What is the Island Model?](#what-is-the-island-model)
- [Choosing a Migration Topology](#choosing-a-migration-topology)
- [Parameter Tuning](#parameter-tuning)
- [Real-World Examples](#real-world-examples)
- [GPU Acceleration](#gpu-acceleration)
- [Performance Comparison](#performance-comparison)
- [Troubleshooting](#troubleshooting)

## Quick Start

Copy this into an Xcode Playground to get started immediately:

```swift
import BusinessMath

// Configure individual GAs for each island
let gaConfig = GeneticAlgorithmConfig(
    populationSize: 50,
    generations: 50
)

// Configure island model
let islandConfig = IslandModelConfig.default  // 4 islands, ring topology

// Create optimizer
let optimizer = IslandModel<VectorN<Double>>(
    gaConfig: gaConfig,
    islandConfig: islandConfig,
    searchSpace: [(-10.0, 10.0), (-10.0, 10.0)]
)

// Minimize Rosenbrock function
let rosenbrock = { (v: VectorN<Double>) -> Double in
    let x = v[0], y = v[1]
    return (1.0 - x) * (1.0 - x) + 100.0 * (y - x * x) * (y - x * x)
}

let result = try! optimizer.minimize(rosenbrock, from: VectorN([0.0, 0.0]))

print("Solution: [\(result.solution[0]), \(result.solution[1])]")
print("Objective value: \(result.value)")
// Solution: [0.98, 0.96]
// Objective value: 0.002
```

## What is the Island Model?

The Island Model is a distributed variant of genetic algorithms where multiple independent populations (islands) evolve in parallel. Periodically, elite individuals migrate between islands according to a topology, combining:

- **Diversity**: Multiple populations explore different regions
- **Parallelization**: Islands evolve independently (GPU-friendly)
- **Robustness**: Less likely to get stuck in local optima

### How It Works

1. **Initialization**: Create N independent island populations
2. **Evolution**: Each island runs its own GA independently
3. **Migration**: Periodically exchange elite individuals between islands
4. **Selection**: Return best solution across all islands

### Key Advantages

- Better exploration through population diversity
- Natural parallelization (each island independent)
- More robust than single-population GA
- Automatically inherits GPU acceleration from GA
- Escapes local optima more effectively

### When to Use Island Model

Use Island Model when:
- Problem has many local optima (multimodal)
- Standard GA converges prematurely
- You want more robust optimization
- You have computational resources for multiple populations
- You can benefit from GPU acceleration (1000+ pop/island)

## Choosing a Migration Topology

The topology determines how individuals move between islands:

### Ring Topology (Default)

**Best for**: Gradual information diffusion, maintaining diversity

```swift
import BusinessMath

let gaConfig = GeneticAlgorithmConfig(
    populationSize: 60,
    generations: 50
)

let islandConfig = IslandModelConfig(
    numberOfIslands: 4,
    migrationInterval: 10,  // Migrate every 10 generations
    migrationSize: 2,        // 2 elite individuals migrate
    topology: .ring          // Island i → Island i+1
)

let optimizer = IslandModel<VectorN<Double>>(
    gaConfig: gaConfig,
    islandConfig: islandConfig,
    searchSpace: [(-5.0, 5.0), (-5.0, 5.0)]
)

// Rastrigin: highly multimodal, benefits from diversity
let rastrigin = { (v: VectorN<Double>) -> Double in
    let A = 10.0
    var sum = A * 2.0
    for i in 0..<2 {
        let xi = v[i]
        sum += xi * xi - A * cos(2.0 * .pi * xi)
    }
    return sum
}

let result = try! optimizer.minimize(rastrigin, from: VectorN([0.0, 0.0]))
print("Ring topology result: \(result.value.number(3))")
```

### Fully Connected Topology

**Best for**: Fast convergence, aggressive information sharing

```swift
import BusinessMath

let gaConfig = GeneticAlgorithmConfig(
    populationSize: 60,
    generations: 50,
    seed: 42
)

let islandConfig = IslandModelConfig(
    numberOfIslands: 5,
    migrationInterval: 15,
    migrationSize: 3,
    topology: .fullyConnected  // All islands exchange with all others
)

let optimizer = IslandModel<VectorN<Double>>(
    gaConfig: gaConfig,
    islandConfig: islandConfig,
    searchSpace: [(-10.0, 10.0), (-10.0, 10.0)]
)

// Sphere: unimodal, benefits from fast convergence
let sphere = { (v: VectorN<Double>) -> Double in v.dot(v) }

let result = try! optimizer.minimize(sphere, from: VectorN([5.0, 5.0]))
print("Fully connected result: \(result.value.number(3))")
```

### Random Topology

**Best for**: Unpredictable connectivity, maximum diversity

```swift
import BusinessMath

let gaConfig = GeneticAlgorithmConfig(
    populationSize: 60,
    generations: 50,
    seed: 42
)

let islandConfig = IslandModelConfig(
    numberOfIslands: 6,
    migrationInterval: 12,
    migrationSize: 2,
    topology: .random  // Random connections each migration
)

let optimizer = IslandModel<VectorN<Double>>(
    gaConfig: gaConfig,
    islandConfig: islandConfig,
    searchSpace: [(-5.0, 5.0), (-5.0, 5.0)]
)

// Ackley: many local minima, needs exploration
let ackley = { (v: VectorN<Double>) -> Double in
    let x = v[0], y = v[1]
    let sum1 = x * x + y * y
    let sum2 = cos(2.0 * .pi * x) + cos(2.0 * .pi * y)
    return -20.0 * exp(-0.2 * sqrt(sum1 / 2.0)) - exp(sum2 / 2.0) + 20.0 + exp(1.0)
}

let result = try! optimizer.minimize(ackley, from: VectorN([0.0, 0.0]))
print("Random topology result: \(result.value)")
```

## Parameter Tuning

### Number of Islands

More islands = more diversity, but more computation:

```swift
import BusinessMath

let gaConfig = GeneticAlgorithmConfig(
    populationSize: 50,
    generations: 40,
    seed: 42
)

// Few islands: Fast, good for simple problems
let fewIslands = IslandModelConfig(
    numberOfIslands: 3,
    migrationInterval: 10,
    migrationSize: 2,
    topology: .ring
)

// Many islands: Better exploration, more computation
let manyIslands = IslandModelConfig(
    numberOfIslands: 8,
    migrationInterval: 10,
    migrationSize: 2,
    topology: .fullyConnected
)

let searchSpace = [(-10.0, 10.0), (-10.0, 10.0)]
let rosenbrock = { (v: VectorN<Double>) -> Double in
    let x = v[0], y = v[1]
    return (1.0 - x) * (1.0 - x) + 100.0 * (y - x * x) * (y - x * x)
}

let opt1 = IslandModel<VectorN<Double>>(
    gaConfig: gaConfig,
    islandConfig: fewIslands,
    searchSpace: searchSpace
)
let result1 = try! opt1.minimize(rosenbrock, from: VectorN([0.0, 0.0]))

let opt2 = IslandModel<VectorN<Double>>(
    gaConfig: gaConfig,
    islandConfig: manyIslands,
    searchSpace: searchSpace
)
let result2 = try! opt2.minimize(rosenbrock, from: VectorN([0.0, 0.0]))

print("3 islands: \(result1.value)")
print("8 islands: \(result2.value)")
```

### Migration Interval

Controls how often islands exchange individuals:

```swift
import BusinessMath

let gaConfig = GeneticAlgorithmConfig(
    populationSize: 50,
    generations: 60,
    seed: 42
)

// Frequent migration: Fast information sharing
let frequentConfig = IslandModelConfig(
    numberOfIslands: 4,
    migrationInterval: 5,   // Every 5 generations
    migrationSize: 3,
    topology: .fullyConnected
)

// Infrequent migration: More independent exploration
let infrequentConfig = IslandModelConfig(
    numberOfIslands: 4,
    migrationInterval: 30,  // Every 30 generations
    migrationSize: 3,
    topology: .ring
)

let searchSpace = [(-5.0, 5.0), (-5.0, 5.0)]
let sphere = { (v: VectorN<Double>) -> Double in v.dot(v) }

let freqOpt = IslandModel<VectorN<Double>>(
    gaConfig: gaConfig,
    islandConfig: frequentConfig,
    searchSpace: searchSpace
)
let freqResult = try! freqOpt.minimize(sphere, from: VectorN([3.0, 3.0]))

let infreqOpt = IslandModel<VectorN<Double>>(
    gaConfig: gaConfig,
    islandConfig: infrequentConfig,
    searchSpace: searchSpace
)
let infreqResult = try! infreqOpt.minimize(sphere, from: VectorN([3.0, 3.0]))

print("Frequent migration (interval=5): \(freqResult.value)")
print("Infrequent migration (interval=30): \(infreqResult.value)")
```

### Migration Size

Number of elite individuals to exchange:

```swift
import BusinessMath

let gaConfig = GeneticAlgorithmConfig(
    populationSize: 100,
    generations: 50,
    seed: 42
)

// Small migration: Preserves diversity
let smallMigration = IslandModelConfig(
    numberOfIslands: 4,
    migrationInterval: 10,
    migrationSize: 1,  // Just 1 elite
    topology: .ring
)

// Large migration: Faster convergence
let largeMigration = IslandModelConfig(
    numberOfIslands: 4,
    migrationInterval: 10,
    migrationSize: 5,  // 5 elites (5% of population)
    topology: .ring
)

let searchSpace = [(-10.0, 10.0), (-10.0, 10.0)]
let rosenbrock = { (v: VectorN<Double>) -> Double in
    let x = v[0], y = v[1]
    return (1.0 - x) * (1.0 - x) + 100.0 * (y - x * x) * (y - x * x)
}

let smallOpt = IslandModel<VectorN<Double>>(
    gaConfig: gaConfig,
    islandConfig: smallMigration,
    searchSpace: searchSpace
)
let smallResult = try! smallOpt.minimize(rosenbrock, from: VectorN([0.0, 0.0]))

let largeOpt = IslandModel<VectorN<Double>>(
    gaConfig: gaConfig,
    islandConfig: largeMigration,
    searchSpace: searchSpace
)
let largeResult = try! largeOpt.minimize(rosenbrock, from: VectorN([0.0, 0.0]))

print("Small migration (1 elite): \(smallResult.value)")
print("Large migration (5 elites): \(largeResult.value)")
```

## Real-World Examples

### Example 1: Traveling Salesman Problem (Continuous Relaxation)

Optimize tour through cities (using continuous coordinates):

```swift
import BusinessMath

// City coordinates
let cities = [
    (0.0, 0.0),
    (1.0, 5.0),
    (5.0, 2.0),
    (6.0, 6.0),
    (8.0, 3.0)
]

// Encode tour as permutation weights (continuous)
let optimizer = IslandModel<VectorN<Double>>(
    gaConfig: GeneticAlgorithmConfig(
        populationSize: 80,
        generations: 100,
        mutationRate: 0.2,
        seed: 42
    ),
    islandConfig: IslandModelConfig(
        numberOfIslands: 5,
        migrationInterval: 15,
        migrationSize: 3,
        topology: .fullyConnected
    ),
    searchSpace: Array(repeating: (0.0, 1.0), count: cities.count)
)

// Tour distance (using continuous encoding)
let tourDistance = { (weights: VectorN<Double>) -> Double in
    let w = weights.toArray()

    // Convert continuous weights to permutation
    let indices = w.enumerated().sorted { $0.element < $1.element }.map { $0.offset }

    // Calculate tour distance
    var distance = 0.0
    for i in 0..<indices.count {
        let from = indices[i]
        let to = indices[(i + 1) % indices.count]

        let dx = cities[to].0 - cities[from].0
        let dy = cities[to].1 - cities[from].1
        distance += sqrt(dx * dx + dy * dy)
    }

    return distance
}

let result = try! optimizer.minimize(tourDistance, from: VectorN(Array(repeating: 0.5, count: cities.count)))

print("Best tour distance: \(String(format: "%.2f", result.value))")

// Decode tour
let weights = result.solution.toArray()
let tour = weights.enumerated().sorted { $0.element < $1.element }.map { $0.offset }
print("Tour order: \(tour)")
```

### Example 2: Feature Selection for Machine Learning

Select optimal subset of features:

```swift
import BusinessMath

// Simulate feature selection: 10 features, select best subset
let optimizer = IslandModel<VectorN<Double>>(
    gaConfig: GeneticAlgorithmConfig(
        populationSize: 60,
        generations: 80,
        mutationRate: 0.15,
        seed: 42
    ),
    islandConfig: IslandModelConfig(
        numberOfIslands: 4,
        migrationInterval: 12,
        migrationSize: 2,
        topology: .ring
    ),
    searchSpace: Array(repeating: (0.0, 1.0), count: 10)  // 10 features
)

// Simplified feature quality scores (real would use cross-validation)
let featureScores = [0.8, 0.3, 0.9, 0.2, 0.7, 0.4, 0.85, 0.6, 0.5, 0.75]

// Objective: Maximize model performance - feature cost
let featureObjective = { (selection: VectorN<Double>) -> Double in
    let features = selection.toArray()

    // Threshold: > 0.5 means feature is selected
    var performance = 0.0
    var cost = 0.0

    for (i, value) in features.enumerated() {
        if value > 0.5 {
            performance += featureScores[i]
            cost += 0.1  // Each feature adds cost
        }
    }

    // Want high performance, low cost
    return -(performance - cost)  // Minimize negative
}

let result = try! optimizer.minimize(featureObjective, from: VectorN(Array(repeating: 0.5, count: 10)))

print("Feature selection results:")
let selected = result.solution.toArray()
for (i, value) in selected.enumerated() {
    if value > 0.5 {
        print("  Feature \(i): SELECTED (score: \(featureScores[i]))")
    }
}
print("Objective: \(String(format: "%.3f", result.value))")
```

### Example 3: Multi-Objective Portfolio Optimization

Balance return, risk, and diversification:

```swift
import BusinessMath

// 5 assets portfolio
let optimizer = IslandModel<VectorN<Double>>(
	gaConfig: GeneticAlgorithmConfig(
		populationSize: 100,
		generations: 100,
		crossoverRate: 0.85,
		mutationRate: 0.1,
		seed: 42
	),
	islandConfig: IslandModelConfig(
		numberOfIslands: 6,
		migrationInterval: 15,
		migrationSize: 4,
		topology: .fullyConnected
	),
	searchSpace: Array(repeating: (0.0, 1.0), count: 5)
)

// Asset parameters
let expectedReturns = [0.12, 0.15, 0.08, 0.18, 0.10]
let volatilities = [0.20, 0.30, 0.15, 0.35, 0.18]
let riskFreeRate = 0.03

// Multi-objective: maximize Sharpe ratio + diversification
let portfolioObjective = { (weights: VectorN<Double>) -> Double in
	let w = weights.toArray()

	// Normalize weights
	let sum = w.reduce(0.0, +)
	let normalized = w.map { $0 / (sum + 1e-10) }

	// Portfolio return
	let portfolioReturn = zip(normalized, expectedReturns).map(*).reduce(0.0, +)

	// Portfolio risk (simplified)
	let portfolioRisk = sqrt(zip(normalized, volatilities).map { $0 * $0 * $1 * $1 }.reduce(0.0, +))

	// Sharpe ratio
	let sharpe = (portfolioReturn - riskFreeRate) / (portfolioRisk + 1e-10)

	// Diversification (entropy)
	let diversification = -normalized.map { x in
		x > 0 ? x * log(x + 1e-10) : 0.0
	}.reduce(0.0, +)

	// Combined objective (maximize both)
	return -(sharpe + 0.5 * diversification)
}

// Constraint: weights sum to 1
let weightConstraint = MultivariateConstraint<VectorN<Double>>.equality { w in
	w.toArray().reduce(0.0, +) - 1.0
}

let result = try! optimizer.minimize(
	portfolioObjective,
	from: VectorN(Array(repeating: 0.2, count: 5)),
	constraints: [weightConstraint]
)

print("Optimal portfolio:")
let weights = result.solution.toArray()
let sum = weights.reduce(0.0, +)
for (i, w) in weights.enumerated() {
	print("  Asset \(i+1): \((w/sum).percent())")
}

// Calculate final metrics
let normalized = weights.map { $0 / sum }
let portReturn = zip(normalized, expectedReturns).map(*).reduce(0.0, +)
let portRisk = sqrt(zip(normalized, volatilities).map { $0 * $0 * $1 * $1 }.reduce(0.0, +))
let sharpe = (portReturn - riskFreeRate) / portRisk

print("Expected return: \(portReturn.percent(1))")
print("Risk (volatility): \(portRisk.percent(1))")
print("Sharpe ratio: \(sharpe.number(3))")
```

### Example 4: Engineering Design Optimization

Optimize truss structure for minimum weight with stress constraints:

```swift
import BusinessMath

// 4-member truss: optimize cross-sectional areas
let optimizer = IslandModel<VectorN<Double>>(
	gaConfig: GeneticAlgorithmConfig(
		populationSize: 80,
		generations: 120,
		mutationRate: 0.12,
		seed: 42
	),
	islandConfig: IslandModelConfig(
		numberOfIslands: 5,
		migrationInterval: 20,
		migrationSize: 3,
		topology: .ring
	),
	searchSpace: Array(repeating: (100.0, 5000.0), count: 4)  // mm² cross-sections
)

// Material and load properties
let density = 7850.0  // kg/m³ (steel)
let E = 200e9         // Pa (Young's modulus)
let maxStress = 250e6 // Pa (allowable stress)
let appliedLoad = 50000.0  // N

let memberLengths = [2.0, 2.0, 2.83, 2.83]  // m

// Objective: Minimize weight
let structureWeight = { (areas: VectorN<Double>) -> Double in
	let A = areas.toArray().map { $0 / 1e6 }  // Convert mm² to m²

	var weight = 0.0
	for i in 0..<4 {
		weight += density * A[i] * memberLengths[i]
	}

	return weight  // kg
}

// Constraint: No member exceeds stress limit (simplified)
let stressConstraint = MultivariateConstraint<VectorN<Double>>.inequality { areas in
	let A = areas.toArray().map { $0 / 1e6 }

	// Simplified stress calculation
	var maxMemberStress = 0.0
	for i in 0..<4 {
		let force = appliedLoad / 4.0  // Simplified load distribution
		let stress = force / A[i]
		maxMemberStress = max(maxMemberStress, stress)
	}

	return maxMemberStress - maxStress  // stress ≤ maxStress
}

let result = try! optimizer.minimize(
	structureWeight,
	from: VectorN([1000.0, 1000.0, 1000.0, 1000.0]),
	constraints: [stressConstraint]
)

print("Optimal truss design:")
for (i, area) in result.solution.toArray().enumerated() {
	print("  Member \(i+1): \(area.number(0)) mm²")
}
print("Total weight: \(result.value.number(2)) kg")
```

## GPU Acceleration

The Island Model automatically inherits GPU acceleration from the underlying `GeneticAlgorithm` implementation:

### Enabling GPU Acceleration

```swift
import BusinessMath

// Each island with population ≥ 1000 uses GPU
let gpuConfig = GeneticAlgorithmConfig.highPerformance  // 1000 pop

let islandConfig = IslandModelConfig(
	numberOfIslands: 4,      // 4 islands
	migrationInterval: 20,
	migrationSize: 5,
	topology: .fullyConnected
)

let optimizer = IslandModel<VectorN<Double>>(
	gaConfig: gpuConfig,     // Each island: 1000 individuals (GPU)
	islandConfig: islandConfig,
	searchSpace: Array(repeating: (-5.0, 5.0), count: 10)
)

// Total: 4 islands × 1000 = 4000 individuals
// Each island runs GPU-accelerated GA independently

let sphere = { (v: VectorN<Double>) -> Double in v.dot(v) }
let result = try! optimizer.minimize(sphere, from: VectorN(Array(repeating: 2.0, count: 10)))

print("GPU-accelerated island model result: \(result.value)")
print("Total evaluations: \(result.iterations)")
```

### Checking GPU Status

```swift
import BusinessMath

#if canImport(Metal)
import Metal

if let device = MTLCreateSystemDefaultDevice() {
    print("GPU available: \(device.name)")
    print("Each island with population ≥ 1000 will use GPU")
} else {
    print("GPU not available - islands will use CPU")
}
#else
print("Metal not supported on this platform")
#endif

// Works regardless of GPU availability
let optimizer = IslandModel<VectorN<Double>>(
    gaConfig: .highPerformance,
    islandConfig: .highPerformance,
    searchSpace: [(-5.0, 5.0)]
)

let simple = { (v: VectorN<Double>) -> Double in v[0] * v[0] }
let result = try! optimizer.minimize(simple, from: VectorN([2.0]))
print("Result: \(result.value)")
```

### Optimal GPU Configuration

```swift
import BusinessMath

// Maximize GPU utilization
let gpuGA = GeneticAlgorithmConfig(
	populationSize: 2000,  // Large population per island
	generations: 100,
	seed: 42
)

let gpuIslands = IslandModelConfig(
	numberOfIslands: 4,     // 4 islands = 8000 total individuals
	migrationInterval: 25,
	migrationSize: 10,      // 0.5% migration
	topology: .fullyConnected
)

let optimizer = IslandModel<VectorN<Double>>(
	gaConfig: gpuGA,
	islandConfig: gpuIslands,
	searchSpace: Array(repeating: (-10.0, 10.0), count: 20)  // 20D problem
)

let highdim = { (v: VectorN<Double>) -> Double in v.dot(v) }
let result = try! optimizer.optimizeDetailed(objective: highdim)

print("High-dimensional optimization:")
print("  Best value: \(result.bestFitness)")
print("  Total evaluations: \(result.generations)")
print("  Best island: \(result.bestIslandIndex)")
```

## Performance Comparison

### Island Analysis

```swift
import BusinessMath

let gaConfig = GeneticAlgorithmConfig(
	populationSize: 60,
	generations: 50,
	seed: 42
)

let islandConfig = IslandModelConfig(
	numberOfIslands: 5,
	migrationInterval: 10,
	migrationSize: 2,
	topology: .ring
)

let optimizer = IslandModel<VectorN<Double>>(
	gaConfig: gaConfig,
	islandConfig: islandConfig,
	searchSpace: [(-5.0, 5.0), (-5.0, 5.0)]
)

let rosenbrock = { (v: VectorN<Double>) -> Double in
	let x = v[0], y = v[1]
	return (1.0 - x) * (1.0 - x) + 100.0 * (y - x * x) * (y - x * x)
}

let result = try! optimizer.optimizeDetailed(objective: rosenbrock)

print("Island Model Analysis:")
print("  Number of islands: \(result.islandFitnesses.count)")
print("  Best island: \(result.bestIslandIndex)")
print("  Best fitness: \(result.bestFitness.number(6))")
print("  Migrations performed: \(result.migrationCount)")
print("\nIndividual island fitnesses:")
for (i, fitness) in result.islandFitnesses.enumerated() {
	let marker = i == result.bestIslandIndex ? " ⭐" : ""
	print("  Island \(i): \(fitness.number(6))\(marker)")
}
```

### Single GA vs Island Model

```swift
import BusinessMath
import Foundation

let searchSpace = [(-5.0, 5.0), (-5.0, 5.0)]
let rosenbrock = { (v: VectorN<Double>) -> Double in
    let x = v[0], y = v[1]
    return (1.0 - x) * (1.0 - x) + 100.0 * (y - x * x) * (y - x * x)
}

// Single large GA
let singleGA = GeneticAlgorithm<VectorN<Double>>(
    config: GeneticAlgorithmConfig(
        populationSize: 200,  // Same total evaluations
        generations: 50,
        seed: 42
    ),
    searchSpace: searchSpace
)

let singleStart = Date()
let singleResult = try! singleGA.minimize(rosenbrock, from: VectorN([0.0, 0.0]))
let singleTime = Date().timeIntervalSince(singleStart)

// Island model: 4 islands × 50 pop = 200 total
let islandModel = IslandModel<VectorN<Double>>(
    gaConfig: GeneticAlgorithmConfig(
        populationSize: 50,
        generations: 50,
        seed: 42
    ),
    islandConfig: IslandModelConfig(
        numberOfIslands: 4,
        migrationInterval: 10,
        migrationSize: 2,
        topology: .ring
    ),
    searchSpace: searchSpace
)

let islandStart = Date()
let islandResult = try! islandModel.minimize(rosenbrock, from: VectorN([0.0, 0.0]))
let islandTime = Date().timeIntervalSince(islandStart)

print("Comparison (same total population):")
print("Single GA (200 pop):")
print("  Result: \(singleResult.value.number(6))")
print("  Time: \(singleTime.number(3))s")
print("\nIsland Model (4×50):")
print("  Result: \(islandResult.value.number(6))")
print("  Time: \(islandTime.number(3))s")
```

## Troubleshooting

### Problem: Poor Diversity

**Symptoms**: All islands converge to same solution

**Solutions**:
```swift
import BusinessMath

// 1. Increase migration interval
let config1 = IslandModelConfig(
    numberOfIslands: 5,
    migrationInterval: 30,  // Less frequent exchange
    migrationSize: 1,        // Smaller migration
    topology: .ring
)

// 2. Use random topology
let config2 = IslandModelConfig(
    numberOfIslands: 6,
    migrationInterval: 15,
    migrationSize: 2,
    topology: .random  // Unpredictable connections
)

// 3. Increase number of islands
let config3 = IslandModelConfig(
    numberOfIslands: 10,  // More independent populations
    migrationInterval: 20,
    migrationSize: 1,
    topology: .ring
)
```

### Problem: Slow Convergence

**Symptoms**: Islands not improving despite many generations

**Solutions**:
```swift
import BusinessMath

// 1. Increase migration frequency
let config1 = IslandModelConfig(
    numberOfIslands: 4,
    migrationInterval: 5,  // More frequent exchange
    migrationSize: 3,       // More migrants
    topology: .fullyConnected
)

// 2. Use fully connected topology
let config2 = IslandModelConfig(
    numberOfIslands: 5,
    migrationInterval: 10,
    migrationSize: 3,
    topology: .fullyConnected  // Faster information sharing
)

// 3. Increase per-island population
let gaConfig = GeneticAlgorithmConfig(
    populationSize: 100,  // Larger islands
    generations: 100
)
```

### Problem: High Computational Cost

**Symptoms**: Optimization takes too long

**Solutions**:
```swift
import BusinessMath

// 1. Reduce number of islands
let config1 = IslandModelConfig(
    numberOfIslands: 3,  // Fewer islands
    migrationInterval: 10,
    migrationSize: 2,
    topology: .ring
)

// 2. Smaller per-island populations
let gaConfig1 = GeneticAlgorithmConfig(
    populationSize: 30,  // Smaller islands
    generations: 40
)

// 3. Or enable GPU acceleration
let gpuConfig = GeneticAlgorithmConfig(
    populationSize: 1000,  // GPU-accelerated
    generations: 100
)

let islandConfig = IslandModelConfig(
    numberOfIslands: 4,
    migrationInterval: 20,
    migrationSize: 5,
    topology: .fullyConnected
)
```

### Problem: Non-Reproducible Results

**Symptoms**: Different results each run

**Solutions**:
```swift
import BusinessMath

// Set seed in GA config for reproducibility
let gaConfig = GeneticAlgorithmConfig(
    populationSize: 50,
    generations: 50,
    seed: 12345  // Fixed seed
)

let islandConfig = IslandModelConfig(
    numberOfIslands: 4,
    migrationInterval: 10,
    migrationSize: 2,
    topology: .ring
)

let optimizer = IslandModel<VectorN<Double>>(
    gaConfig: gaConfig,
    islandConfig: islandConfig,
    searchSpace: [(-10.0, 10.0)]
)

// Results will now be reproducible
let result1 = try! optimizer.minimize({ v in v[0] * v[0] }, from: VectorN([5.0]))
let result2 = try! optimizer.minimize({ v in v[0] * v[0] }, from: VectorN([5.0]))

print("Result 1: \(result1.value)")
print("Result 2: \(result2.value)")
// Both should be identical
```

## Further Reading

- Original island model: Whitley et al. (1999)
- Migration strategies: Cant****-Paz (2000)
- See `IslandModel.swift` for implementation details
- GPU acceleration: `GPU_ACCELERATION_TUTORIAL.md`
- Genetic algorithms: `GeneticAlgorithm.swift`
