# Island Model Genetic Algorithm Tutorial

Complete guide to using the Island Model for distributed genetic algorithm optimization in BusinessMath.

## Table of Contents

- [Quick Start](#quick-start)
- [What is the Island Model?](#what-is-the-island-model)
- [Choosing a Migration Topology](#choosing-a-migration-topology)
- [Parameter Tuning](#parameter-tuning)
- [Real-World Examples](#real-world-examples)
- [GPU Acceleration](#gpu-acceleration)
- [Performance Comparison](#performance-comparison)
- [Troubleshooting](#troubleshooting)

## Quick Start

Copy this into an Xcode Playground to get started immediately:

> **Note for Xcode Playgrounds:** Island Model uses background threads for parallel island evolution. All playground examples require:
> ```swift
> import PlaygroundSupport
> PlaygroundPage.current.needsIndefiniteExecution = true
> // ... your Island Model code ...
> PlaygroundPage.current.finishExecution()
> ```
> Examples throughout this tutorial include these imports automatically.

```swift
import BusinessMath
import PlaygroundSupport

// Required for Island Model (uses background threads for parallel islands)
PlaygroundPage.current.needsIndefiniteExecution = true

// Configure individual GAs for each island
let gaConfig = GeneticAlgorithmConfig(
    populationSize: 1000,
    generations: 500
)

// Configure island model
let islandConfig = IslandModelConfig.default  // 4 islands, ring topology

// Create optimizer
let optimizer = IslandModel<VectorN<Double>>(
    gaConfig: gaConfig,
    islandConfig: islandConfig,
    searchSpace: [(-10.0, 10.0), (-10.0, 10.0)]
)

// Minimize Rosenbrock function
let rosenbrock = { (v: VectorN<Double>) -> Double in
    let x = v[0], y = v[1]
    return (1.0 - x) * (1.0 - x) + 100.0 * (y - x * x) * (y - x * x)
}

let result = try! optimizer.minimize(rosenbrock, from: VectorN([0.0, 0.0]))

print("Solution: [\(result.solution[0]), \(result.solution[1])]")
print("Objective value: \(result.value)")
// Solution: [0.98, 0.96]
// Objective value: 0.002

// Finish playground execution after result is printed
PlaygroundPage.current.finishExecution()
```

## What is the Island Model?

The Island Model is a distributed variant of genetic algorithms where multiple independent populations (islands) evolve in parallel. Periodically, elite individuals migrate between islands according to a topology, combining:

- **Diversity**: Multiple populations explore different regions
- **Parallelization**: Islands evolve independently (GPU-friendly)
- **Robustness**: Less likely to get stuck in local optima

### How It Works

1. **Initialization**: Create N independent island populations
2. **Evolution**: Each island runs its own GA independently
3. **Migration**: Periodically exchange elite individuals between islands
4. **Selection**: Return best solution across all islands

### Key Advantages

- Better exploration through population diversity
- Natural parallelization (each island independent)
- More robust than single-population GA
- Automatically inherits GPU acceleration from GA
- Escapes local optima more effectively

### When to Use Island Model

Use Island Model when:
- Problem has many local optima (multimodal)
- Standard GA converges prematurely
- You want more robust optimization
- You have computational resources for multiple populations
- You can benefit from GPU acceleration (1000+ pop/island)

## Choosing a Migration Topology

The topology determines how individuals move between islands:

### Ring Topology (Default)

**Best for**: Gradual information diffusion, maintaining diversity

```swift
import BusinessMath
import PlaygroundSupport

PlaygroundPage.current.needsIndefiniteExecution = true

let gaConfig = GeneticAlgorithmConfig(
    populationSize: 60,
    generations: 50
)

let islandConfig = IslandModelConfig(
    numberOfIslands: 4,
    migrationInterval: 10,  // Migrate every 10 generations
    migrationSize: 2,        // 2 elite individuals migrate
    topology: .ring          // Island i → Island i+1
)

let optimizer = IslandModel<VectorN<Double>>(
    gaConfig: gaConfig,
    islandConfig: islandConfig,
    searchSpace: [(-5.0, 5.0), (-5.0, 5.0)]
)

// Rastrigin: highly multimodal, benefits from diversity
let rastrigin = { (v: VectorN<Double>) -> Double in
    let A = 10.0
    var sum = A * 2.0
    for i in 0..<2 {
        let xi = v[i]
        sum += xi * xi - A * cos(2.0 * .pi * xi)
    }
    return sum
}

let result = try! optimizer.minimize(rastrigin, from: VectorN([0.0, 0.0]))
print("Ring topology result: \(result.value.number(3))")

PlaygroundPage.current.finishExecution()
```

### Fully Connected Topology

**Best for**: Fast convergence, aggressive information sharing

```swift
import BusinessMath
import PlaygroundSupport

PlaygroundPage.current.needsIndefiniteExecution = true

let gaConfig = GeneticAlgorithmConfig(
    populationSize: 60,
    generations: 50,
    seed: 42
)

let islandConfig = IslandModelConfig(
    numberOfIslands: 5,
    migrationInterval: 15,
    migrationSize: 3,
    topology: .fullyConnected  // All islands exchange with all others
)

let optimizer = IslandModel<VectorN<Double>>(
    gaConfig: gaConfig,
    islandConfig: islandConfig,
    searchSpace: [(-10.0, 10.0), (-10.0, 10.0)]
)

// Sphere: unimodal, benefits from fast convergence
let sphere = { (v: VectorN<Double>) -> Double in v.dot(v) }

let result = try! optimizer.minimize(sphere, from: VectorN([5.0, 5.0]))
print("Fully connected result: \(result.value.number(3))")

PlaygroundPage.current.finishExecution()
```

### Random Topology

**Best for**: Unpredictable connectivity, maximum diversity

```swift
import BusinessMath
import PlaygroundSupport

PlaygroundPage.current.needsIndefiniteExecution = true

let gaConfig = GeneticAlgorithmConfig(
    populationSize: 60,
    generations: 50,
    seed: 42
)

let islandConfig = IslandModelConfig(
    numberOfIslands: 6,
    migrationInterval: 12,
    migrationSize: 2,
    topology: .random  // Random connections each migration
)

let optimizer = IslandModel<VectorN<Double>>(
    gaConfig: gaConfig,
    islandConfig: islandConfig,
    searchSpace: [(-5.0, 5.0), (-5.0, 5.0)]
)

// Ackley: many local minima, needs exploration
let ackley = { (v: VectorN<Double>) -> Double in
    let x = v[0], y = v[1]
    let sum1 = x * x + y * y
    let sum2 = cos(2.0 * .pi * x) + cos(2.0 * .pi * y)
    return -20.0 * exp(-0.2 * sqrt(sum1 / 2.0)) - exp(sum2 / 2.0) + 20.0 + exp(1.0)
}

let result = try! optimizer.minimize(ackley, from: VectorN([0.0, 0.0]))
print("Random topology result: \(result.value)")

PlaygroundPage.current.finishExecution()
```

## Parameter Tuning

### Number of Islands

More islands = more diversity, but more computation:

```swift
import BusinessMath

let gaConfig = GeneticAlgorithmConfig(
    populationSize: 50,
    generations: 40,
    seed: 42
)

// Few islands: Fast, good for simple problems
let fewIslands = IslandModelConfig(
    numberOfIslands: 3,
    migrationInterval: 10,
    migrationSize: 2,
    topology: .ring
)

// Many islands: Better exploration, more computation
let manyIslands = IslandModelConfig(
    numberOfIslands: 8,
    migrationInterval: 10,
    migrationSize: 2,
    topology: .fullyConnected
)

let searchSpace = [(-10.0, 10.0), (-10.0, 10.0)]
let rosenbrock = { (v: VectorN<Double>) -> Double in
    let x = v[0], y = v[1]
    return (1.0 - x) * (1.0 - x) + 100.0 * (y - x * x) * (y - x * x)
}

let opt1 = IslandModel<VectorN<Double>>(
    gaConfig: gaConfig,
    islandConfig: fewIslands,
    searchSpace: searchSpace
)
let result1 = try! opt1.minimize(rosenbrock, from: VectorN([0.0, 0.0]))

let opt2 = IslandModel<VectorN<Double>>(
    gaConfig: gaConfig,
    islandConfig: manyIslands,
    searchSpace: searchSpace
)
let result2 = try! opt2.minimize(rosenbrock, from: VectorN([0.0, 0.0]))

print("3 islands: \(result1.value)")
print("8 islands: \(result2.value)")
```

### Migration Interval

Controls how often islands exchange individuals:

```swift
import BusinessMath

let gaConfig = GeneticAlgorithmConfig(
    populationSize: 50,
    generations: 60,
    seed: 42
)

// Frequent migration: Fast information sharing
let frequentConfig = IslandModelConfig(
    numberOfIslands: 4,
    migrationInterval: 5,   // Every 5 generations
    migrationSize: 3,
    topology: .fullyConnected
)

// Infrequent migration: More independent exploration
let infrequentConfig = IslandModelConfig(
    numberOfIslands: 4,
    migrationInterval: 30,  // Every 30 generations
    migrationSize: 3,
    topology: .ring
)

let searchSpace = [(-5.0, 5.0), (-5.0, 5.0)]
let sphere = { (v: VectorN<Double>) -> Double in v.dot(v) }

let freqOpt = IslandModel<VectorN<Double>>(
    gaConfig: gaConfig,
    islandConfig: frequentConfig,
    searchSpace: searchSpace
)
let freqResult = try! freqOpt.minimize(sphere, from: VectorN([3.0, 3.0]))

let infreqOpt = IslandModel<VectorN<Double>>(
    gaConfig: gaConfig,
    islandConfig: infrequentConfig,
    searchSpace: searchSpace
)
let infreqResult = try! infreqOpt.minimize(sphere, from: VectorN([3.0, 3.0]))

print("Frequent migration (interval=5): \(freqResult.value)")
print("Infrequent migration (interval=30): \(infreqResult.value)")
```

### Migration Size

Number of elite individuals to exchange:

```swift
import BusinessMath

let gaConfig = GeneticAlgorithmConfig(
    populationSize: 100,
    generations: 50,
    seed: 42
)

// Small migration: Preserves diversity
let smallMigration = IslandModelConfig(
    numberOfIslands: 4,
    migrationInterval: 10,
    migrationSize: 1,  // Just 1 elite
    topology: .ring
)

// Large migration: Faster convergence
let largeMigration = IslandModelConfig(
    numberOfIslands: 4,
    migrationInterval: 10,
    migrationSize: 5,  // 5 elites (5% of population)
    topology: .ring
)

let searchSpace = [(-10.0, 10.0), (-10.0, 10.0)]
let rosenbrock = { (v: VectorN<Double>) -> Double in
    let x = v[0], y = v[1]
    return (1.0 - x) * (1.0 - x) + 100.0 * (y - x * x) * (y - x * x)
}

let smallOpt = IslandModel<VectorN<Double>>(
    gaConfig: gaConfig,
    islandConfig: smallMigration,
    searchSpace: searchSpace
)
let smallResult = try! smallOpt.minimize(rosenbrock, from: VectorN([0.0, 0.0]))

let largeOpt = IslandModel<VectorN<Double>>(
    gaConfig: gaConfig,
    islandConfig: largeMigration,
    searchSpace: searchSpace
)
let largeResult = try! largeOpt.minimize(rosenbrock, from: VectorN([0.0, 0.0]))

print("Small migration (1 elite): \(smallResult.value)")
print("Large migration (5 elites): \(largeResult.value)")
```

## Real-World Examples

### Example 1: Traveling Salesman Problem (Continuous Relaxation)

Optimize tour through cities (using continuous coordinates):

```swift
import BusinessMath
import PlaygroundSupport

PlaygroundPage.current.needsIndefiniteExecution = true

// City coordinates
let cities = [
    (0.0, 0.0),
    (1.0, 5.0),
    (5.0, 2.0),
    (6.0, 6.0),
    (8.0, 3.0)
]

// Encode tour as permutation weights (continuous)
let optimizer = IslandModel<VectorN<Double>>(
    gaConfig: GeneticAlgorithmConfig(
        populationSize: 80,
        generations: 100,
        mutationRate: 0.2,
        seed: 42
    ),
    islandConfig: IslandModelConfig(
        numberOfIslands: 5,
        migrationInterval: 15,
        migrationSize: 3,
        topology: .fullyConnected
    ),
    searchSpace: Array(repeating: (0.0, 1.0), count: cities.count)
)

// Tour distance (using continuous encoding)
let tourDistance = { (weights: VectorN<Double>) -> Double in
    let w = weights.toArray()

    // Convert continuous weights to permutation
    let indices = w.enumerated().sorted { $0.element < $1.element }.map { $0.offset }

    // Calculate tour distance
    var distance = 0.0
    for i in 0..<indices.count {
        let from = indices[i]
        let to = indices[(i + 1) % indices.count]

        let dx = cities[to].0 - cities[from].0
        let dy = cities[to].1 - cities[from].1
        distance += sqrt(dx * dx + dy * dy)
    }

    return distance
}

let result = try! optimizer.minimize(tourDistance, from: VectorN(Array(repeating: 0.5, count: cities.count)))

print("Best tour distance: \(String(format: "%.2f", result.value))")

// Decode tour
let weights = result.solution.toArray()
let tour = weights.enumerated().sorted { $0.element < $1.element }.map { $0.offset }
print("Tour order: \(tour)")

PlaygroundPage.current.finishExecution()
```

### Example 2: Feature Selection for Machine Learning

Select optimal subset of features with budget constraints:

```swift
import BusinessMath
import PlaygroundSupport

PlaygroundPage.current.needsIndefiniteExecution = true

// Simulate feature selection: 10 features, select best subset
let optimizer_mlFS = IslandModel<VectorN<Double>>(
	gaConfig: GeneticAlgorithmConfig(
		populationSize: 60,
		generations: 80,
		mutationRate: 0.15,
		seed: 42
	),
	islandConfig: IslandModelConfig(
		numberOfIslands: 4,
		migrationInterval: 12,
		migrationSize: 2,
		topology: .ring
	),
	searchSpace: Array(repeating: (0.0, 1.0), count: 10)  // 10 features
)

// Feature quality scores and computational costs
let featureScores_mlFS = [0.8, 0.3, 0.9, 0.2, 0.7, 0.4, 0.85, 0.6, 0.5, 0.75]
let featureCosts_mlFS = [1.0, 0.5, 1.5, 0.5, 1.0, 0.5, 1.2, 0.8, 0.6, 1.0]  // Computational cost varies

// Feature correlation (redundancy penalty)
// Features 0 and 2 are highly correlated, as are features 6 and 9
let redundancy_mlFS = [
	(0, 2, 0.3),  // Using both reduces combined value by 0.3
	(6, 9, 0.25)  // Using both reduces combined value by 0.25
]

// Budget constraints
let maxFeatures_mlFS = 6      // Can only use 6 out of 10 features
let maxTotalCost_mlFS = 6.0   // Total computational budget

// Objective: Maximize model performance - cost, considering redundancy
let featureObjective_mlFS = { (selection: VectorN<Double>) -> Double in
	let features = selection.toArray()

	// Threshold: > 0.5 means feature is selected
	var performance = 0.0
	var cost = 0.0
	var selectedCount = 0

	for (i, value) in features.enumerated() {
		if value > 0.5 {
			performance += featureScores_mlFS[i]
			cost += featureCosts_mlFS[i]
			selectedCount += 1
		}
	}

	// Apply redundancy penalties
	for (i, j, penalty) in redundancy_mlFS {
		if features[i] > 0.5 && features[j] > 0.5 {
			performance -= penalty
		}
	}

	// Penalty for violating constraints (soft constraints for GA)
	var constraintPenalty = 0.0

	// Feature count constraint
	if selectedCount > maxFeatures_mlFS {
		constraintPenalty += Double(selectedCount - maxFeatures_mlFS) * 2.0
	}

	// Cost budget constraint
	if cost > maxTotalCost_mlFS {
		constraintPenalty += (cost - maxTotalCost_mlFS) * 2.0
	}

	// Objective: maximize performance - cost - penalties
	return -(performance - constraintPenalty)  // Minimize negative
}

let result_mlFS = try! optimizer_mlFS.minimize(featureObjective_mlFS, from: VectorN(Array(repeating: 0.5, count: 10)))

print("Feature selection results:")
let selected_mlFS = result_mlFS.solution.toArray()
var totalCost_mlFS = 0.0
var totalPerformance_mlFS = 0.0
var selectedCount_mlFS = 0

for (i, value) in selected_mlFS.enumerated() {
	if value > 0.5 {
		print("  Feature \(i): SELECTED (score: \(featureScores_mlFS[i]), cost: \(featureCosts_mlFS[i]))")
		totalCost_mlFS += featureCosts_mlFS[i]
		totalPerformance_mlFS += featureScores_mlFS[i]
		selectedCount_mlFS += 1
	}
}

// Check for redundancy
for (i, j, penalty) in redundancy_mlFS {
	if selected_mlFS[i] > 0.5 && selected_mlFS[j] > 0.5 {
		print("  Warning: Features \(i) and \(j) are redundant (penalty: \(penalty))")
		totalPerformance_mlFS -= penalty
	}
}

print("\nSummary:")
print("  Selected features: \(selectedCount_mlFS)/\(maxFeatures_mlFS)")
print("  Total cost: \(totalCost_mlFS.number(2))/\(maxTotalCost_mlFS)")
print("  Net performance: \(totalPerformance_mlFS.number(2))")
print("  Objective: \(result_mlFS.value.number(3))")

PlaygroundPage.current.finishExecution()
```

**Expected Output:**
```
Feature selection results:
	Feature 0: SELECTED (score: 0.8, cost: 1.0)
	Feature 2: SELECTED (score: 0.9, cost: 1.5)
	Feature 4: SELECTED (score: 0.7, cost: 1.0)
	Feature 5: SELECTED (score: 0.4, cost: 0.5)
	Feature 6: SELECTED (score: 0.85, cost: 1.2)
	Feature 7: SELECTED (score: 0.6, cost: 0.8)
	Warning: Features 0 and 2 are redundant (penalty: 0.3)

Summary:
  Selected features: 6/6
  Total cost: 6.00/6.0
  Net performance: 3.95
  Objective: -3.950
```

**★ Insight ─────────────────────────────────────**
Why these specific features? Let's analyze the optimizer's decisions:

1. **Redundancy penalty accepted:** Features 0 (0.8) and 2 (0.9) are both selected despite -0.3 redundancy penalty. Their combined net value (0.8 + 0.9 - 0.3 = 1.4) still beats alternatives within budget constraints.

2. **Top features selected strategically:** Features 2 (0.9) and 6 (0.85) are the two highest-scoring features and both made the cut. Feature 0 (0.8) came along despite redundancy.

3. **Budget forces hard choices:** Total cost is exactly 6.0/6.0 (binding constraint). Feature 9 (0.75, cost 1.0) would be valuable but doesn't fit - swapping Feature 5 (cost 0.5) for Feature 9 (cost 1.0) would exceed budget (6.5 > 6.0).

4. **Low-value feature included for budget efficiency:** Feature 5 (0.4) has the lowest score among selected features but costs only 0.5. It's the "filler" that lets us use 6 features while staying at exactly 6.0 cost. Feature 8 (0.5, cost 0.6) would be marginally better but pushes cost to 6.1.

5. **Features excluded:**
   - Feature 9 (0.75): Can't fit in budget despite good score
   - Feature 8 (0.5): Would exceed budget by 0.1
   - Features 1 (0.3) and 3 (0.2): Low scores make them inferior choices

**Real-world analogy:** Like packing a suitcase with a weight limit - sometimes you include a lightweight item (Feature 5) not because it's essential, but because it fills space without breaking your budget. The expensive high-quality item you had to leave behind (Feature 9) hurts, but the math doesn't lie.
**─────────────────────────────────────────────────**

### Example 3: Multi-Objective Portfolio Optimization

Balance return, risk, and diversification:

```swift
import BusinessMath

// 5 assets portfolio
let optimizer = IslandModel<VectorN<Double>>(
	gaConfig: GeneticAlgorithmConfig(
		populationSize: 100,
		generations: 100,
		crossoverRate: 0.85,
		mutationRate: 0.1,
		seed: 42
	),
	islandConfig: IslandModelConfig(
		numberOfIslands: 6,
		migrationInterval: 15,
		migrationSize: 4,
		topology: .fullyConnected
	),
	searchSpace: Array(repeating: (0.0, 1.0), count: 5)
)

// Asset parameters
let expectedReturns = [0.12, 0.15, 0.08, 0.18, 0.10]
let volatilities = [0.20, 0.30, 0.15, 0.35, 0.18]
let riskFreeRate = 0.03

// Multi-objective: maximize Sharpe ratio + diversification
let portfolioObjective = { (weights: VectorN<Double>) -> Double in
	let w = weights.toArray()

	// Normalize weights
	let sum = w.reduce(0.0, +)
	let normalized = w.map { $0 / (sum + 1e-10) }

	// Portfolio return
	let portfolioReturn = zip(normalized, expectedReturns).map(*).reduce(0.0, +)

	// Portfolio risk (simplified)
	let portfolioRisk = sqrt(zip(normalized, volatilities).map { $0 * $0 * $1 * $1 }.reduce(0.0, +))

	// Sharpe ratio
	let sharpe = (portfolioReturn - riskFreeRate) / (portfolioRisk + 1e-10)

	// Diversification (entropy)
	let diversification = -normalized.map { x in
		x > 0 ? x * log(x + 1e-10) : 0.0
	}.reduce(0.0, +)

	// Combined objective (maximize both)
	return -(sharpe + 0.5 * diversification)
}

// Constraint: weights sum to 1
let weightConstraint = MultivariateConstraint<VectorN<Double>>.equality { w in
	w.toArray().reduce(0.0, +) - 1.0
}

let result = try! optimizer.minimize(
	portfolioObjective,
	from: VectorN(Array(repeating: 0.2, count: 5)),
	constraints: [weightConstraint]
)

print("Optimal portfolio:")
let weights = result.solution.toArray()
let sum = weights.reduce(0.0, +)
for (i, w) in weights.enumerated() {
	print("  Asset \(i+1): \((w/sum).percent())")
}

// Calculate final metrics
let normalized = weights.map { $0 / sum }
let portReturn = zip(normalized, expectedReturns).map(*).reduce(0.0, +)
let portRisk = sqrt(zip(normalized, volatilities).map { $0 * $0 * $1 * $1 }.reduce(0.0, +))
let sharpe = (portReturn - riskFreeRate) / portRisk

print("Expected return: \(portReturn.percent(1))")
print("Risk (volatility): \(portRisk.percent(1))")
print("Sharpe ratio: \(sharpe.number(3))")
```

### Example 4: Engineering Design Optimization

Optimize truss structure for minimum weight with stress and buckling constraints:

```swift
import BusinessMath
import PlaygroundSupport

PlaygroundPage.current.needsIndefiniteExecution = true

// 4-member truss: optimize cross-sectional areas
// Members: [0,1] = top chord (tension), [2,3] = diagonals (compression)
let optimizer_truss = IslandModel<VectorN<Double>>(
	gaConfig: GeneticAlgorithmConfig(
		populationSize: 80,
		generations: 120,
		mutationRate: 0.12,
		seed: 42
	),
	islandConfig: IslandModelConfig(
		numberOfIslands: 5,
		migrationInterval: 20,
		migrationSize: 3,
		topology: .ring
	),
	searchSpace: Array(repeating: (100.0, 5000.0), count: 4)  // mm² cross-sections
)

// Material and load properties
let density_truss = 7850.0     // kg/m³ (steel)
let E_truss = 200e9            // Pa (Young's modulus)
let maxStress_truss = 250e6    // Pa (allowable stress)
let appliedLoad_truss = 100000.0  // N (vertical load at center)

// Member geometry
let memberLengths_truss = [3.0, 3.0, 4.24, 4.24]  // m (diagonals are longer)
let memberTypes_truss = ["tension", "tension", "compression", "compression"]

// Realistic force distribution from truss analysis
// Top members in tension, diagonals in compression
let memberForces_truss = [70710.0, 70710.0, -100000.0, -100000.0]  // N (negative = compression)

// Objective: Minimize total weight
let structureWeight_truss = { (areas: VectorN<Double>) -> Double in
	let A = areas.toArray().map { $0 / 1e6 }  // Convert mm² to m²

	var weight = 0.0
	for i in 0..<4 {
		weight += density_truss * A[i] * memberLengths_truss[i]
	}

	return weight  // kg
}

// Constraint 1: Tensile stress limit
let tensileStressConstraint_truss = MultivariateConstraint<VectorN<Double>>.inequality { areas in
	let A = areas.toArray().map { $0 / 1e6 }

	var maxViolation = 0.0
	for i in 0..<4 {
		if memberForces_truss[i] > 0 {  // Tension members
			let stress = memberForces_truss[i] / A[i]
			maxViolation = max(maxViolation, stress - maxStress_truss)
		}
	}

	return maxViolation  // stress ≤ maxStress
}

// Constraint 2: Buckling limit for compression members (Euler buckling)
// Critical load: P_cr = π²EI/L² where I = A × r² and r ≈ 0.289×√A for circular section
let bucklingConstraint_truss = MultivariateConstraint<VectorN<Double>>.inequality { areas in
	let A = areas.toArray().map { $0 / 1e6 }

	var maxViolation = 0.0
	for i in 0..<4 {
		if memberForces_truss[i] < 0 {  // Compression members
			let compressiveForce = abs(memberForces_truss[i])
			let L = memberLengths_truss[i]

			// Moment of inertia for circular section: I = A × r²
			// Radius of gyration for circle: r ≈ 0.289 × √A (approximation)
			let radiusOfGyration = 0.289 * sqrt(A[i])
			let I = A[i] * radiusOfGyration * radiusOfGyration

			// Euler critical load
			let P_critical = (Double.pi * Double.pi * E_truss * I) / (L * L)

			// Safety factor of 2 for buckling
			let allowableLoad = P_critical / 2.0

			maxViolation = max(maxViolation, compressiveForce - allowableLoad)
		}
	}

	return maxViolation  // force ≤ critical_load/2
}

let result_truss = try! optimizer_truss.minimize(
	structureWeight_truss,
	from: VectorN([1000.0, 1000.0, 1000.0, 1000.0]),
	constraints: [tensileStressConstraint_truss, bucklingConstraint_truss]
)

print("Optimal truss design:")
for (i, area) in result_truss.solution.toArray().enumerated() {
	let A_m2 = area / 1e6
	let weight = density_truss * A_m2 * memberLengths_truss[i]
	print("  Member \(i+1) (\(memberTypes_truss[i])): \(area.number(0)) mm², \(weight.number(2)) kg")
}
print("\nTotal weight: \(result_truss.value.number(2)) kg")

// Verify constraints
print("\nConstraint verification:")
let finalAreas_truss = result_truss.solution.toArray().map { $0 / 1e6 }
for i in 0..<4 {
	if memberForces_truss[i] > 0 {
		let stress = memberForces_truss[i] / finalAreas_truss[i]
		print("  Member \(i+1) stress: \((stress/1e6).number(1)) MPa / \(maxStress_truss/1e6) MPa")
	} else {
		let compForce = abs(memberForces_truss[i])
		let r = 0.289 * sqrt(finalAreas_truss[i])
		let I = finalAreas_truss[i] * r * r
		let L = memberLengths_truss[i]
		let P_cr = (Double.pi * Double.pi * E_truss * I) / (L * L)
		print("  Member \(i+1) buckling: \((compForce/1000).number(1)) kN / \((P_cr/2000).number(1)) kN")
	}
}

PlaygroundPage.current.finishExecution()
```

**Expected Output:**
```
Optimal truss design:
  Member 1 (tension): 339 mm², 7.98 kg
  Member 2 (tension): 374 mm², 8.80 kg
  Member 3 (compression): 4,672 mm², 155.52 kg
  Member 4 (compression): 4,690 mm², 156.11 kg

Total weight: 328.41 kg

Constraint verification:
  Member 1 stress: 208.7 MPa / 250.0 MPa
  Member 2 stress: 189.2 MPa / 250.0 MPa
  Member 3 buckling: 100.0 kN / 100.1 kN
  Member 4 buckling: 100.0 kN / 100.9 kN
```

**★ Insight ─────────────────────────────────────**
Why are compression members SO MUCH larger than tension members?

1. **The Buckling Catastrophe:** Compression members (3-4) at ~4,680 mm² are **13× larger** than the theoretical minimum for tension members (~360 mm²). This dramatic difference is pure physics - Euler buckling scales harshly with length.

2. **Why Buckling Dominates:** For compression member 3 at 4.24m length:
   - Required to carry: 100 kN compression
   - Buckling formula: P_cr = π²EI/L² with safety factor 2
   - Critical dependence: I ∝ A² (moment of inertia scales quadratically with area)
   - BUT: L² = 18.0 m² appears in denominator (4.24²)
   - **At minimum area (283 mm²):** P_cr ≈ 14 kN allowable ❌ WAY too small!
   - **Needs 4,680 mm² (16.5× larger!)** to get P_cr ≈ 200 kN allowable

3. **The Quadratic Trap:** To double the buckling resistance, you need to increase I by 2×. Since I ∝ A², you need to increase A by √2 ≈ 1.41×. But to handle 7× more force (100 kN vs 14 kN), you need √7 ≈ 2.65× in linear dimension, which translates to **7× more area** (quadratic scaling strikes again!).

4. **Genetic Algorithm Suboptimality:** Tension members show slack (208 MPa and 189 MPa vs 250 MPa limit). Theoretical minimum is 283 mm² for both, but GA found 339 and 374 mm². This is typical GA behavior - it gets close but may not find the exact optimum, especially when one constraint (buckling) is binding hard and another (tension stress) has slack.

5. **Weight Distribution:** Compression members account for **95% of total weight** (311 kg / 328 kg) despite being only 50% of the structure. In real bridge trusses, you often see this exact pattern: massive compression arches with delicate tension cables.

**Real-world analogue:** Compare a suspension bridge cable (thin, pure tension) to its compression towers (massive). The Golden Gate Bridge towers are enormous concrete/steel structures, while the suspension cables are relatively slender - same physics at play!
**─────────────────────────────────────────────────**

## GPU Acceleration

The Island Model automatically inherits GPU acceleration from the underlying `GeneticAlgorithm` implementation:

### Enabling GPU Acceleration

```swift
import BusinessMath

// Each island with population ≥ 1000 uses GPU
let gpuConfig = GeneticAlgorithmConfig.highPerformance  // 1000 pop

let islandConfig = IslandModelConfig(
	numberOfIslands: 4,      // 4 islands
	migrationInterval: 20,
	migrationSize: 5,
	topology: .fullyConnected
)

let optimizer = IslandModel<VectorN<Double>>(
	gaConfig: gpuConfig,     // Each island: 1000 individuals (GPU)
	islandConfig: islandConfig,
	searchSpace: Array(repeating: (-5.0, 5.0), count: 10)
)

// Total: 4 islands × 1000 = 4000 individuals
// Each island runs GPU-accelerated GA independently

let sphere = { (v: VectorN<Double>) -> Double in v.dot(v) }
let result = try! optimizer.minimize(sphere, from: VectorN(Array(repeating: 2.0, count: 10)))

print("GPU-accelerated island model result: \(result.value)")
print("Total evaluations: \(result.iterations)")
```

### Checking GPU Status

```swift
import BusinessMath

#if canImport(Metal)
import Metal

if let device = MTLCreateSystemDefaultDevice() {
    print("GPU available: \(device.name)")
    print("Each island with population ≥ 1000 will use GPU")
} else {
    print("GPU not available - islands will use CPU")
}
#else
print("Metal not supported on this platform")
#endif

// Works regardless of GPU availability
let optimizer = IslandModel<VectorN<Double>>(
    gaConfig: .highPerformance,
    islandConfig: .highPerformance,
    searchSpace: [(-5.0, 5.0)]
)

let simple = { (v: VectorN<Double>) -> Double in v[0] * v[0] }
let result = try! optimizer.minimize(simple, from: VectorN([2.0]))
print("Result: \(result.value)")
```

### Optimal GPU Configuration

```swift
import BusinessMath

// Maximize GPU utilization
let gpuGA = GeneticAlgorithmConfig(
	populationSize: 2000,  // Large population per island
	generations: 100,
	seed: 42
)

let gpuIslands = IslandModelConfig(
	numberOfIslands: 4,     // 4 islands = 8000 total individuals
	migrationInterval: 25,
	migrationSize: 10,      // 0.5% migration
	topology: .fullyConnected
)

let optimizer = IslandModel<VectorN<Double>>(
	gaConfig: gpuGA,
	islandConfig: gpuIslands,
	searchSpace: Array(repeating: (-10.0, 10.0), count: 20)  // 20D problem
)

let highdim = { (v: VectorN<Double>) -> Double in v.dot(v) }
let result = try! optimizer.optimizeDetailed(objective: highdim)

print("High-dimensional optimization:")
print("  Best value: \(result.bestFitness)")
print("  Total evaluations: \(result.generations)")
print("  Best island: \(result.bestIslandIndex)")
```

## Performance Comparison

### Island Analysis

```swift
import BusinessMath

let gaConfig = GeneticAlgorithmConfig(
	populationSize: 60,
	generations: 50,
	seed: 42
)

let islandConfig = IslandModelConfig(
	numberOfIslands: 5,
	migrationInterval: 10,
	migrationSize: 2,
	topology: .ring
)

let optimizer = IslandModel<VectorN<Double>>(
	gaConfig: gaConfig,
	islandConfig: islandConfig,
	searchSpace: [(-5.0, 5.0), (-5.0, 5.0)]
)

let rosenbrock = { (v: VectorN<Double>) -> Double in
	let x = v[0], y = v[1]
	return (1.0 - x) * (1.0 - x) + 100.0 * (y - x * x) * (y - x * x)
}

let result = try! optimizer.optimizeDetailed(objective: rosenbrock)

print("Island Model Analysis:")
print("  Number of islands: \(result.islandFitnesses.count)")
print("  Best island: \(result.bestIslandIndex)")
print("  Best fitness: \(result.bestFitness.number(6))")
print("  Migrations performed: \(result.migrationCount)")
print("\nIndividual island fitnesses:")
for (i, fitness) in result.islandFitnesses.enumerated() {
	let marker = i == result.bestIslandIndex ? " ⭐" : ""
	print("  Island \(i): \(fitness.number(6))\(marker)")
}
```

### Single GA vs Island Model

```swift
import BusinessMath
import Foundation

let searchSpace = [(-5.0, 5.0), (-5.0, 5.0)]
let rosenbrock = { (v: VectorN<Double>) -> Double in
    let x = v[0], y = v[1]
    return (1.0 - x) * (1.0 - x) + 100.0 * (y - x * x) * (y - x * x)
}

// Single large GA
let singleGA = GeneticAlgorithm<VectorN<Double>>(
    config: GeneticAlgorithmConfig(
        populationSize: 200,  // Same total evaluations
        generations: 50,
        seed: 42
    ),
    searchSpace: searchSpace
)

let singleStart = Date()
let singleResult = try! singleGA.minimize(rosenbrock, from: VectorN([0.0, 0.0]))
let singleTime = Date().timeIntervalSince(singleStart)

// Island model: 4 islands × 50 pop = 200 total
let islandModel = IslandModel<VectorN<Double>>(
    gaConfig: GeneticAlgorithmConfig(
        populationSize: 50,
        generations: 50,
        seed: 42
    ),
    islandConfig: IslandModelConfig(
        numberOfIslands: 4,
        migrationInterval: 10,
        migrationSize: 2,
        topology: .ring
    ),
    searchSpace: searchSpace
)

let islandStart = Date()
let islandResult = try! islandModel.minimize(rosenbrock, from: VectorN([0.0, 0.0]))
let islandTime = Date().timeIntervalSince(islandStart)

print("Comparison (same total population):")
print("Single GA (200 pop):")
print("  Result: \(singleResult.value.number(6))")
print("  Time: \(singleTime.number(3))s")
print("\nIsland Model (4×50):")
print("  Result: \(islandResult.value.number(6))")
print("  Time: \(islandTime.number(3))s")
```

## Troubleshooting

### Problem: Poor Diversity

**Symptoms**: All islands converge to same solution

**Solutions**:
```swift
import BusinessMath

// 1. Increase migration interval
let config1 = IslandModelConfig(
    numberOfIslands: 5,
    migrationInterval: 30,  // Less frequent exchange
    migrationSize: 1,        // Smaller migration
    topology: .ring
)

// 2. Use random topology
let config2 = IslandModelConfig(
    numberOfIslands: 6,
    migrationInterval: 15,
    migrationSize: 2,
    topology: .random  // Unpredictable connections
)

// 3. Increase number of islands
let config3 = IslandModelConfig(
    numberOfIslands: 10,  // More independent populations
    migrationInterval: 20,
    migrationSize: 1,
    topology: .ring
)
```

### Problem: Slow Convergence

**Symptoms**: Islands not improving despite many generations

**Solutions**:
```swift
import BusinessMath

// 1. Increase migration frequency
let config1 = IslandModelConfig(
    numberOfIslands: 4,
    migrationInterval: 5,  // More frequent exchange
    migrationSize: 3,       // More migrants
    topology: .fullyConnected
)

// 2. Use fully connected topology
let config2 = IslandModelConfig(
    numberOfIslands: 5,
    migrationInterval: 10,
    migrationSize: 3,
    topology: .fullyConnected  // Faster information sharing
)

// 3. Increase per-island population
let gaConfig = GeneticAlgorithmConfig(
    populationSize: 100,  // Larger islands
    generations: 100
)
```

### Problem: High Computational Cost

**Symptoms**: Optimization takes too long

**Solutions**:
```swift
import BusinessMath

// 1. Reduce number of islands
let config1 = IslandModelConfig(
    numberOfIslands: 3,  // Fewer islands
    migrationInterval: 10,
    migrationSize: 2,
    topology: .ring
)

// 2. Smaller per-island populations
let gaConfig1 = GeneticAlgorithmConfig(
    populationSize: 30,  // Smaller islands
    generations: 40
)

// 3. Or enable GPU acceleration
let gpuConfig = GeneticAlgorithmConfig(
    populationSize: 1000,  // GPU-accelerated
    generations: 100
)

let islandConfig = IslandModelConfig(
    numberOfIslands: 4,
    migrationInterval: 20,
    migrationSize: 5,
    topology: .fullyConnected
)
```

### Problem: Non-Reproducible Results

**Symptoms**: Different results each run

**Solutions**:
```swift
import BusinessMath

// Set seed in GA config for reproducibility
let gaConfig = GeneticAlgorithmConfig(
    populationSize: 50,
    generations: 50,
    seed: 12345  // Fixed seed
)

let islandConfig = IslandModelConfig(
    numberOfIslands: 4,
    migrationInterval: 10,
    migrationSize: 2,
    topology: .ring
)

let optimizer = IslandModel<VectorN<Double>>(
    gaConfig: gaConfig,
    islandConfig: islandConfig,
    searchSpace: [(-10.0, 10.0)]
)

// Results will now be reproducible
let result1 = try! optimizer.minimize({ v in v[0] * v[0] }, from: VectorN([5.0]))
let result2 = try! optimizer.minimize({ v in v[0] * v[0] }, from: VectorN([5.0]))

print("Result 1: \(result1.value)")
print("Result 2: \(result2.value)")
// Both should be identical
```

## Further Reading

- Original island model: Whitley et al. (1999)
- Migration strategies: Cant****-Paz (2000)
- See `IslandModel.swift` for implementation details
- GPU acceleration: `GPU_ACCELERATION_TUTORIAL.md`
- Genetic algorithms: `GeneticAlgorithm.swift`
