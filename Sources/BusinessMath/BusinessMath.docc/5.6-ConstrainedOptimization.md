# Constrained Optimization

This module adds **constrained optimization** to BusinessMath.

---

## Table of Contents

1. [Overview](#overview)
2. [Constraint Infrastructure](#constraint-infrastructure)
3. [Equality-Constrained Optimization](#equality-constrained-optimization)
4. [Inequality-Constrained Optimization](#inequality-constrained-optimization)
5. [Integration Examples](#integration-examples)
6. [Best Practices](#best-practices)

---

## Overview

This module adds **constrained optimization** to BusinessMath. While before, we could optimize unconstrained functions, now we can handle real-world problems with constraints:

- **Budget constraints**: Σwᵢ = 1 (portfolio weights sum to 1)
- **Non-negativity**: wᵢ ≥ 0 (no short-selling)
- **Capacity limits**: production ≤ capacity
- **Target requirements**: return ≥ targetReturn

### What's Included

- **Constraint Infrastructure**: Type-safe constraint specification
- **Equality Constraints**: Augmented Lagrangian method
- **Inequality Constraints**: Augmented Lagrangian with quadratic penalties
- **Shadow Prices**: Lagrange multipliers for sensitivity analysis

### Design Philosophy

Constraints are first-class citizens:
```swift
// Before Phase 4: Post-hoc normalization
let weights = optimizer.minimize(objective)
let normalized = weights / weights.sum()  // Wrong!

// After Phase 4: Proper constraints during optimization
let result = optimizer.minimize(
    objective,
    subjectTo: [.budgetConstraint, .nonNegativity(dimension: n)]
)
// Constraints satisfied throughout optimization
```

---

## Constraint Infrastructure

### What Problems Does It Solve?

The `MultivariateConstraint` enum provides a type-safe way to specify constraints on optimization problems.

### Quick Start

```swift
import BusinessMath

// Define constraints for a 3-asset portfolio
let constraints: [MultivariateConstraint<VectorN<Double>>] = [
    .budgetConstraint,  // Weights sum to 1
    .nonNegativity(dimension: 3)  // No negative weights (no short-selling)
]

// Use with any optimizer
let result = try optimizer.minimize(objective, subjectTo: constraints)
```

### API Reference

#### `MultivariateConstraint<V: VectorSpace>`

Generic constraint enum that works with any vector space.

```swift
enum MultivariateConstraint<V: VectorSpace> {
    // Full form with explicit gradient
    case equality(
        function: (V) -> V.Scalar,
        gradient: ((V) -> V)?
    )
    case inequality(
        function: (V) -> V.Scalar,
        gradient: ((V) -> V)?
    )

    // Convenience forms (gradient computed numerically)
    static func equality(_ function: @escaping (V) -> V.Scalar) -> MultivariateConstraint<V>
    static func inequality(_ function: @escaping (V) -> V.Scalar) -> MultivariateConstraint<V>
}
```

**Key Methods:**
```swift
// Check if constraint is satisfied
func isSatisfied(at point: V, tolerance: V.Scalar = 1e-6) -> Bool

// Evaluate constraint function
func evaluate(at point: V) -> V.Scalar

// Get gradient (analytical if provided, otherwise numerical)
func gradient(at point: V) throws -> V

// Check constraint type
var isEquality: Bool
var isInequality: Bool
```

### Pre-Built Constraint Helpers

#### Budget Constraint
Weights must sum to 1 (for portfolios).

```swift
static let budgetConstraint: MultivariateConstraint<VectorN<Double>>
// Enforces: Σwᵢ = 1
```

**Example:**
```swift
let constraints = [MultivariateConstraint<VectorN<Double>>.budgetConstraint]
```

#### Non-Negativity
All components must be ≥ 0.

```swift
static func nonNegativity(dimension: Int) -> [MultivariateConstraint<VectorN<Double>>]
// Returns n inequality constraints: wᵢ ≥ 0 for all i
```

**Example:**
```swift
let constraints = MultivariateConstraint<VectorN<Double>>.nonNegativity(dimension: 5)
// Creates 5 constraints: w₁≥0, w₂≥0, w₃≥0, w₄≥0, w₅≥0
```

#### Position Limits
Upper bounds on each component.

```swift
static func positionLimit(_ max: Double, dimension: Int) -> [MultivariateConstraint<VectorN<Double>>]
// Returns n inequality constraints: wᵢ ≤ max for all i
```

**Example:**
```swift
// No position > 30%
let limits = MultivariateConstraint<VectorN<Double>>.positionLimit(0.30, dimension: 10)
```

#### Box Constraints
Both lower and upper bounds.

```swift
static func boxConstraints(
    min: Double,
    max: Double,
    dimension: Int
) -> [MultivariateConstraint<VectorN<Double>>]
// Enforces: min ≤ wᵢ ≤ max for all i
```

**Example:**
```swift
// Each position between 5% and 40%
let box = MultivariateConstraint<VectorN<Double>>.boxConstraints(
    min: 0.05,
    max: 0.40,
    dimension: 8
)
```

### Custom Constraints

#### Equality Constraints

```swift
// Linear constraint: x + 2y + 3z = 10
let linearEq: MultivariateConstraint<VectorN<Double>> = .equality { v in
    return v[0] + 2*v[1] + 3*v[2] - 10
}

// Nonlinear constraint: x² + y² = 1 (circle)
let circle: MultivariateConstraint<VectorN<Double>> = .equality { v in
    return v[0]*v[0] + v[1]*v[1] - 1
}
```

#### Inequality Constraints

```swift
// Linear inequality: x + y ≤ 5
let linearIneq: MultivariateConstraint<VectorN<Double>> = .inequality { v in
    return v[0] + v[1] - 5  // g(x) ≤ 0 form
}

// Nonlinear inequality: x² + y² ≤ 4 (inside circle)
let insideCircle: MultivariateConstraint<VectorN<Double>> = .inequality { v in
    return v[0]*v[0] + v[1]*v[1] - 4
}

// Capacity constraint: production ≤ capacity
let capacity: MultivariateConstraint<VectorN<Double>> = .inequality { production in
    let used = production[0] * 2.0 + production[1] * 1.5  // Resource usage
    return used - 1000  // capacity = 1000
}
```

---

## Equality-Constrained Optimization

### What Problems Does It Solve?

Solves: **minimize f(x) subject to h(x) = 0**

Examples:
- Portfolio optimization with budget constraint (Σwᵢ = 1)
- Resource allocation with total resource constraint
- Curve fitting through specific points

### Quick Start

```swift
import BusinessMath

// Minimize x² + y² subject to x + y = 1
let objective: (VectorN<Double>) -> Double = { v in
    v[0]*v[0] + v[1]*v[1]
}

let constraints = [
    MultivariateConstraint<VectorN<Double>>.equality { v in
        v[0] + v[1] - 1  // x + y = 1
    }
]

let optimizer = ConstrainedOptimizer<VectorN<Double>>()
let result = try optimizer.minimize(
    objective,
    from: VectorN([0.5, 0.5]),
    subjectTo: constraints
)

print("Solution: \(result.solution)")  // [0.5, 0.5]
print("Lagrange multipliers: \(result.lagrangeMultipliers ?? [])")
```

### API Reference

#### `ConstrainedOptimizer<V: VectorSpace>`

Uses augmented Lagrangian method for equality constraints.

```swift
struct ConstrainedOptimizer<V: VectorSpace> {
    init(
        maxIterations: Int = 200,
        tolerance: Double = 1e-6,
        penaltyIncrease: Double = 10.0
    )

    func minimize(
        _ objective: @escaping (V) -> Double,
        from initialGuess: V,
        subjectTo constraints: [MultivariateConstraint<V>]
    ) throws -> OptimizationResult<V>

    func maximize(
        _ objective: @escaping (V) -> Double,
        from initialGuess: V,
        subjectTo constraints: [MultivariateConstraint<V>]
    ) throws -> OptimizationResult<V>
}
```

**Result includes:**
- `solution`: Optimal point
- `value`: Objective value at optimum
- `lagrangeMultipliers`: Shadow prices (sensitivity to constraints)
- `converged`: Whether optimization converged
- `iterations`: Number of iterations taken

### Lagrange Multipliers (Shadow Prices)

The Lagrange multiplier tells you how much the objective would improve if you relaxed the constraint slightly.

**Example:**
```swift
let result = try optimizer.minimize(objective, from: initial, subjectTo: constraints)

if let multipliers = result.lagrangeMultipliers {
    for (i, λ) in multipliers.enumerated() {
        print("Constraint \(i): λ = \(λ)")
        print("  Relaxing this constraint by 1 unit improves objective by \(λ)")
    }
}
```

**Applications:**
- **Portfolio**: λ for budget constraint = marginal value of additional capital
- **Production**: λ for capacity constraint = value of additional capacity
- **Resource allocation**: λ shows which constraints are binding

### Detailed Example

```swift
// Portfolio optimization with budget constraint
let returns = [0.10, 0.12, 0.15]
let covariance = [
    [0.04, 0.01, 0.02],
    [0.01, 0.09, 0.03],
    [0.02, 0.03, 0.16]
]

// Objective: Minimize variance (risk)
let variance: (VectorN<Double>) -> Double = { w in
    var v = 0.0
    for i in 0..<3 {
        for j in 0..<3 {
            v += w[i] * covariance[i][j] * w[j]
        }
    }
    return v
}

// Constraint: Weights sum to 1
let constraints = [MultivariateConstraint<VectorN<Double>>.budgetConstraint]

let optimizer = ConstrainedOptimizer<VectorN<Double>>()
let result = try optimizer.minimize(
    variance,
    from: VectorN([1.0/3, 1.0/3, 1.0/3]),
    subjectTo: constraints
)

print("Optimal weights: \(result.solution.components)")
print("Portfolio risk: \(sqrt(result.value))")
print("Shadow price: \(result.lagrangeMultipliers?.first ?? 0)")
```

---

## Inequality-Constrained Optimization

### What Problems Does It Solve?

Solves: **minimize f(x) subject to h(x) = 0 and g(x) ≤ 0**

Examples:
- Portfolio with no short-selling (wᵢ ≥ 0)
- Production with capacity limits (production ≤ capacity)
- Position limits (5% ≤ wᵢ ≤ 30%)

### Quick Start

```swift
import BusinessMath

// Minimize (x-1)² + (y-1)² subject to x≥0, y≥0, x+y≤2
let objective: (VectorN<Double>) -> Double = { v in
    let x = v[0] - 1
    let y = v[1] - 1
    return x*x + y*y
}

let constraints: [MultivariateConstraint<VectorN<Double>>] = [
    .inequality { v in -v[0] },        // x ≥ 0 → -x ≤ 0
    .inequality { v in -v[1] },        // y ≥ 0 → -y ≤ 0
    .inequality { v in v[0] + v[1] - 2 }  // x+y ≤ 2
]

let optimizer = InequalityOptimizer<VectorN<Double>>()
let result = try optimizer.minimize(
    objective,
    from: VectorN([0.5, 0.5]),
    subjectTo: constraints
)

print("Solution: \(result.solution)")  // [1, 1]
```

### API Reference

#### `InequalityOptimizer<V: VectorSpace>`

Uses augmented Lagrangian with quadratic penalties for mixed equality/inequality constraints.

```swift
struct InequalityOptimizer<V: VectorSpace> {
    init(
        maxIterations: Int = 200,
        tolerance: Double = 1e-6
    )

    func minimize(
        _ objective: @escaping (V) -> Double,
        from initialGuess: V,
        subjectTo constraints: [MultivariateConstraint<V>]
    ) throws -> OptimizationResult<V>

    func maximize(
        _ objective: @escaping (V) -> Double,
        from initialGuess: V,
        subjectTo constraints: [MultivariateConstraint<V>]
    ) throws -> OptimizationResult<V>
}
```

### Quadratic Penalty Method

The optimizer uses **quadratic penalties** for inequality constraints:
- Adds (ρ/2)·max(0, g(x))² to objective for each inequality g(x) ≤ 0
- Only penalizes violations (satisfied constraints contribute zero)
- ρ → ∞ as optimization progresses, making violations increasingly costly
- Works for both interior and boundary optima

**Key advantages:**
- No requirement for strictly interior starting points
- Handles inactive constraints naturally (no penalty when g < 0)
- Converges correctly for problems where optimum is interior to all constraints
- Smooth, differentiable penalties suitable for gradient-based methods

### Detailed Example

```swift
// Portfolio optimization: minimize variance with no short-selling
// Problem: minimize w'Cw subject to Σw = 1, w ≥ 0

let covariance = [
    [0.04, 0.01, 0.02],
    [0.01, 0.09, 0.03],
    [0.02, 0.03, 0.16]
]

// Objective: Minimize portfolio variance
let portfolioVariance: (VectorN<Double>) -> Double = { w in
    var variance = 0.0
    for i in 0..<3 {
        for j in 0..<3 {
            variance += w[i] * covariance[i][j] * w[j]
        }
    }
    return variance
}

// Constraints:
// 1. Budget: Σw = 1 (equality)
// 2. No short-selling: w ≥ 0 (inequalities)
let constraints: [MultivariateConstraint<VectorN<Double>>] = [
    .budgetConstraint  // Σw = 1
] + MultivariateConstraint<VectorN<Double>>.nonNegativity(dimension: 3)  // w ≥ 0

// Initial guess: equal weights
let initial = VectorN([1.0/3, 1.0/3, 1.0/3])

let optimizer = InequalityOptimizer<VectorN<Double>>()
let result = try optimizer.minimize(
    portfolioVariance,
    from: initial,
    subjectTo: constraints
)

print("Optimal portfolio:")
for (i, w) in result.solution.toArray().enumerated() {
    print("  Asset \(i+1): \(String(format: "%.1f", w * 100))%")
}
print("Portfolio variance: \(String(format: "%.6f", result.objectiveValue))")
print("Portfolio volatility: \(String(format: "%.2f", sqrt(result.objectiveValue) * 100))%")
```

---

## Integration Examples

### Portfolio Optimization (Complete)

```swift
// Combining everything: Min variance, target return, position limits
let optimizer = PortfolioOptimizer(
    expectedReturns: [0.08, 0.10, 0.12, 0.15],
    covarianceMatrix: covariance
)

// Constraint set with position limits
let result = try optimizer.minimumVariance(
    constraints: .boxConstrained(min: 0.05, max: 0.35)
)

print("Weights: \(result.weights)")
print("Risk: \(result.risk * 100)%")
print("Return: \(result.expectedReturn * 100)%")
```

### Resource Allocation

```swift
// Allocate budget across projects to maximize value
let projectValues = [100.0, 150.0, 200.0]  // Value of each project
let projectCosts = [50.0, 75.0, 100.0]     // Cost of each project
let totalBudget = 200.0

// Objective: Maximize total value
let value: (VectorN<Double>) -> Double = { allocation in
    var total = 0.0
    for i in 0..<3 {
        total += allocation[i] * projectValues[i]
    }
    return -total  // Negative for minimization
}

// Constraints: Budget limit, non-negative allocations (0-100% per project)
let constraints: [MultivariateConstraint<VectorN<Double>>] = [
    .inequality { allocation in
        let totalCost = (0..<3).map { i in
            allocation[i] * projectCosts[i]
        }.reduce(0, +)
        return totalCost - totalBudget  // ≤ budget
    }
] + MultivariateConstraint<VectorN<Double>>.nonNegativity(dimension: 3)
  + MultivariateConstraint<VectorN<Double>>.positionLimit(1.0, dimension: 3)

let optimizer = InequalityOptimizer<VectorN<Double>>()
let result = try optimizer.minimize(
    value,
    from: VectorN([0.5, 0.5, 0.5]),
    subjectTo: constraints
)

print("Optimal allocations:")
for (i, alloc) in result.solution.components.enumerated() {
    let funding = alloc * projectCosts[i]
    print("  Project \(i+1): \(Int(alloc * 100))% → $\(Int(funding))")
}
```

---

## Best Practices

### 1. Constraint Formulation

```swift
// Good: Use g(x) ≤ 0 form for inequalities
.inequality { x in x[0] - 10 }  // x ≤ 10

// Bad: Don't use ≥ form (negate it)
.inequality { x in 10 - x[0] }  // This is x ≥ 10, reformulate!
```

### 2. Initial Guess

```swift
// Good: Strictly feasible initial guess
let feasible = VectorN([0.1, 0.1, 0.8])  // All constraints satisfied strictly

// Bad: On boundary or infeasible
let boundary = VectorN([0.0, 0.0, 1.0])  // On boundary (w₀=0, w₁=0)
let infeasible = VectorN([1.5, -0.3, 0.8])  // Negative weight!
```

### 3. Constraint Ordering

```swift
// Good: Equality constraints first, then inequalities
let constraints = [
    .equality { /* ... */ },    // Equality first
    .inequality { /* ... */ },  // Then inequalities
    .inequality { /* ... */ }
]
```

### 4. Monitoring Convergence

```swift
let result = try optimizer.minimize(objective, from: initial, subjectTo: constraints)

// Check convergence
if !result.converged {
    print("Warning: Did not converge")
    print("Constraint violations:")
    for constraint in constraints {
        let violation = constraint.violation(at: result.solution)
        if abs(violation) > 1e-6 {
            print("  Violation: \(violation)")
        }
    }
}

// Check shadow prices (if available)
if let multipliers = result.lagrangeMultipliers {
    print("Shadow prices:")
    for (i, λ) in multipliers.enumerated() {
        if abs(λ) > 1e-6 {
            print("  Constraint \(i): λ = \(λ)")
        }
    }
}
```

### 5. Scaling

```swift
// Bad: Variables on wildly different scales
let unscaled = VectorN([1_000_000, 0.0001, 50])

// Good: Scale to similar magnitudes
let scaled = VectorN([1.0, 1.0, 1.0])
// Then scale back in constraints and objectives
```

---

## Summary

This module completes the optimization framework with **proper constraint handling**:

- **Constraint Infrastructure**: Type-safe, reusable constraint specifications
- **Equality Constraints**: Augmented Lagrangian method with shadow prices
- **Inequality Constraints**: Augmented Lagrangian with quadratic penalties with logarithmic barriers
- **Portfolio Integration**: All portfolio methods use proper constraints

**Key Capabilities:**
- Optimize with budget constraints (Σw = 1)
- Handle non-negativity (w ≥ 0)
- Enforce position limits (w ≤ max)
- Target return constraints (E[r] ≥ target)
- Compute shadow prices (Lagrange multipliers)

**Next Steps:**
1. Try constrained optimization on your problems
2. Experiment with different constraint combinations
3. Use shadow prices for sensitivity analysis
4. Look at applied examples for business applications

For more information, see source files and comprehensive tests.
