//
//  RealOptions.swift
//  BusinessMath
//
//  Created by Justin Purnell on 10/31/25.
//

import Foundation
import Numerics

// MARK: - RealOptionsAnalysis

/// Real options for strategic business decisions.
///
/// `RealOptionsAnalysis` applies option pricing theory to value managerial
/// flexibility and strategic choices. Common real options include:
/// - Option to expand (call option on growth opportunities)
/// - Option to abandon (put option on salvage value)
/// - Option to delay (American call on project initiation)
///
/// ## Usage
///
/// ```swift
/// let projectValue = RealOptionsAnalysis<Double>.expansionOption(
///     baseNPV: 10_000_000,
///     expansionCost: 5_000_000,
///     expansionNPV: 8_000_000,
///     volatility: 0.30,
///     timeToDecision: 2.0,
///     riskFreeRate: 0.05
/// )
/// ```
public struct RealOptionsAnalysis<T: Real & Sendable> {

	// MARK: - Expansion Option

	/// Value option to expand operations.
	///
	/// Models the right (but not obligation) to expand as a call option where:
	/// - Underlying = Value of expansion
	/// - Strike = Cost to expand
	///
	/// - Parameters:
	///   - baseNPV: NPV of base project without expansion.
	///   - expansionCost: Cost to implement expansion.
	///   - expansionNPV: NPV generated by expansion.
	///   - volatility: Volatility of expansion value.
	///   - timeToDecision: Years until expansion decision must be made.
	///   - riskFreeRate: Risk-free rate.
	/// - Returns: Total project value (base + option value).
	public static func expansionOption(
		baseNPV: T,
		expansionCost: T,
		expansionNPV: T,
		volatility: T,
		timeToDecision: T,
		riskFreeRate: T
	) -> T {
		// Model as call option
		let spotPrice = expansionNPV  // Value of expansion
		let strikePrice = expansionCost  // Cost to expand

		let optionValue = BlackScholesModel<T>.price(
			optionType: .call,
			spotPrice: spotPrice,
			strikePrice: strikePrice,
			timeToExpiry: timeToDecision,
			riskFreeRate: riskFreeRate,
			volatility: volatility
		)

		return baseNPV + optionValue
	}

	// MARK: - Abandonment Option

	/// Value option to abandon project.
	///
	/// Models the right (but not obligation) to abandon as a put option where:
	/// - Underlying = Project continuation value
	/// - Strike = Salvage value from abandonment
	///
	/// - Parameters:
	///   - projectNPV: NPV if project continues.
	///   - salvageValue: Value recovered if abandoned.
	///   - volatility: Volatility of project value.
	///   - timeToDecision: Years until abandonment decision.
	///   - riskFreeRate: Risk-free rate.
	/// - Returns: Total project value (NPV + abandonment option).
	public static func abandonmentOption(
		projectNPV: T,
		salvageValue: T,
		volatility: T,
		timeToDecision: T,
		riskFreeRate: T
	) -> T {
		// Model as put option
		let spotPrice = projectNPV
		let strikePrice = salvageValue

		let optionValue = BlackScholesModel<T>.price(
			optionType: .put,
			spotPrice: spotPrice,
			strikePrice: strikePrice,
			timeToExpiry: timeToDecision,
			riskFreeRate: riskFreeRate,
			volatility: volatility
		)

		return projectNPV + optionValue
	}

	// MARK: - Decision Tree Analysis

	/// Evaluate decision tree using backward induction.
	///
	/// - Parameter root: Root node of decision tree.
	/// - Returns: Expected value of the decision tree.
	public static func decisionTree(root: DecisionNode<T>) -> T {
		return evaluateNode(root)
	}

	private static func evaluateNode(_ node: DecisionNode<T>) -> T {
		switch node.type {
		case .terminal:
			return node.value

		case .chance:
			// Expected value over branches
			var expectedValue: T = 0
			for branch in node.branches {
				expectedValue += branch.probability * evaluateNode(branch.node)
			}
			return expectedValue

		case .decision:
			// Choose best decision
			guard !node.branches.isEmpty else { return node.value }

			var bestValue: T = evaluateNode(node.branches[0].node)
			for branch in node.branches.dropFirst() {
				let value = evaluateNode(branch.node)
				bestValue = max(bestValue, value)
			}
			return bestValue
		}
	}
}

// MARK: - DecisionNode

/// Node in a decision tree.
public struct DecisionNode<T: Real & Sendable>: Sendable {
	/// Type of node (terminal, chance, or decision).
	public let type: NodeType

	/// Value at this node (for terminal nodes).
	public let value: T

	/// Branches from this node.
	public let branches: [Branch<T>]

	/// Type of decision tree node.
	public enum NodeType: Sendable {
		/// Terminal node (leaf) with a fixed value.
		case terminal

		/// Chance node (uncertain outcome).
		case chance

		/// Decision node (choice point).
		case decision
	}

	public init(type: NodeType, value: T = T(0), branches: [Branch<T>] = []) {
		self.type = type
		self.value = value
		self.branches = branches
	}
}

// MARK: - Branch

/// Branch in a decision tree.
public struct Branch<T: Real & Sendable>: Sendable {
	/// Probability (for chance nodes, should sum to 1).
	public let probability: T

	/// Node this branch leads to.
	public let node: DecisionNode<T>

	public init(probability: T, node: DecisionNode<T>) {
		self.probability = probability
		self.node = node
	}
}
