//
//  CommandLineVisualization.swift
//  BusinessMath
//
//  Created by Justin Purnell on 10/22/25.
//

import Foundation

/// Visualization utilities for command-line display of simulation results and data analysis.
///
/// This module provides text-based visualization functions that render charts and graphs
/// directly in the terminal using Unicode characters and formatting.
///
/// ## Use Cases
///
/// - Display Monte Carlo simulation distributions
/// - Visualize histogram data in terminal environments
/// - Quick data exploration without external plotting tools
/// - CLI applications and scripts
///
/// ## Example
///
/// ```swift
/// let results = SimulationResults(values: simulationData)
/// let histogram = results.histogram(bins: 20)
/// let plot = plotHistogram(histogram)
/// print(plot)
/// ```

// MARK: - Histogram Plotting

/// Renders a horizontal bar chart histogram for command-line display.
///
/// Creates a visual representation of histogram data using Unicode block characters (█).
/// The output includes:
/// - Header with bin count and total sample count
/// - Each bin showing: range, bar graph, count, and percentage
/// - Automatic scaling so the largest bin uses the full bar width
///
/// ## Output Format
///
/// ```
/// Histogram (10 bins, 1,000 samples):
///
/// [    0.00 -   10.00):  ████████████ 234 ( 23.4%)
/// [   10.00 -   20.00):  ██████████████████ 456 ( 45.6%)
/// [   20.00 -   30.00):  ████████ 156 ( 15.6%)
/// ...
/// ```
///
/// ## Features
///
/// - **Auto-scaling**: Bars automatically scale relative to the maximum count
/// - **Unicode rendering**: Uses █ (U+2588) for solid bar appearance
/// - **Smart formatting**: Adjusts decimal places based on value magnitude
/// - **Percentage display**: Shows percentage of total for each bin
/// - **Clean alignment**: Right-aligned numbers for easy reading
///
/// ## Parameters
///
/// - Parameter histogram: Array of tuples containing range and count for each bin,
///   typically generated by `SimulationResults.histogram(bins:)`
///
/// - Returns: A formatted string containing the complete histogram visualization
///
/// ## Example
///
/// ```swift
/// // Generate histogram from simulation results
/// let results = SimulationResults(values: revenueData)
/// let histogram = results.histogram(bins: 20)
///
/// // Plot and display
/// let plot = plotHistogram(histogram)
/// print(plot)
///
/// // Output:
/// // Histogram (20 bins, 10,000 samples):
/// //
/// // [  950.00 - 1,000.00):  ████████████ 234 (  2.3%)
/// // [1,000.00 - 1,050.00):  ██████████████████ 456 (  4.6%)
/// // ...
/// ```
///
/// ## Customization
///
/// The function uses these default parameters:
/// - Maximum bar width: 50 characters
/// - Decimal places: 2 (auto-adjusts for large numbers)
/// - Bar character: █ (solid block)
///
/// For custom visualizations, create your own histogram data structure
/// and pass it to this function.
///
/// - Complexity: O(n) where n is the number of bins
public func plotHistogram(_ histogram: [(range: Range<Double>, count: Int)]) -> String {
	// Handle empty histogram
	guard !histogram.isEmpty else {
		return "Empty histogram"
	}

	// Calculate total count and max count for scaling
	let totalCount = histogram.reduce(0) { $0 + $1.count }
	let maxCount = histogram.map { $0.count }.max() ?? 1

	// Configuration
	let maxBarWidth = 50

	// Determine decimal places based on value magnitude
	let maxValue = histogram.map { $0.range.upperBound }.max() ?? 1.0
	let decimalPlaces: Int
	if maxValue > 1000 {
		decimalPlaces = 0
	} else if maxValue > 10 {
		decimalPlaces = 1
	} else {
		decimalPlaces = 2
	}

	// Build output string
	var output = "Histogram (\(histogram.count) bin\(histogram.count == 1 ? "" : "s"), \(totalCount) sample\(totalCount == 1 ? "" : "s")):\n\n"

	// Render each bin
	for bin in histogram {
		// Calculate bar width (proportional to count)
		let barWidth = maxCount > 0 ? Int(Double(bin.count) / Double(maxCount) * Double(maxBarWidth)) : 0
		let bar = String(repeating: "█", count: barWidth)

		// Pad bar to fixed width for alignment
		let paddedBar = bar.padding(toLength: maxBarWidth, withPad: " ", startingAt: 0)

		// Calculate percentage
		let percentage = totalCount > 0 ? (Double(bin.count) / Double(totalCount)) : 0.0

		// Format the line based on decimal places
		let line: String
		line = "[\(bin.range.lowerBound.number(decimalPlaces).paddingLeft(toLength: 8)) - \(bin.range.upperBound.number(decimalPlaces).paddingLeft(toLength: 8))):  \(paddedBar) \("\(bin.count)".paddingLeft(toLength: 4)) (\(percentage.percent(1)))\n"
		output += line
	}

	return output
}

// MARK: - Tornado Diagram Plotting

/// Renders a tornado diagram for command-line display showing sensitivity analysis results.
///
/// Creates a horizontal bar chart showing the impact of each input driver on an output metric.
/// Drivers are displayed in order of impact (largest first), with bars extending left and right
/// from a central baseline representing the base case output.
///
/// ## Output Format
///
/// ```
/// Tornado Diagram - Sensitivity Analysis
/// Base Case: 1,000.00
///
/// Revenue        ◄████████████████████████████►             Impact: 500.00 (50.0%)
///                750                     1000                     1250
///
/// Costs          ◄████████████████►                         Impact: 300.00 (30.0%)
///                850            1000                1150
///
/// Marketing      ◄████►                                     Impact: 100.00 (10.0%)
///                950   1000              1050
/// ```
///
/// ## Features
///
/// - **Ranked by impact**: Drivers with the largest impact appear first
/// - **Bidirectional bars**: Shows both decrease and increase scenarios
/// - **Base case marker**: Central vertical line shows baseline
/// - **Impact metrics**: Shows absolute and percentage impact
/// - **Value labels**: Shows low/base/high values for each driver
///
/// ## Interpretation
///
/// - **Bar length**: Longer bars = greater impact on output
/// - **Left side**: Output when driver is decreased
/// - **Right side**: Output when driver is increased
/// - **Asymmetry**: Unequal left/right bars indicate non-linear relationships
///
/// ## Parameters
///
/// - Parameter analysis: The tornado diagram analysis results from `runTornadoAnalysis(...)`
///
/// - Returns: A formatted string containing the complete tornado diagram visualization
///
/// ## Example
///
/// ```swift
/// let tornado = try runTornadoAnalysis(
///     baseCase: baseCase,
///     entity: entity,
///     periods: periods,
///     inputDrivers: ["Revenue", "Costs", "Marketing"],
///     variationPercent: 0.20,
///     steps: 2,
///     builder: builder
/// ) { projection in
///     projection.incomeStatement.netIncome[q1]!
/// }
///
/// let plot = plotTornadoDiagram(tornado)
/// print(plot)
/// ```
///
/// - Complexity: O(n) where n is the number of input drivers
public func plotTornadoDiagram(_ analysis: TornadoDiagramAnalysis) -> String {
	// Handle empty analysis
	guard !analysis.inputs.isEmpty else {
		return "Empty tornado diagram (no inputs)"
	}

	let baseCaseOutput = analysis.baseCaseOutput

	// Find the maximum impact for scaling bar lengths
	var maxImpact = 0.0
	for input in analysis.inputs {
		let impact = analysis.impacts[input] ?? 0.0
		maxImpact = max(maxImpact, impact)
	}

	// Configuration
	let maxBarWidth = 25  // Max characters for each side (left/right)
	let maxInputNameWidth = analysis.inputs.map { $0.count }.max() ?? 15

	// Determine decimal places based on magnitude
	let maxValue = max(abs(baseCaseOutput), maxImpact)
	let decimalPlaces: Int
	if maxValue > 1000 {
		decimalPlaces = 0
	} else if maxValue > 10 {
		decimalPlaces = 1
	} else {
		decimalPlaces = 2
	}

	// Build output string
	var output = "Tornado Diagram - Sensitivity Analysis\n"
	output += "Base Case: \(baseCaseOutput.number(decimalPlaces))\n\n"
	
	// Format the bar line
	func barLine(_ paddedName: String, _ paddedLeftBar: String, _ paddedRightBar: String) -> String {
		return "\(paddedName) ◄\(paddedLeftBar)|\(paddedRightBar)►"
	}

	// Render each input (already sorted by impact)
	for input in analysis.inputs {
		let low = analysis.lowValues[input] ?? baseCaseOutput
		let high = analysis.highValues[input] ?? baseCaseOutput
		let impact = analysis.impacts[input] ?? 0.0

		// Calculate bar widths based on IMPACT, not deviation from base
		// Total bar width should be proportional to impact
		let totalBarWidth: Int
		if maxImpact > 0 {
			totalBarWidth = Int((impact / maxImpact) * Double(maxBarWidth * 2))
		} else {
			totalBarWidth = 0
		}

		// Split the bar at the base case position
		// Determine what fraction of the range is left of base case
		let range = high - low
		var fractionLeft: Double
		if range > 0 {
			fractionLeft = (baseCaseOutput - low) / range
			// Clamp to [0, 1] in case base is outside [low, high]
			fractionLeft = max(0, min(1, fractionLeft))
		} else {
			fractionLeft = 0.5
		}

		let leftWidth = Int(Double(totalBarWidth) * fractionLeft)
		let rightWidth = totalBarWidth - leftWidth

		// Create bars with direction indicators
		let leftBar = String(repeating: "█", count: leftWidth)
		let rightBar = String(repeating: "█", count: rightWidth)

		// Pad input name for alignment
		let paddedName = input.padding(toLength: maxInputNameWidth, withPad: " ", startingAt: 0)

		// Calculate percentage impact
		let percentImpact = baseCaseOutput != 0 ? (abs(impact) / abs(baseCaseOutput)) : 0.0

		// Pad bars: left bar is right-aligned (padding on left), right bar is left-aligned (padding on right)
		let paddedLeftBar = String(repeating: " ", count: maxBarWidth - leftWidth) + leftBar
		let paddedRightBar = rightBar.padding(toLength: maxBarWidth, withPad: " ", startingAt: 0)

		// Format impact info
		let impactInfo = " Impact: \(impact.number(decimalPlaces)) \(percentImpact.percent(decimalPlaces == 0 ? 1 : decimalPlaces))"

		output += barLine(paddedName, paddedLeftBar, paddedRightBar) + impactInfo + "\n"

		// Add value labels underneath
		let valueLabels = "\(String(repeating: " ", count: maxInputNameWidth + 3))\(low.number(decimalPlaces))\(String(repeating: " ", count: maxBarWidth - 8))\(baseCaseOutput.number(decimalPlaces))\(String(repeating: " ", count: maxBarWidth - 8))\(high.number(decimalPlaces)))"
//		let valueLabels = String(format: "%@%.\(decimalPlaces)f%@%.\(decimalPlaces)f%@%.\(decimalPlaces)f\n",
//			String(repeating: " ", count: maxInputNameWidth + 3),
//			low,
//			String(repeating: " ", count: maxBarWidth - 8),
//			baseCaseOutput,
//			String(repeating: " ", count: maxBarWidth - 8),
//			high
//		)

		output += valueLabels + "\n"
	}

	return output
}

