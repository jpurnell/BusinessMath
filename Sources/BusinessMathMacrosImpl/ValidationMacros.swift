//
//  ValidationMacros.swift
//  BusinessMath
//
//  Created by Justin Purnell on 2025-12-29.
//

import SwiftSyntax
import SwiftSyntaxMacros
import SwiftSyntaxBuilder
import SwiftCompilerPlugin
import SwiftDiagnostics
import Foundation

// MARK: - Validation Error Type

/// Error type generated by validation macros
public struct ValidationError: Error, CustomStringConvertible {
    public let property: String
    public let violation: String
    public let value: (any Sendable)?

    public var description: String {
        if let value = value {
            return "Validation failed for '\(property)': \(violation) (value: \(value))"
        } else {
            return "Validation failed for '\(property)': \(violation)"
        }
    }
}

// MARK: - Property-Level Validation Macros

/// Marks a property as requiring positive values (> 0)
public struct PositiveMacro: PeerMacro {
    public static func expansion(
        of node: AttributeSyntax,
        providingPeersOf declaration: some DeclSyntaxProtocol,
        in context: some MacroExpansionContext
    ) throws -> [DeclSyntax] {
        // This macro is detected by @Validated, not expanded directly
        return []
    }
}

/// Marks a property as requiring non-negative values (>= 0)
public struct NonNegativeMacro: PeerMacro {
    public static func expansion(
        of node: AttributeSyntax,
        providingPeersOf declaration: some DeclSyntaxProtocol,
        in context: some MacroExpansionContext
    ) throws -> [DeclSyntax] {
        return []
    }
}

/// Marks a property as requiring values within a specified range
public struct RangeMacro: PeerMacro {
    public static func expansion(
        of node: AttributeSyntax,
        providingPeersOf declaration: some DeclSyntaxProtocol,
        in context: some MacroExpansionContext
    ) throws -> [DeclSyntax] {
        return []
    }
}

/// Marks a property as requiring a minimum value
public struct MinMacro: PeerMacro {
    public static func expansion(
        of node: AttributeSyntax,
        providingPeersOf declaration: some DeclSyntaxProtocol,
        in context: some MacroExpansionContext
    ) throws -> [DeclSyntax] {
        return []
    }
}

/// Marks a property as requiring a maximum value
public struct MaxMacro: PeerMacro {
    public static func expansion(
        of node: AttributeSyntax,
        providingPeersOf declaration: some DeclSyntaxProtocol,
        in context: some MacroExpansionContext
    ) throws -> [DeclSyntax] {
        return []
    }
}

/// Marks a collection property as requiring non-empty values
public struct NonEmptyMacro: PeerMacro {
    public static func expansion(
        of node: AttributeSyntax,
        providingPeersOf declaration: some DeclSyntaxProtocol,
        in context: some MacroExpansionContext
    ) throws -> [DeclSyntax] {
        return []
    }
}

// MARK: - Struct-Level Validation Macro

/// Macro for adding validation to struct properties
/// Scans properties for validation attributes and generates validation logic
public struct ValidatedMacro: MemberMacro {
    public static func expansion(
        of node: AttributeSyntax,
        providingMembersOf declaration: some DeclGroupSyntax,
		conformingTo protocols: [TypeSyntax],
        in context: some MacroExpansionContext
    ) throws -> [DeclSyntax] {

        // Extract struct members
        guard let structDecl = declaration.as(StructDeclSyntax.self) else {
            return []
        }

        // Collect validation rules from properties
        var validationChecks: [String] = []

        for member in structDecl.memberBlock.members {
            guard let varDecl = member.decl.as(VariableDeclSyntax.self),
                  let binding = varDecl.bindings.first,
                  let pattern = binding.pattern.as(IdentifierPatternSyntax.self) else {
                continue
            }

            let propertyName = pattern.identifier.text

            // Check for validation attributes
            for attribute in varDecl.attributes {
                guard let attr = attribute.as(AttributeSyntax.self),
                      let attrName = attr.attributeName.as(IdentifierTypeSyntax.self)?.name.text else {
                    continue
                }

                switch attrName {
                case "Positive":
                    validationChecks.append("""
                            if \(propertyName) <= 0 {
                                throw ValidationError(
                                    property: "\(propertyName)",
                                    violation: "must be positive (> 0)",
                                    value: \(propertyName)
                                )
                            }
                    """)

                case "NonNegative":
                    validationChecks.append("""
                            if \(propertyName) < 0 {
                                throw ValidationError(
                                    property: "\(propertyName)",
                                    violation: "must be non-negative (>= 0)",
                                    value: \(propertyName)
                                )
                            }
                    """)

                case "Range":
                    // Extract range from arguments
                    if let arguments = attr.arguments?.as(LabeledExprListSyntax.self),
                       let firstArg = arguments.first {
                        let rangeExpr = firstArg.expression.description.trimmingCharacters(in: CharacterSet.whitespaces)
                        validationChecks.append("""
                                let range_\(propertyName) = \(rangeExpr)
                                if !\(rangeExpr).contains(\(propertyName)) {
                                    throw ValidationError(
                                        property: "\(propertyName)",
                                        violation: "must be within range \\(range_\(propertyName))",
                                        value: \(propertyName)
                                    )
                                }
                        """)
                    }

                case "Min":
                    if let arguments = attr.arguments?.as(LabeledExprListSyntax.self),
                       let firstArg = arguments.first {
                        let minValue = firstArg.expression.description.trimmingCharacters(in: CharacterSet.whitespaces)
                        validationChecks.append("""
                                if \(propertyName) < \(minValue) {
                                    throw ValidationError(
                                        property: "\(propertyName)",
                                        violation: "must be at least \(minValue)",
                                        value: \(propertyName)
                                    )
                                }
                        """)
                    }

                case "Max":
                    if let arguments = attr.arguments?.as(LabeledExprListSyntax.self),
                       let firstArg = arguments.first {
                        let maxValue = firstArg.expression.description.trimmingCharacters(in: CharacterSet.whitespaces)
                        validationChecks.append("""
                                if \(propertyName) > \(maxValue) {
                                    throw ValidationError(
                                        property: "\(propertyName)",
                                        violation: "must be at most \(maxValue)",
                                        value: \(propertyName)
                                    )
                                }
                        """)
                    }

                case "NonEmpty":
                    validationChecks.append("""
                            if \(propertyName).isEmpty {
                                throw ValidationError(
                                    property: "\(propertyName)",
                                    violation: "must not be empty",
                                    value: nil
                                )
                            }
                    """)

                default:
                    break
                }
            }
        }

        // Generate validation method with all checks
        let validationBody = validationChecks.isEmpty
            ? "// No validation rules defined"
            : validationChecks.joined(separator: "\n")

        let validationMethod: DeclSyntax = """

        /// Validates all properties with validation attributes
        /// - Throws: ValidationError if any validation rule fails
        func validate() throws {
        \(raw: validationBody)
        }
        """

        let isValidProperty: DeclSyntax = """

        /// Returns true if all validation rules pass
        var isValid: Bool {
            do {
                try validate()
                return true
            } catch {
                return false
            }
        }
        """

        let validationErrorProperty: DeclSyntax = """

        /// Returns the first validation error, or nil if valid
        var validationError: ValidationError? {
            do {
                try validate()
                return nil
            } catch let error as ValidationError {
                return error
            } catch {
                return ValidationError(
                    property: "unknown",
                    violation: error.localizedDescription,
                    value: nil
                )
            }
        }
        """

        return [validationMethod, isValidProperty, validationErrorProperty]
    }
}
