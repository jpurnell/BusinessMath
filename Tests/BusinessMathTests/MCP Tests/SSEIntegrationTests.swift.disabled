import Testing
import Foundation
import Network
@testable import BusinessMathMCP

/// Integration tests for SSE functionality
///
/// These tests verify the complete SSE flow:
/// 1. Client opens SSE connection (GET /mcp/sse)
/// 2. Client sends JSON-RPC request with session ID (POST /mcp)
/// 3. Server routes response via SSE stream
@Suite("SSE Integration Tests")
struct SSEIntegrationTests {

    // MARK: - Connection Tests

    @Test("SSE connection returns correct headers")
    func testSSEConnectionHeaders() async throws {
        let transport = HTTPServerTransport(port: 9200)
        try await transport.connect()
        defer { Task { await transport.disconnect() } }

        try await Task.sleep(nanoseconds: 200_000_000)

        // Connect to SSE endpoint
        let url = URL(string: "http://localhost:9200/mcp/sse")!
        var request = URLRequest(url: url)
        request.httpMethod = "GET"
        request.timeoutInterval = 2.0

        let (statusCode, contentType, sessionId) = try await withTimeout(seconds: 3) {
            try await getSSEHeaders(request: request)
        }

        #expect(statusCode == 200, "SSE endpoint should return 200 OK")
        #expect(contentType?.contains("text/event-stream") == true, "Should return event-stream content type")
        #expect(sessionId != nil, "Should include X-Session-ID header")
        #expect(UUID(uuidString: sessionId ?? "") != nil, "Session ID should be valid UUID")
    }

    @Test("SSE session is registered in manager")
    func testSSESessionRegistration() async throws {
        let transport = HTTPServerTransport(port: 9201)
        try await transport.connect()
        defer { Task { await transport.disconnect() } }

        try await Task.sleep(nanoseconds: 200_000_000)

        // Open SSE connection
        let url = URL(string: "http://localhost:9201/mcp/sse")!
        var request = URLRequest(url: url)
        request.httpMethod = "GET"
        request.timeoutInterval = 2.0

        let (statusCode, _, sessionId) = try await withTimeout(seconds: 3) {
            try await getSSEHeaders(request: request)
        }

        #expect(statusCode == 200)
        #expect(sessionId != nil, "Session should be created")
    }

    @Test("Multiple SSE clients can connect simultaneously")
    func testMultipleSSEClients() async throws {
        let transport = HTTPServerTransport(port: 9202)
        try await transport.connect()
        defer { Task { await transport.disconnect() } }

        try await Task.sleep(nanoseconds: 200_000_000)

        // Open 3 SSE connections concurrently
        let url = URL(string: "http://localhost:9202/mcp/sse")!

        async let client1 = getSSEHeaders(request: URLRequest(url: url))
        async let client2 = getSSEHeaders(request: URLRequest(url: url))
        async let client3 = getSSEHeaders(request: URLRequest(url: url))

        let (result1, result2, result3) = try await withTimeout(seconds: 5) {
            try await (client1, client2, client3)
        }

        // All should succeed
        #expect(result1.0 == 200)
        #expect(result2.0 == 200)
        #expect(result3.0 == 200)

        // All should have unique session IDs
        let sessionIds = Set([result1.2, result2.2, result3.2].compactMap { $0 })
        #expect(sessionIds.count == 3, "Each client should get unique session ID")
    }

    @Test("SSE heartbeat is sent periodically")
    func testSSEHeartbeat() async throws {
        let transport = HTTPServerTransport(port: 9203)
        try await transport.connect()
        defer { Task { await transport.disconnect() } }

        try await Task.sleep(nanoseconds: 200_000_000)

        // Open SSE connection and read stream
        let url = URL(string: "http://localhost:9203/mcp/sse")!
        var request = URLRequest(url: url)
        request.httpMethod = "GET"

        let receivedHeartbeat = try await withTimeout(seconds: 35) {
            try await receiveSSEHeartbeat(request: request)
        }

        #expect(receivedHeartbeat, "Should receive heartbeat within 35 seconds")
    }

    // MARK: - Request/Response Flow Tests

    @Test("SSE request/response flow with session ID")
    func testSSERequestResponse() async throws {
        let transport = HTTPServerTransport(port: 9204)
        try await transport.connect()
        defer { Task { await transport.disconnect() } }

        try await Task.sleep(nanoseconds: 200_000_000)

        // Step 1: Open SSE connection
        let sseURL = URL(string: "http://localhost:9204/mcp/sse")!
        let sseRequest = URLRequest(url: sseURL)

        let (statusCode, _, sessionId) = try await withTimeout(seconds: 3) {
            try await getSSEHeaders(request: sseRequest)
        }

        #expect(statusCode == 200)
        guard let sessionId = sessionId else {
            Issue.record("No session ID received")
            return
        }

        // Step 2: Send JSON-RPC request with session ID header
        let rpcURL = URL(string: "http://localhost:9204/mcp")!
        var rpcRequest = URLRequest(url: rpcURL)
        rpcRequest.httpMethod = "POST"
        rpcRequest.setValue(sessionId, forHTTPHeaderField: "X-Session-ID")
        rpcRequest.setValue("application/json", forHTTPHeaderField: "Content-Type")

        let jsonRPCRequest = """
        {
          "jsonrpc": "2.0",
          "id": 1,
          "method": "tools/list",
          "params": {}
        }
        """

        rpcRequest.httpBody = jsonRPCRequest.data(using: .utf8)

        // Send request (response will come via SSE, not HTTP response)
        let (_, response) = try await URLSession.shared.data(for: rpcRequest)

        // The HTTP POST should return quickly (we're testing SSE routing)
        // In the actual implementation, responses go via SSE stream
        #expect(response is HTTPURLResponse, "Should receive HTTP response")
    }

    @Test("Server info endpoint shows SSE support")
    func testServerInfoEndpoint() async throws {
        let transport = HTTPServerTransport(port: 9205)
        try await transport.connect()
        defer { Task { await transport.disconnect() } }

        try await Task.sleep(nanoseconds: 200_000_000)

        let url = URL(string: "http://localhost:9205/mcp")!
        let (data, response) = try await URLSession.shared.data(from: url)

        let httpResponse = response as? HTTPURLResponse
        #expect(httpResponse?.statusCode == 200)

        let json = try JSONSerialization.jsonObject(with: data) as? [String: Any]
        #expect(json?["protocol"] as? String == "MCP over HTTP + SSE", "Should advertise SSE support")

        let endpoints = json?["endpoints"] as? [String: String]
        #expect(endpoints?["sse"] != nil, "Should document SSE endpoint")
        #expect(endpoints?["rpc"] != nil, "Should document RPC endpoint")
    }
}

// MARK: - Helper Functions

/// Get SSE response headers without blocking on stream
func getSSEHeaders(request: URLRequest) async throws -> (Int, String?, String?) {
    try await withCheckedThrowingContinuation { continuation in
        let delegate = SSEHeaderDelegate(continuation: continuation)
        let session = URLSession(configuration: .default, delegate: delegate, delegateQueue: nil)
        let task = session.dataTask(with: request)
        task.resume()
    }
}

/// Wait for SSE heartbeat (: comment line)
func receiveSSEHeartbeat(request: URLRequest) async throws -> Bool {
    try await withCheckedThrowingContinuation { continuation in
        let delegate = SSEHeartbeatDelegate(continuation: continuation)
        let session = URLSession(configuration: .default, delegate: delegate, delegateQueue: nil)
        let task = session.dataTask(with: request)
        task.resume()
    }
}

/// Execute async operation with timeout
func withTimeout<T>(seconds: Double, operation: @escaping () async throws -> T) async throws -> T {
    try await withThrowingTaskGroup(of: T.self) { group in
        group.addTask {
            try await operation()
        }

        group.addTask {
            try await Task.sleep(nanoseconds: UInt64(seconds * 1_000_000_000))
            throw SSEIntegrationTestError.timeout
        }

        guard let result = try await group.next() else {
            throw SSEIntegrationTestError.timeout
        }

        group.cancelAll()
        return result
    }
}

// MARK: - URLSession Delegates

/// Captures SSE response headers immediately
class SSEHeaderDelegate: NSObject, URLSessionDataDelegate {
    private let continuation: CheckedContinuation<(Int, String?, String?), Error>
    private var didResume = false

    init(continuation: CheckedContinuation<(Int, String?, String?), Error>) {
        self.continuation = continuation
    }

    func urlSession(_ session: URLSession, dataTask: URLSessionDataTask, didReceive response: URLResponse, completionHandler: @escaping (URLSession.ResponseDisposition) -> Void) {
        guard !didResume, let httpResponse = response as? HTTPURLResponse else {
            completionHandler(.allow)
            return
        }

        didResume = true
        let contentType = httpResponse.value(forHTTPHeaderField: "Content-Type")
        let sessionId = httpResponse.value(forHTTPHeaderField: "X-Session-ID")
        continuation.resume(returning: (httpResponse.statusCode, contentType, sessionId))

        dataTask.cancel()
        completionHandler(.cancel)
    }

    func urlSession(_ session: URLSession, task: URLSessionTask, didCompleteWithError error: Error?) {
        if !didResume, let error = error, (error as? URLError)?.code != .cancelled {
            didResume = true
            continuation.resume(throwing: error)
        }
    }
}

/// Waits for SSE heartbeat (: comment)
class SSEHeartbeatDelegate: NSObject, URLSessionDataDelegate {
    private let continuation: CheckedContinuation<Bool, Error>
    private var didResume = false

    init(continuation: CheckedContinuation<Bool, Error>) {
        self.continuation = continuation
    }

    func urlSession(_ session: URLSession, dataTask: URLSessionDataTask, didReceive data: Data) {
        guard !didResume else { return }

        // Check if this is a heartbeat (: followed by newline)
        if let string = String(data: data, encoding: .utf8), string.contains(":\n") {
            didResume = true
            continuation.resume(returning: true)
            dataTask.cancel()
        }
    }

    func urlSession(_ session: URLSession, task: URLSessionTask, didCompleteWithError error: Error?) {
        if !didResume {
            didResume = true
            if let error = error, (error as? URLError)?.code != .cancelled {
                continuation.resume(throwing: error)
            } else {
                continuation.resume(returning: false)
            }
        }
    }
}

enum SSEIntegrationTestError: Error {
    case timeout
    case invalidResponse
}
