//
//  PerformanceTests.swift
//  BusinessMath
//
//  Created by Justin Purnell on 10/15/25.
//

import Testing
import Foundation
@testable import BusinessMath

/// Performance tests for BusinessMath library.
///
/// These tests measure execution time for various operations to ensure
/// the library performs well with large datasets and complex calculations.
@Suite("Performance Tests")
struct PerformanceTests {

	// MARK: - Helper Functions

	/// Measures execution time of a block and returns duration in seconds.
	private func measure(_ block: () throws -> Void) rethrows -> TimeInterval {
		let start = Date()
		try block()
		let end = Date()
		return end.timeIntervalSince(start)
	}
	/// Measures execution time and returns both result and duration.
	private func measureWithResult<T>(_ block: () throws -> T) rethrows -> (result: T, duration: TimeInterval) {
		let start = Date()
		let result = try block()
		let end = Date()
		return (result, end.timeIntervalSince(start))
	}
	// MARK: - Time Series Performance

	@Test("Large time series creation - 10,000 periods")
	func largeTimeSeriesCreation10K() throws {
		let size = 10_000
		let periods = (0..<size).map { Period.month(year: 2000 + $0/12, month: ($0 % 12) + 1) }
		let values = (0..<size).map { Double($0) }

		let ts = TimeSeries(periods: periods, values: values)
		#expect(ts.count == size)
	}
	@Test("Large time series creation - 50,000 periods")
	func largeTimeSeriesCreation50K() throws {
		let size = 50_000
		let periods = (0..<size).map { Period.month(year: 2000 + $0/12, month: ($0 % 12) + 1) }
		let values = (0..<size).map { Double($0) }

		let ts = TimeSeries(periods: periods, values: values)
		#expect(ts.count == size)
	}
	@Test("Large time series subscript access")
	func largeTimeSeriesAccess() throws {
		let size = 10_000
		let periods = (0..<size).map { Period.month(year: 2000 + $0/12, month: ($0 % 12) + 1) }
		let values = (0..<size).map { Double($0) }
		let ts = TimeSeries(periods: periods, values: values)

		// Random access test
		for _ in 0..<100 {
			let randomIndex = Int.random(in: 0..<size)
			let value = ts[periods[randomIndex]]
			#expect(value == values[randomIndex])
		}
	}

	@Test("Large time series iteration")
	func largeTimeSeriesIteration() throws {
		let size = 10_000
		let periods = (0..<size).map { Period.month(year: 2000 + $0/12, month: ($0 % 12) + 1) }
		let values = (0..<size).map { Double($0) }
		let ts = TimeSeries(periods: periods, values: values)

		var sum = 0.0
		for value in ts {
			sum += value
		}
		#expect(sum > 0)
	}
	// MARK: - Time Series Operations Performance

	@Test("Chained operations on large time series")
	func chainedOperations() throws {
		let size = 5_000
		let periods = (0..<size).map { Period.month(year: 2000 + $0/12, month: ($0 % 12) + 1) }
		let values = (0..<size).map { 100_000.0 + Double($0) * 100 + Double.random(in: -500...500) }
		let ts = TimeSeries(periods: periods, values: values)


	}
		// Verify chained operations work
		let result = ts.map { $0 * 1.05 }.filter { $0 > 100_000 }
		#expect(result.count > 0)

	@Test("Moving average on large time series")
	func movingAverageLarge() throws {
		let size = 10_000
		let periods = (0..<size).map { Period.month(year: 2000 + $0/12, month: ($0 % 12) + 1) }
		let values = (0..<size).map { _ in 100.0 + Double.random(in: -10...10) }
		let ts = TimeSeries(periods: periods, values: values)


		let ma = ts.movingAverage(window: 12)
		#expect(ma.count > 0)

	}
	@Test("Exponential moving average on large time series")
	func exponentialMovingAverageLarge() throws {
		let size = 10_000
		let periods = (0..<size).map { Period.month(year: 2000 + $0/12, month: ($0 % 12) + 1) }
		let values = (0..<size).map { _ in 100.0 + Double.random(in: -10...10) }
		let ts = TimeSeries(periods: periods, values: values)


		let ema = ts.exponentialMovingAverage(alpha: 0.3)
		#expect(ema.count > 0)

	}
	// MARK: - NPV Performance

	@Test("NPV with 100 cash flows")
	func npv100CashFlows() throws {
		let cashFlows = (0..<100).map { $0 == 0 ? -1_000_000.0 : 50_000.0 }
	}

	@Test("NPV with 1,000 cash flows")
	func npv1000CashFlows() throws {
		let cashFlows = (0..<1000).map { $0 == 0 ? -10_000_000.0 : 50_000.0 }

	// MARK: - IRR Performance

	@Test("IRR with 10 cash flows")
	func irr10CashFlows() throws {
		let cashFlows = [-100_000.0, 20_000, 25_000, 30_000, 35_000, 40_000, 45_000, 50_000, 55_000, 60_000]

	@Test("IRR with 50 cash flows")
		}
	}

	// MARK: - XIRR Performance

	@Test("XIRR with irregular dates")
	func xirrPerformance() throws {
		let baseDate = Date()
		}
	}

	@Test("XNPV with many dates")
	func xnpvPerformance() throws {
		let baseDate = Date()
		}
	}

	// MARK: - Trend Model Performance

	@Test("Linear trend fitting - 1,000 points")
	func linearTrendFitting1000() throws {
		let size = 1_000
		let periods = (0..<size).map { Period.month(year: 2000 + $0/12, month: ($0 % 12) + 1) }
		let values = (0..<size).map { 100_000.0 + Double($0) * 500 + Double.random(in: -1000...1000) }
		let ts = TimeSeries(periods: periods, values: values)

		var model = LinearTrend<Double>()

	}
	@Test("Linear trend projection - 1,000 periods")
	func linearTrendProjection() throws {
		let size = 100
		let periods = (0..<size).map { Period.month(year: 2020 + $0/12, month: ($0 % 12) + 1) }
		let values = (0..<size).map { 100_000.0 + Double($0) * 500 }
		let ts = TimeSeries(periods: periods, values: values)

		var model = LinearTrend<Double>()
		try model.fit(to: ts)

	}
	@Test("Exponential trend fitting")
	func exponentialTrendFitting() throws {
		let size = 500
		let periods = (0..<size).map { Period.month(year: 2000 + $0/12, month: ($0 % 12) + 1) }
		let values = (0..<size).map { 100_000.0 * pow(1.01, Double($0)) }
		let ts = TimeSeries(periods: periods, values: values)

		var model = ExponentialTrend<Double>()

	}
	@Test("Logistic trend fitting")
	func logisticTrendFitting() throws {
		let size = 300
		let periods = (0..<size).map { Period.month(year: 2000 + $0/12, month: ($0 % 12) + 1) }
		let capacity = 10_000.0
		let values = (0..<size).map { _ in capacity / (1.0 + exp(Double.random(in: -2...2))) }
		let ts = TimeSeries(periods: periods, values: values)

		var model = LogisticTrend<Double>(capacity: capacity)

	}
	// MARK: - Seasonality Performance

	@Test("Seasonal indices calculation - 10 years monthly")
	func seasonalIndices10Years() throws {
		let size = 120  // 10 years × 12 months
		let periods = (0..<size).map { Period.month(year: 2015 + $0/12, month: ($0 % 12) + 1) }

		// Generate data with seasonal pattern
		let values = (0..<size).map { i -> Double in
			let trend = 100_000.0 + Double(i) * 500
			let seasonal = 1.0 + 0.2 * sin(Double(i % 12) * .pi / 6)
			return trend * seasonal
		}
		let ts = TimeSeries(periods: periods, values: values)

	}
	@Test("Seasonal adjustment - 10 years monthly")
	func seasonalAdjustment10Years() throws {
		let size = 120
		let periods = (0..<size).map { Period.month(year: 2015 + $0/12, month: ($0 % 12) + 1) }
		let values = (0..<size).map { i -> Double in
			let trend = 100_000.0 + Double(i) * 500
			let seasonal = 1.0 + 0.2 * sin(Double(i % 12) * .pi / 6)
			return trend * seasonal
		}
		let ts = TimeSeries(periods: periods, values: values)

		let indices = try seasonalIndices(timeSeries: ts, periodsPerYear: 12)

	}
	@Test("Time series decomposition - 10 years quarterly")
	func decomposition10Years() throws {
		let size = 40  // 10 years × 4 quarters
		let periods = (0..<size).map { Period.quarter(year: 2015 + $0/4, quarter: ($0 % 4) + 1) }
		let values = (0..<size).map { i -> Double in
			let trend = 500_000.0 + Double(i) * 10_000
			let seasonal = [0.9, 1.0, 0.95, 1.15][i % 4]
			return trend * seasonal
		}
		let ts = TimeSeries(periods: periods, values: values)

	}
	// MARK: - Real-World Workflow Performance

	@Test("Complete revenue forecasting workflow")
	func completeRevenueWorkflow() throws {
		// 3 years of monthly historical data
		let historicalSize = 36
		let periods = (0..<historicalSize).map { Period.month(year: 2022 + $0/12, month: ($0 % 12) + 1) }
		let values = (0..<historicalSize).map { i -> Double in
			let trend = 100_000.0 + Double(i) * 1_000
			let seasonal = [0.9, 0.95, 0.95, 1.15, 1.0, 1.05, 0.95, 0.90, 1.0, 1.05, 1.1, 1.2][i % 12]
			return trend * seasonal + Double.random(in: -2000...2000)
		}
		let historical = TimeSeries(periods: periods, values: values)

		let (_, duration) = try measureWithResult { () -> TimeSeries<Double> in
			// 1. Extract seasonality
			let indices = try seasonalIndices(timeSeries: historical, periodsPerYear: 12)

			// 2. Deseasonalize
			let deseasonalized = try seasonallyAdjust(timeSeries: historical, indices: indices)

			// 3. Fit trend
			var trend = LinearTrend<Double>()
			try trend.fit(to: deseasonalized)

			// 4. Project forward 12 months
			let forecast = try trend.project(periods: 12)

			// 5. Reapply seasonality
			return try applySeasonal(timeSeries: forecast, indices: indices)
		}
	}

	@Test("Complete investment analysis workflow")
	func completeInvestmentWorkflow() throws {
		let cashFlows = [-100_000.0, 20_000, 25_000, 30_000, 35_000, 40_000, 45_000, 50_000]
		let rate = 0.12

	}
	// MARK: - Memory Performance

	@Test("Memory usage with large time series")
	func memoryUsageLarge() throws {
		// This test verifies we can create multiple large time series without issues
		let size = 10_000


				let ts = TimeSeries(periods: periods, values: values)
				series.append(ts)
			}
			// Force use of series to prevent optimization
			let totalCount = series.reduce(0) { $0 + $1.count }
			#expect(totalCount == size * 10)
		}
	}
